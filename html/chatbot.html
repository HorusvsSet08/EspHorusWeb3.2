<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Chatbot Meteorol칩gico - Horus</title>
  <link rel="stylesheet" href="../css/style.css" />
  <link rel="stylesheet" href="../css/chatbot.css" />
  <script src="../js/PapaParse.js"></script>
  <script src="../js/chart.js"></script>
</head>
<body class="light-mode chatbot-page">
<nav class="nav">
  <div class="nav-container">
    <div class="nav-buttons">
      <a href="../index.html" class="nav-btn"><span class="nav-icon">游</span> Inicio</a>
      <a href="mqtt.html" class="nav-btn">
        <span class="nav-icon">游니</span> Datos en Vivo
      </a>
      <a href="analisis.html" class="nav-btn">
        <span class="nav-icon">游늵</span> An치lisis
      </a>
      <a href="chatbot.html" class="nav-btn active">
        <span class="nav-icon">游뱄</span> Chatbot
      </a>
    </div>
    <!-- Switch de Galahad -->
    <div class="nav-right">
      <label class="theme-switch">
        <input type="checkbox" class="theme-switch__checkbox">
        <div class="theme-switch__container">
          <div class="theme-switch__clouds"></div>
          <div class="theme-switch__stars-container">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 144 55" fill="none">
            </svg>
          </div>
          <div class="theme-switch__sun-moon-container">
            <div class="theme-switch__moon">
              <div class="theme-switch__spot"></div>
              <div class="theme-switch__spot"></div>
              <div class="theme-switch__spot"></div>
            </div>
          </div>
        </div>
      </label>
    </div>
  </div>
</nav>

<div class="container">
  <header>
    <h1>游뱄 Horus AI - An치lisis Avanzado</h1>
    <p>Un asistente inteligente con an치lisis sem치ntico avanzado y procesamiento profundo de preguntas</p>
  </header>
  
  <main id="chat-container" class="chat-main-container">
    <div id="chat-messages" class="chat-messages">
      <div class="message bot welcome-message">
        <div class="bot-avatar">
          <span>游뱄</span>
        </div>
        <div class="message-content">
          춰Hola! Soy Horus AI, tu asistente meteorol칩gico especializado.<br><br>
          <strong>Puedo ayudarte con:</strong>
          <ul>
            <li>Consultar la temperatura, humedad, presi칩n y otros datos actuales</li>
            <li>Analizar tendencias hist칩ricas de los 칰ltimos d칤as, semanas o meses</li>
            <li>Comparar condiciones meteorol칩gicas entre diferentes periodos</li>
            <li>Predecir condiciones clim치ticas basado en datos hist칩ricos</li>
          </ul>
          <br>
          <strong>Ejemplos de preguntas:</strong>
          <div class="suggestion">쮺u치l es la temperatura actual?</div>
          <div class="suggestion">쮺칩mo ha sido la humedad esta semana?</div>
          <div class="suggestion">Muestra la tendencia de presi칩n de los 칰ltimos 7 d칤as</div>
        </div>
        <div class="message-time">Ahora</div>
      </div>
    </div>
    
    <div class="chat-input-container">
      <input type="text" id="user-input" placeholder="Escribe tu pregunta sobre el clima...">
      <button id="send-button">Enviar</button>
    </div>
    
    <div class="status-bar">
      <div id="status-indicator" class="status-indicator"></div>
      <span id="status-text">Esperando entrada del usuario...</span>
    </div>
  </main>
</div>

<style>
  /* Estilos para el contenedor del chat */
  .chat-main-container {
    max-width: 900px;
    margin: 0 auto;
    background: var(--card-bg);
    border-radius: var(--border-radius);
    overflow: hidden;
    box-shadow: var(--shadow);
  }

  /* Mensajes del chat */
  .chat-messages {
    height: 60vh;
    overflow-y: auto;
    padding: 15px;
    background: var(--dark-bg);
  }

  .message {
    display: flex;
    margin-bottom: 15px;
    animation: fadeIn 0.3s ease;
  }

  .message.user {
    justify-content: flex-end;
  }

  .message.bot {
    justify-content: flex-start;
  }

  .bot-avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: var(--primary);
    display: flex;
    align-items: center;
    justify-content: center;
    margin-right: 10px;
    flex-shrink: 0;
  }

  .bot-avatar span {
    font-size: 20px;
  }

  .message-content {
    background: var(--card-bg);
    color: var(--text);
    padding: 12px 15px;
    border-radius: 18px;
    max-width: 75%;
    line-height: 1.5;
  }

  .message.user .message-content {
    background: var(--primary);
    color: #000;
    border-bottom-right-radius: 5px;
  }

  .message-time {
    font-size: 11px;
    color: var(--text-secondary);
    margin-top: 5px;
    text-align: right;
    opacity: 0.7;
  }

  /* Barra de entrada */
  .chat-input-container {
    display: flex;
    padding: 10px 15px;
    background: var(--card-bg);
    border-top: 1px solid rgba(255, 255, 255, 0.05);
  }

  .chat-input-container input {
    flex: 1;
    padding: 12px 15px;
    border: none;
    background: var(--dark-bg);
    color: var(--text);
    border-radius: 20px 0 0 20px;
    font-size: 16px;
    outline: none;
    transition: var(--transition);
  }

  .chat-input-container input:focus {
    box-shadow: 0 0 0 2px var(--primary-glow);
  }

  .chat-input-container button {
    background: var(--primary);
    color: #000;
    border: none;
    padding: 12px 20px;
    border-radius: 0 20px 20px 0;
    cursor: pointer;
    font-weight: bold;
    transition: var(--transition);
  }

  .chat-input-container button:hover {
    background: #00d0e0;
    transform: translateY(-2px);
  }

  /* Barra de estado */
  .status-bar {
    padding: 8px 15px;
    background: rgba(0, 0, 0, 0.1);
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .status-indicator {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: #4CAF50;
    box-shadow: 0 0 6px rgba(76, 175, 80, 0.7);
  }

  .status-indicator.error {
    background: #f44336;
    box-shadow: 0 0 6px rgba(244, 67, 54, 0.7);
  }

  /* Sugerencias de preguntas */
  .suggestion {
    background: rgba(255, 255, 255, 0.1);
    padding: 8px 12px;
    border-radius: 12px;
    margin: 5px 0;
    cursor: pointer;
    transition: var(--transition);
  }

  .suggestion:hover {
    background: rgba(0, 234, 255, 0.2);
    transform: translateX(5px);
  }

  /* Efecto de escritura */
  .typing-indicator {
    display: inline-flex;
    gap: 4px;
    margin-right: 8px;
  }

  .typing-indicator span {
    width: 6px;
    height: 6px;
    background: var(--primary);
    border-radius: 50%;
    animation: typing 1s infinite;
  }

  .typing-indicator span:nth-child(2) {
    animation-delay: 0.2s;
  }

  .typing-indicator span:nth-child(3) {
    animation-delay: 0.4s;
  }

  @keyframes typing {
    0%, 100% { transform: translateY(0); opacity: 0.5; }
    50% { transform: translateY(-5px); opacity: 1; }
  }

  /* An치lisis de datos */
  .analysis-header {
    margin-bottom: 15px;
  }

  .analysis-header h2 {
    font-size: 1.2rem;
    margin-bottom: 8px;
    color: var(--primary);
  }

  .analysis-header p {
    color: var(--text-secondary);
    font-size: 0.9rem;
  }

  .statistics-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
    margin-bottom: 20px;
  }

  .stat-item {
    background: rgba(0, 234, 255, 0.1);
    padding: 10px;
    border-radius: 8px;
    text-align: center;
  }

  .stat-value {
    font-size: 1.3rem;
    font-weight: bold;
    color: var(--primary);
    display: block;
    margin-top: 5px;
  }

  .trend-analysis {
    background: rgba(0, 0, 0, 0.2);
    padding: 15px;
    border-radius: 10px;
    margin-top: 15px;
  }

  .trend-analysis h3 {
    margin-top: 0;
    color: var(--primary);
  }

  .trend-description {
    color: var(--text-secondary);
  }

  .prediction-container {
    margin-top: 15px;
  }

  .prediction-reliability {
    margin-bottom: 10px;
    font-size: 0.9rem;
  }

  .reliability-bar {
    height: 6px;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 3px;
    margin-top: 4px;
  }

  .reliability-fill {
    height: 100%;
    background: var(--primary);
    border-radius: 3px;
    transition: width 0.5s ease;
  }

  .prediction-chart-container {
    height: 250px;
    margin-top: 10px;
  }

  .chart-title {
    font-weight: bold;
    margin-bottom: 8px;
    color: var(--primary);
    font-size: 1rem;
  }

  .source-badge {
    display: inline-block;
    margin-left: 5px;
    font-size: 0.8rem;
    opacity: 0.7;
  }

  .welcome-message {
    background: rgba(0, 234, 255, 0.05);
    border-radius: 15px;
    padding: 15px;
    border: 1px solid rgba(0, 234, 255, 0.2);
  }
</style>

<script>
  // Variables globales
  let historicalData = [];
  let chatbotReady = false;
  let charts = []; // Para almacenar instancias de gr치ficos
  
  // Contexto de conversaci칩n mejorado
  let conversationContext = {
    lastParameter: null,
    lastPeriod: null,
    lastQuestionType: null,
    conversationHistory: [],
    entityContext: {},
    temporalContext: null,
    spatialContext: null,
    confidenceThreshold: 0.65 // Umbral de confianza para aceptar una intenci칩n
  };

  // Elementos del DOM
  const chatMessages = document.getElementById('chat-messages');
  const userInput = document.getElementById('user-input');
  const sendButton = document.getElementById('send-button');
  const statusIndicator = document.getElementById('status-indicator');
  const statusText = document.getElementById('status-text');

  // Actualizar estado
  const updateStatus = (message, isError = false) => {
    statusText.textContent = message;
    if (isError) {
      statusIndicator.classList.add('error');
    } else {
      statusIndicator.classList.remove('error');
    }
  };

  // A침adir mensaje al chat
  const addMessage = (content, isUser = false, source = 'local') => {
    const messageDiv = document.createElement('div');
    messageDiv.classList.add('message');
    messageDiv.classList.add(isUser ? 'user' : 'bot');
    
    // Marca de fuente para mensajes del bot
    const sourceBadge = source !== 'local' 
      ? `<span class="source-badge" title="Informaci칩n obtenida de: ${source}">${source === 'web' ? '游깷' : source}</span>` 
      : '';
      
    if (isUser) {
      messageDiv.innerHTML = `
        <div class="message-content">${content}</div>
        <div class="message-time">${new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</div>
      `;
    } else {
      messageDiv.innerHTML = `
        <div class="bot-avatar"><span>游뱄</span></div>
        <div class="message-content">${content}${sourceBadge}</div>
        <div class="message-time">Ahora</div>
      `;
    }
    
    chatMessages.appendChild(messageDiv);
    chatMessages.scrollTop = chatMessages.scrollHeight;
    
    // Actualizar el tiempo "Ahora" a minutos reales despu칠s de 5 segundos
    setTimeout(() => {
      const timeElement = messageDiv.querySelector('.message-time');
      if (timeElement && timeElement.textContent === 'Ahora') {
        timeElement.textContent = new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
      }
    }, 5000);
    
    // Guardar en historial de conversaci칩n
    if (!isUser) {
      conversationContext.conversationHistory.push({
        role: 'assistant',
        content,
        timestamp: new Date().toISOString()
      });
    }
  };

  // Mostrar estado de carga
  const showLoading = (message = "Analizando tu pregunta") => {
    const loadingId = `loading-${Date.now()}`;
    const loadingDiv = document.createElement('div');
    loadingDiv.id = loadingId;
    loadingDiv.className = 'message bot';
    loadingDiv.innerHTML = `
      <div class="bot-avatar"><span>游뱄</span></div>
      <div class="message-content">
        <div class="typing-indicator"><span></span><span></span><span></span></div>
        <div class="loading-text">${message}</div>
      </div>
      <div class="message-time">Escribiendo...</div>
    `;
    chatMessages.appendChild(loadingDiv);
    chatMessages.scrollTop = chatMessages.scrollHeight;
    return loadingId;
  };

  // Diccionario de sin칩nimos meteorol칩gicos mejorado
  const weatherSynonyms = {
    temperatura: ['temp', 'calor', 'fr칤o', 'frio', 'grados', '춿', 'celsius', 'cent칤grados', 'centigrados'],
    humedad: ['hum', 'vapor', 'agua', 'porcentaje de agua', '% agua'],
    presi칩n: ['pres', 'atmosf칠rica', 'barom칠trica', 'barometrica', 'hpa', 'mb'],
    lluvia: ['precipitaci칩n', 'precipitacion', 'agua', 'llovizna', 'tormenta', 'lluvioso', 'precipitaciones'],
    viento: ['velocidad del viento', 'r치fagas', 'r치faga', 'r치fagas de viento', 'velocidad viento', 'km/h', 'nudos'],
    gas: ['calidad del aire', 'calidad aire', 'contaminaci칩n', 'contaminacion', 'pm2.5', 'pm10', 'part칤culas', 'particulas'],
    direcci칩n: ['direccion', 'rumbo', 'orientaci칩n', 'orientacion', 'grados', 'norte', 'sur', 'este', 'oeste'],
    an치lisis: ['analisis', 'tendencia', 'tendencias', 'evoluci칩n', 'comportamiento', 'patr칩n', 'patron'],
    predicci칩n: ['prediccion', 'pron칩stico', 'pronostico', 'previsi칩n', 'prevision', 'futuro', 'ma침ana', 'siguiente'],
    actual: ['ahora', 'en este momento', 'en este instante', 'actualidad', 'presente', 'en directo'],
    hist칩rico: ['historico', 'pasado', 'antes', 'anterior', 'anteriores', 'd칤as anteriores', 'semanas anteriores'],
    comparar: ['comparaci칩n', 'comparar', 'compara', 'diferencia', 'vs', 'versus', 'comparativo'],
    m치ximo: ['maximo', 'm치ximo', 'pico', 'peak', 'm치s alto', 'mayor'],
    m칤nimo: ['minimo', 'm칤nimo', 'm치s bajo', 'menor']
  };

  // Mapeo de intenciones mejorado
  const intentMap = {
    current_data: {
      keywords: ['actual', 'ahora', 'en este momento', 'en directo', 'presente', 'en tiempo real', 'hoy'],
      parameters: ['temperatura', 'humedad', 'presi칩n', 'lluvia', 'viento', 'gas', 'direcci칩n'],
      required: []
    },
    historical_trend: {
      keywords: ['tendencia', 'evoluci칩n', 'comportamiento', 'an치lisis', 'analisis', 'patr칩n', 'patron', 'gr치fico', 'grafico', 'historial', 'historico', 'hist칩rico'],
      parameters: ['temperatura', 'humedad', 'presi칩n', 'lluvia', 'viento', 'gas'],
      required: ['period']
    },
    prediction: {
      keywords: ['predicci칩n', 'prediccion', 'pron칩stico', 'pronostico', 'previsi칩n', 'prevision', 'futuro', 'ma침ana', 'siguiente', 'proyecci칩n', 'proyeccion'],
      parameters: ['temperatura', 'humedad', 'presi칩n', 'lluvia', 'viento'],
      required: []
    },
    comparison: {
      keywords: ['comparar', 'comparaci칩n', 'compara', 'diferencia', 'vs', 'versus', 'comparativo', 'entre', 'y'],
      parameters: ['temperatura', 'humedad', 'presi칩n', 'lluvia', 'viento', 'gas'],
      required: ['periods']
    },
    max_min: {
      keywords: ['m치ximo', 'maximo', 'm칤nimo', 'minimo', 'pico', 'peak', 'mayor', 'menor', 'm치s alto', 'm치s bajo'],
      parameters: ['temperatura', 'humedad', 'presi칩n', 'lluvia', 'viento', 'gas'],
      required: ['period']
    },
    greeting: {
      keywords: ['hola', 'buenos d칤as', 'buenos dias', 'buenas tardes', 'hey', 'saludos', 'buen d칤a', 'buen dia', 'buenas noches'],
      parameters: [],
      required: []
    },
    goodbye: {
      keywords: ['adi칩s', 'adios', 'gracias', 'chao', 'hasta luego', 'hasta pronto', 'nos vemos', 'bye', 'grac칤as', 'gracias'],
      parameters: [],
      required: []
    },
    help: {
      keywords: ['ayuda', 'funciona', 'c칩mo', 'como', 'puedo', 'capaz', 'hacer', 'qu칠', 'que', 'preguntar', 'instrucciones', 'ejemplo', 'ejemplos'],
      parameters: [],
      required: []
    }
  };

  // Mapeo de periodos
  const periodMap = {
    'hoy': { type: 'day', value: 1, unit: 'day' },
    'ayer': { type: 'day', value: 1, unit: 'day', offset: 1 },
    '칰ltimas 24 horas': { type: 'hour', value: 24, unit: 'hour' },
    '칰ltimas 12 horas': { type: 'hour', value: 12, unit: 'hour' },
    'esta ma침ana': { type: 'morning', value: 1, unit: 'day' },
    'esta tarde': { type: 'afternoon', value: 1, unit: 'day' },
    'esta noche': { type: 'night', value: 1, unit: 'day' },
    'esta semana': { type: 'week', value: 1, unit: 'week' },
    'esta semana pasada': { type: 'week', value: 1, unit: 'week', offset: 1 },
    '칰ltimos 7 d칤as': { type: 'day', value: 7, unit: 'day' },
    '칰ltimos 14 d칤as': { type: 'day', value: 14, unit: 'day' },
    '칰ltimos 30 d칤as': { type: 'day', value: 30, unit: 'day' },
    'este mes': { type: 'month', value: 1, unit: 'month' },
    'este a침o': { type: 'year', value: 1, unit: 'year' },
    '칰ltimo mes': { type: 'month', value: 1, unit: 'month', offset: 1 },
    '칰ltimo a침o': { type: 'year', value: 1, unit: 'year', offset: 1 }
  };

  // Diccionario para correcci칩n ortogr치fica
  const spellingDictionary = {
    'tempertura': 'temperatura',
    'temperaruta': 'temperatura',
    'humedad': 'humedad',
    'humead': 'humedad',
    'umedad': 'humedad',
    'presion': 'presi칩n',
    'presion': 'presi칩n',
    'presion atmosferica': 'presi칩n atmosf칠rica',
    'presion atmosferica': 'presi칩n atmosf칠rica',
    'presion barometrica': 'presi칩n barom칠trica',
    'presion barometrica': 'presi칩n barom칠trica',
    'lluvia': 'lluvia',
    'llubia': 'lluvia',
    'lubia': 'lluvia',
    'viento': 'viento',
    'biento': 'viento',
    'bientto': 'viento',
    'gas': 'gas',
    'calidad del aire': 'calidad del aire',
    'calidad aire': 'calidad del aire',
    'direccion': 'direcci칩n',
    'direccion del viento': 'direcci칩n del viento',
    'direccion viento': 'direcci칩n del viento'
  };

  // Sistema de an치lisis sem치ntico mejorado
  const semanticAnalysis = {
    // Analiza el dominio de la pregunta
    analyzeDomain: (text) => {
      const weatherKeywords = [
        'temperatura', 'calor', 'fr칤o', 'frio', 'grados', 
        'humedad', 'agua', 'presi칩n', 'atmosf칠rica', 'barom칠trica',
        'lluvia', 'precipitaci칩n', 'viento', 'r치fagas', 'gas',
        'calidad del aire', 'direcci칩n', 'clima', 'meteorol칩gico',
        'meteorologico', 'tiempo', 'nublado', 'soleado', 'nubes'
      ];
      
      let matchCount = 0;
      const normalizedText = text.toLowerCase();
      
      weatherKeywords.forEach(keyword => {
        if (normalizedText.includes(keyword)) {
          matchCount++;
        }
      });
      
      // Si encontramos al menos 1 palabra clave meteorol칩gica, es una pregunta sobre clima
      return {
        isWeatherQuestion: matchCount > 0,
        confidence: Math.min(1.0, matchCount * 0.2)
      };
    },
    
    // Identifica entidades en el texto
    identifyEntities: (text) => {
      const entities = {
        parameters: [],
        periods: [],
        locations: [],
        numbers: []
      };
      
      const normalizedText = text.toLowerCase();
      
      // Identificar par치metros meteorol칩gicos
      Object.keys(weatherSynonyms).forEach(param => {
        // Verificar el par치metro principal
        if (normalizedText.includes(param)) {
          entities.parameters.push(param);
        }
        
        // Verificar sin칩nimos
        weatherSynonyms[param].forEach(synonym => {
          if (normalizedText.includes(synonym)) {
            entities.parameters.push(param);
          }
        });
      });
      
      // Identificar periodos
      Object.keys(periodMap).forEach(period => {
        if (normalizedText.includes(period)) {
          entities.periods.push(period);
        }
      });
      
      // Identificar n칰meros
      const numberMatches = text.match(/\d+/g);
      if (numberMatches) {
        entities.numbers = numberMatches.map(num => parseInt(num));
      }
      
      // Eliminar duplicados
      entities.parameters = [...new Set(entities.parameters)];
      entities.periods = [...new Set(entities.periods)];
      
      return entities;
    },
    
    // Analiza la intenci칩n del usuario
    analyzeIntent: (text, entities, domainAnalysis) => {
      if (!domainAnalysis.isWeatherQuestion) {
        // Verificar si es un saludo o despedida incluso si no es meteorol칩gico
        if (semanticAnalysis.isGreeting(text)) return { type: 'greeting', confidence: 0.9 };
        if (semanticAnalysis.isGoodbye(text)) return { type: 'goodbye', confidence: 0.9 };
        if (semanticAnalysis.isHelpRequest(text)) return { type: 'help', confidence: 0.8 };
        
        return { type: 'unrelated', confidence: 1.0 };
      }
      
      let bestIntent = null;
      let highestConfidence = 0;
      
      // Analizar cada posible intenci칩n
      Object.keys(intentMap).forEach(intentType => {
        const intent = intentMap[intentType];
        let confidence = 0;
        
        // Calcular coincidencia con palabras clave
        intent.keywords.forEach(keyword => {
          if (text.toLowerCase().includes(keyword)) {
            confidence += 0.2;
          }
        });
        
        // Aumentar confianza si se encontraron par치metros relevantes
        if (entities.parameters.length > 0) {
          const commonParams = entities.parameters.filter(p => intent.parameters.includes(p));
          confidence += commonParams.length * 0.15;
        }
        
        // Aumentar confianza si se encontraron periodos y la intenci칩n los requiere
        if (intent.required.includes('period') && entities.periods.length > 0) {
          confidence += 0.2;
        }
        
        // Aumentar confianza si se encontraron m칰ltiples periodos y la intenci칩n los requiere
        if (intent.required.includes('periods') && entities.periods.length > 1) {
          confidence += 0.25;
        }
        
        // Ajustar confianza seg칰n el dominio
        confidence *= domainAnalysis.confidence;
        
        // Verificar si es la mejor intenci칩n hasta ahora
        if (confidence > highestConfidence) {
          highestConfidence = confidence;
          bestIntent = {
            type: intentType,
            confidence: confidence,
            parameters: entities.parameters,
            periods: entities.periods
          };
        }
      });
      
      // Si no se encontr칩 una intenci칩n clara pero hay par치metros, asumir que es una consulta actual
      if (!bestIntent && entities.parameters.length > 0) {
        return {
          type: 'current_data',
          confidence: 0.7,
          parameters: entities.parameters,
          periods: ['hoy']
        };
      }
      
      return bestIntent || { type: 'unrecognized', confidence: 0 };
    },
    
    // Verifica si es un saludo
    isGreeting: (text) => {
      const greetings = intentMap.greeting.keywords;
      const normalizedText = text.toLowerCase();
      
      return greetings.some(greeting => normalizedText.includes(greeting));
    },
    
    // Verifica si es una despedida
    isGoodbye: (text) => {
      const goodbyes = intentMap.goodbye.keywords;
      const normalizedText = text.toLowerCase();
      
      return goodbyes.some(goodbye => normalizedText.includes(goodbye));
    },
    
    // Verifica si es una solicitud de ayuda
    isHelpRequest: (text) => {
      const helpKeywords = intentMap.help.keywords;
      const normalizedText = text.toLowerCase();
      
      return helpKeywords.some(keyword => normalizedText.includes(keyword));
    }
  };

  // Sistema de correcci칩n ortogr치fica CORREGIDO
  const spellingCorrection = {
    // Calcula la distancia de Levenshtein entre dos strings
    levenshteinDistance: function(a, b) {
      if (a.length === 0) return b.length;
      if (b.length === 0) return a.length;
      
      const matrix = [];
      
      for (let i = 0; i <= b.length; i++) {
        matrix[i] = [i];
      }
      
      for (let j = 0; j <= a.length; j++) {
        matrix[0][j] = j;
      }
      
      for (let i = 1; i <= b.length; i++) {
        for (let j = 1; j <= a.length; j++) {
          if (b.charAt(i - 1) === a.charAt(j - 1)) {
            matrix[i][j] = matrix[i - 1][j - 1];
          } else {
            matrix[i][j] = Math.min(
              matrix[i - 1][j - 1] + 1, // Sustituci칩n
              matrix[i][j - 1] + 1, // Inserci칩n
              matrix[i - 1][j] + 1 // Eliminaci칩n
            );
          }
        }
      }
      
      return matrix[b.length][a.length];
    },
    
    // Corrige la ortograf칤a de una palabra
    correctWord: function(word) {
      // Si la palabra est치 en el diccionario, devolver la correcci칩n
      if (spellingDictionary[word.toLowerCase()]) {
        return spellingDictionary[word.toLowerCase()];
      }
      
      // Buscar en el diccionario de sin칩nimos
      for (const [correct, synonyms] of Object.entries(weatherSynonyms)) {
        for (const synonym of synonyms) {
          if (word.toLowerCase() === synonym) {
            return correct;
          }
          
          // Calcular distancia de Levenshtein para correcci칩n aproximada
          const distance = this.levenshteinDistance(word.toLowerCase(), synonym);
          if (distance <= Math.max(1, Math.floor(synonym.length * 0.2))) {
            return correct;
          }
        }
      }
      
      return word;
    },
    
    // Corrige todo el mensaje
    correctMessage: function(message) {
      const words = message.split(/\s+/);
      let correctedWords = [];
      let foundCorrection = false;
      
      words.forEach(word => {
        // Mantener signos de puntuaci칩n
        const cleanWord = word.replace(/[.,!?;:]/g, '');
        const punctuation = word.match(/[.,!?;:]+$/);
        
        if (cleanWord.length > 2) {
          // CORRECCI칍N: Usar spellingCorrection.correctWord en lugar de this.correctWord
          const corrected = spellingCorrection.correctWord(cleanWord);
          if (corrected !== cleanWord) {
            correctedWords.push(corrected + (punctuation ? punctuation[0] : ''));
            foundCorrection = true;
          } else {
            correctedWords.push(word);
          }
        } else {
          correctedWords.push(word);
        }
      });
      
      return {
        correctedMessage: correctedWords.join(' '),
        hasCorrection: foundCorrection
      };
    }
  };

  // Cargar datos hist칩ricos (simulaci칩n)
  const loadHistoricalData = async () => {
    updateStatus("Cargando datos hist칩ricos...");
    
    return new Promise((resolve) => {
      // Simulaci칩n de carga de datos
      setTimeout(() => {
        // Generar datos simulados para los 칰ltimos 30 d칤as
        const now = new Date();
        historicalData = [];
        
        for (let i = 29; i >= 0; i--) {
          const date = new Date(now);
          date.setDate(now.getDate() - i);
          
          historicalData.push({
            timestamp: date.toISOString(),
            temp: 20 + Math.random() * 10 - 5 * (i/30),
            hum: 60 + Math.random() * 20 - 10 * (i/30),
            pres: 1013 + Math.random() * 5 - 2 * (i/30),
            lluvia: i < 5 ? 1 : 0,
            wind: 5 + Math.random() * 10,
            wind_dir: Math.floor(Math.random() * 360),
            gas: 1.0 + Math.random() * 0.5
          });
        }
        
        resolve();
      }, 800);
    });
  };

  // Manejadores de intenciones
  const intentHandlers = {
    current_data: (entities, context) => {
      // Si no hay par치metros espec칤ficos, usar el 칰ltimo par치metro mencionado o uno por defecto
      let parameters = entities.parameters.length > 0 ? entities.parameters : 
                      (context.lastParameter ? [context.lastParameter] : ['temperatura']);
      
      // Actualizar contexto
      conversationContext.lastParameter = parameters[0];
      conversationContext.lastQuestionType = 'current_data';
      
      // Obtener el dato actual
      const latestData = historicalData[historicalData.length - 1];
      let response = '';
      
      parameters.forEach(param => {
        switch(param) {
          case 'temperatura':
            response += `La temperatura actual es de ${latestData.temp.toFixed(1)}춿C.\n`;
            break;
          case 'humedad':
            response += `La humedad actual es del ${latestData.hum.toFixed(0)}%.\n`;
            break;
          case 'presi칩n':
            response += `La presi칩n atmosf칠rica actual es de ${latestData.pres.toFixed(0)} hPa.\n`;
            break;
          case 'lluvia':
            response += `Actualmente ${latestData.lluvia ? 'est치 lloviendo' : 'no est치 lloviendo'}.\n`;
            break;
          case 'viento':
            response += `La velocidad del viento actual es de ${latestData.wind.toFixed(1)} m/s (${(latestData.wind * 3.6).toFixed(1)} km/h).\n`;
            break;
          case 'gas':
            response += `El nivel de gas actual es de ${latestData.gas.toFixed(2)} k풜.\n`;
            break;
          case 'direcci칩n':
            const directions = ['N', 'NE', 'E', 'ENE', 'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'];
            const index = Math.round((latestData.wind_dir % 360) / 30) % 12;
            response += `La direcci칩n del viento actual es ${directions[index]} (${latestData.wind_dir}춿).\n`;
            break;
        }
      });
      
      // A침adir sugerencia para an치lisis m치s detallado
      if (parameters.length === 1) {
        response += `\n쯊e gustar칤a ver un an치lisis hist칩rico de ${parameters[0]} o una predicci칩n para los pr칩ximos d칤as?`;
      }
      
      return response.trim();
    },
    
    historical_trend: (entities, context) => {
      // Determinar el periodo
      let period = entities.periods.length > 0 ? entities.periods[0] : 
                  (context.lastPeriod ? context.lastPeriod : '칰ltimos 7 d칤as');
      
      // Actualizar contexto
      conversationContext.lastPeriod = period;
      conversationContext.lastQuestionType = 'historical_trend';
      
      // Obtener datos para el periodo
      const periodInfo = periodMap[period] || periodMap['칰ltimos 7 d칤as'];
      const now = new Date();
      let startDate;
      
      if (periodInfo.type === 'day') {
        startDate = new Date(now);
        startDate.setDate(now.getDate() - periodInfo.value);
      } else if (periodInfo.type === 'week') {
        startDate = new Date(now);
        startDate.setDate(now.getDate() - (periodInfo.value * 7));
      } else if (periodInfo.type === 'month') {
        startDate = new Date(now);
        startDate.setMonth(now.getMonth() - periodInfo.value);
      }
      
      // Si no hay par치metros espec칤ficos, usar el 칰ltimo par치metro mencionado o uno por defecto
      let parameters = entities.parameters.length > 0 ? entities.parameters : 
                      (context.lastParameter ? [context.lastParameter] : ['temperatura']);
      
      // Preparar datos para el gr치fico
      const chartData = historicalData
        .filter(data => new Date(data.timestamp) >= startDate)
        .map(data => ({
          x: new Date(data.timestamp),
          y: data[parameters[0] === 'presi칩n' ? 'pres' : 
                 parameters[0] === 'lluvia' ? 'lluvia' : 
                 parameters[0]]
        }));
      
      // Generar la respuesta basada en el an치lisis de los datos
      const response = analyzeData(parameters[0], chartData, periodInfo);
      
      // A침ade un gr치fico de an치lisis
      const chartId = `prediction-chart-${Date.now()}`;
      const chartResponse = `
        <div class="prediction-chart-container">
          <div class="chart-title">Tendencia de ${parameters[0]} en ${period}</div>
          <canvas class="prediction-chart" id="${chartId}" 
                  data-parameter="${parameters[0]}" 
                  data-chart-data='${JSON.stringify(chartData)}'></canvas>
        </div>
      `;
      
      return response + chartResponse;
    },
    
    prediction: (entities, context) => {
      // Si no hay par치metros espec칤ficos, usar el 칰ltimo par치metro mencionado o uno por defecto
      let parameters = entities.parameters.length > 0 ? entities.parameters : 
                      (context.lastParameter ? [context.lastParameter] : ['temperatura']);
      
      // Actualizar contexto
      conversationContext.lastParameter = parameters[0];
      conversationContext.lastQuestionType = 'prediction';
      
      // Generar datos de predicci칩n simulados
      const predictionData = [];
      const now = new Date();
      const latestData = historicalData[historicalData.length - 1];
      
      for (let i = 0; i < 5; i++) {
        const date = new Date(now);
        date.setDate(now.getDate() + i);
        
        let value;
        switch(parameters[0]) {
          case 'temperatura':
            value = latestData.temp + (Math.random() - 0.5) * 3;
            break;
          case 'humedad':
            value = latestData.hum + (Math.random() - 0.5) * 10;
            break;
          case 'presi칩n':
            value = latestData.pres + (Math.random() - 0.5) * 3;
            break;
          case 'viento':
            value = latestData.wind + (Math.random() - 0.5) * 2;
            break;
          default:
            value = latestData.temp + (Math.random() - 0.5) * 3;
        }
        
        predictionData.push({
          x: date,
          y: value
        });
      }
      
      // Generar respuesta
      let response = '';
      const nextDay = new Date(now);
      nextDay.setDate(now.getDate() + 1);
      
      switch(parameters[0]) {
        case 'temperatura':
          response = `Para ma침ana ${nextDay.toLocaleDateString('es-ES', { weekday: 'long' })}, la temperatura se espera que est칠 entre ${(latestData.temp - 1).toFixed(1)}춿C y ${(latestData.temp + 2).toFixed(1)}춿C.\n\n`;
          response += `La tendencia a corto plazo sugiere ${latestData.temp < predictionData[1].y ? 'un aumento' : 'una disminuci칩n'} en la temperatura.\n\n`;
          break;
        case 'humedad':
          response = `Para ma침ana ${nextDay.toLocaleDateString('es-ES', { weekday: 'long' })}, la humedad se espera que est칠 alrededor del ${(latestData.hum + (Math.random() * 5 - 2.5)).toFixed(0)}%.\n\n`;
          response += `La tendencia a corto plazo sugiere ${latestData.hum < predictionData[1].y ? 'un aumento' : 'una disminuci칩n'} en la humedad.\n\n`;
          break;
        case 'presi칩n':
          response = `Para ma침ana ${nextDay.toLocaleDateString('es-ES', { weekday: 'long' })}, la presi칩n atmosf칠rica se espera que est칠 alrededor de ${(latestData.pres + (Math.random() * 3 - 1.5)).toFixed(0)} hPa.\n\n`;
          response += `La tendencia a corto plazo sugiere ${latestData.pres < predictionData[1].y ? 'un aumento' : 'una disminuci칩n'} en la presi칩n.\n\n`;
          break;
        case 'viento':
          response = `Para ma침ana ${nextDay.toLocaleDateString('es-ES', { weekday: 'long' })}, la velocidad del viento se espera que est칠 alrededor de ${(latestData.wind + (Math.random() * 2 - 1)).toFixed(1)} m/s.\n\n`;
          response += `La tendencia a corto plazo sugiere ${latestData.wind < predictionData[1].y ? 'un aumento' : 'una disminuci칩n'} en la velocidad del viento.\n\n`;
          break;
        default:
          response = `Para ma침ana ${nextDay.toLocaleDateString('es-ES', { weekday: 'long' })}, se espera que ${parameters[0]} muestre una tendencia ${latestData.temp < predictionData[1].y ? 'ascendente' : 'descendente'}.\n\n`;
      }
      
      response += `Esta predicci칩n se basa en el an치lisis de los datos hist칩ricos de los 칰ltimos 30 d칤as y tiene una confiabilidad estimada del 75%.`;
      
      // A침ade un gr치fico de predicci칩n
      const chartId = `prediction-chart-${Date.now()}`;
      const reliability = 75;
      
      const chartResponse = `
        <div class="prediction-container">
          <div class="prediction-reliability">
            Confiabilidad de la predicci칩n: ${reliability}% 
            <div class="reliability-bar">
              <div class="reliability-fill" style="width: ${reliability}%"></div>
            </div>
          </div>
          <div class="prediction-chart-container">
            <div class="chart-title">Predicci칩n de ${parameters[0]} para los pr칩ximos 5 d칤as</div>
            <canvas class="prediction-chart" id="${chartId}" 
                    data-parameter="${parameters[0]}" 
                    data-chart-data='${JSON.stringify(predictionData)}'></canvas>
          </div>
        </div>
      `;
      
      return response + chartResponse;
    },
    
    comparison: (entities, context) => {
      // Necesitamos al menos dos periodos para comparar
      if (entities.periods.length < 2) {
        return "Para hacer una comparaci칩n necesito dos periodos. Por ejemplo: 'Compara la temperatura de esta semana con la semana pasada'.";
      }
      
      const period1 = entities.periods[0];
      const period2 = entities.periods[1];
      
      // Actualizar contexto
      conversationContext.lastPeriod = period1;
      conversationContext.lastQuestionType = 'comparison';
      
      // Si no hay par치metros espec칤ficos, usar el 칰ltimo par치metro mencionado o uno por defecto
      let parameters = entities.parameters.length > 0 ? entities.parameters : 
                      (context.lastParameter ? [context.lastParameter] : ['temperatura']);
      
      // Obtener datos para ambos periodos
      const periodInfo1 = periodMap[period1] || periodMap['esta semana'];
      const periodInfo2 = periodMap[period2] || periodMap['칰ltimos 7 d칤as'];
      
      const now = new Date();
      let startDate1, startDate2;
      
      // Calcular fechas de inicio para ambos periodos
      if (periodInfo1.type === 'day') {
        startDate1 = new Date(now);
        startDate1.setDate(now.getDate() - periodInfo1.value);
      } else if (periodInfo1.type === 'week') {
        startDate1 = new Date(now);
        startDate1.setDate(now.getDate() - (periodInfo1.value * 7));
      } else if (periodInfo1.type === 'month') {
        startDate1 = new Date(now);
        startDate1.setMonth(now.getMonth() - periodInfo1.value);
      }
      
      if (periodInfo2.type === 'day') {
        startDate2 = new Date(now);
        startDate2.setDate(now.getDate() - periodInfo2.value);
      } else if (periodInfo2.type === 'week') {
        startDate2 = new Date(now);
        startDate2.setDate(now.getDate() - (periodInfo2.value * 7));
      } else if (periodInfo2.type === 'month') {
        startDate2 = new Date(now);
        startDate2.setMonth(now.getMonth() - periodInfo2.value);
      }
      
      // Obtener datos para ambos periodos
      const data1 = historicalData.filter(data => new Date(data.timestamp) >= startDate1);
      const data2 = historicalData.filter(data => new Date(data.timestamp) >= startDate2);
      
      // Calcular promedios
      const avg1 = data1.reduce((sum, item) => sum + item[parameters[0] === 'presi칩n' ? 'pres' : 
                                     parameters[0] === 'lluvia' ? 'lluvia' : 
                                     parameters[0]], 0) / data1.length;
      const avg2 = data2.reduce((sum, item) => sum + item[parameters[0] === 'presi칩n' ? 'pres' : 
                                     parameters[0] === 'lluvia' ? 'lluvia' : 
                                     parameters[0]], 0) / data2.length;
      
      // Generar respuesta
      let response = `Comparaci칩n de ${parameters[0]} entre ${period1} y ${period2}:\n\n`;
      
      response += `* ${period1.charAt(0).toUpperCase() + period1.slice(1)}: ${avg1.toFixed(2)}\n`;
      response += `* ${period2.charAt(0).toUpperCase() + period2.slice(1)}: ${avg2.toFixed(2)}\n\n`;
      
      const difference = avg1 - avg2;
      if (Math.abs(difference) > 0.01) {
        const percentChange = (Math.abs(difference) / avg2) * 100;
        if (difference > 0) {
          response += `La ${parameters[0]} fue ${percentChange.toFixed(1)}% mayor en ${period1} que en ${period2}.`;
        } else {
          response += `La ${parameters[0]} fue ${percentChange.toFixed(1)}% menor en ${period1} que en ${period2}.`;
        }
      } else {
        response += `La ${parameters[0]} fue muy similar en ambos periodos.`;
      }
      
      // Preparar datos para el gr치fico comparativo
      const chartData1 = data1.map(data => ({
        x: new Date(data.timestamp),
        y: data[parameters[0] === 'presi칩n' ? 'pres' : 
               parameters[0] === 'lluvia' ? 'lluvia' : 
               parameters[0]]
      }));
      
      const chartData2 = data2.map(data => ({
        x: new Date(data.timestamp),
        y: data[parameters[0] === 'presi칩n' ? 'pres' : 
               parameters[0] === 'lluvia' ? 'lluvia' : 
               parameters[0]]
      }));
      
      // A침ade un gr치fico comparativo
      const chartId = `comparison-chart-${Date.now()}`;
      const chartResponse = `
        <div class="comparison-chart-container">
          <div class="chart-title">Comparaci칩n de ${parameters[0]}: ${period1} vs ${period2}</div>
          <canvas class="comparison-chart" id="${chartId}" 
                  data-parameter="${parameters[0]}" 
                  data-chart-data1='${JSON.stringify(chartData1)}'
                  data-chart-data2='${JSON.stringify(chartData2)}'
                  data-period1="${period1}"
                  data-period2="${period2}"></canvas>
        </div>
      `;
      
      return response + chartResponse;
    },
    
    max_min: (entities, context) => {
      // Determinar el periodo
      let period = entities.periods.length > 0 ? entities.periods[0] : 
                  (context.lastPeriod ? context.lastPeriod : '칰ltimos 7 d칤as');
      
      // Actualizar contexto
      conversationContext.lastPeriod = period;
      conversationContext.lastQuestionType = 'max_min';
      
      // Obtener datos para el periodo
      const periodInfo = periodMap[period] || periodMap['칰ltimos 7 d칤as'];
      const now = new Date();
      let startDate;
      
      if (periodInfo.type === 'day') {
        startDate = new Date(now);
        startDate.setDate(now.getDate() - periodInfo.value);
      } else if (periodInfo.type === 'week') {
        startDate = new Date(now);
        startDate.setDate(now.getDate() - (periodInfo.value * 7));
      } else if (periodInfo.type === 'month') {
        startDate = new Date(now);
        startDate.setMonth(now.getMonth() - periodInfo.value);
      }
      
      // Si no hay par치metros espec칤ficos, usar el 칰ltimo par치metro mencionado o uno por defecto
      let parameters = entities.parameters.length > 0 ? entities.parameters : 
                      (context.lastParameter ? [context.lastParameter] : ['temperatura']);
      
      // Obtener datos para el periodo
      const periodData = historicalData.filter(data => new Date(data.timestamp) >= startDate);
      
      // Encontrar m치ximos y m칤nimos
      let max = -Infinity;
      let min = Infinity;
      let maxDate, minDate;
      
      periodData.forEach(data => {
        const value = data[parameters[0] === 'presi칩n' ? 'pres' : 
                         parameters[0] === 'lluvia' ? 'lluvia' : 
                         parameters[0]];
                         
        if (value > max) {
          max = value;
          maxDate = data.timestamp;
        }
        
        if (value < min) {
          min = value;
          minDate = data.timestamp;
        }
      });
      
      // Generar respuesta
      let response = `En ${period}, el valor m치ximo de ${parameters[0]} fue de ${max.toFixed(2)}`;
      
      if (parameters[0] !== 'lluvia' && parameters[0] !== 'direcci칩n') {
        response += ` ${parameters[0] === 'presi칩n' ? 'hPa' : 
                    parameters[0] === 'humedad' ? '%' : 
                    '춿C'}`;
      }
      
      response += ` registrado el ${new Date(maxDate).toLocaleDateString('es-ES', { 
        weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' 
      })}.\n\n`;
      
      response += `El valor m칤nimo fue de ${min.toFixed(2)}`;
      
      if (parameters[0] !== 'lluvia' && parameters[0] !== 'direcci칩n') {
        response += ` ${parameters[0] === 'presi칩n' ? 'hPa' : 
                    parameters[0] === 'humedad' ? '%' : 
                    '춿C'}`;
      }
      
      response += ` registrado el ${new Date(minDate).toLocaleDateString('es-ES', { 
        weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' 
      })}.`;
      
      // Preparar datos para el gr치fico
      const chartData = historicalData
        .filter(data => new Date(data.timestamp) >= startDate)
        .map(data => ({
          x: new Date(data.timestamp),
          y: data[parameters[0] === 'presi칩n' ? 'pres' : 
                 parameters[0] === 'lluvia' ? 'lluvia' : 
                 parameters[0]]
        }));
      
      // A침ade un gr치fico con marcadores de m치ximos y m칤nimos
      const chartId = `extremes-chart-${Date.now()}`;
      const chartResponse = `
        <div class="extremes-chart-container">
          <div class="chart-title">Valores extremos de ${parameters[0]} en ${period}</div>
          <canvas class="extremes-chart" id="${chartId}" 
                  data-parameter="${parameters[0]}" 
                  data-chart-data='${JSON.stringify(chartData)}'
                  data-max-date="${maxDate}"
                  data-min-date="${minDate}"></canvas>
        </div>
      `;
      
      return response + chartResponse;
    },
    
    greeting: () => {
      const hours = new Date().getHours();
      let greeting;
      
      if (hours < 12) {
        greeting = "춰Buenos d칤as! ";
      } else if (hours < 18) {
        greeting = "춰Buenas tardes! ";
      } else {
        greeting = "춰Buenas noches! ";
      }
      
      return `${greeting}Soy Horus AI, tu asistente meteorol칩gico especializado. 쮼n qu칠 puedo ayudarte hoy?`;
    },
    
    goodbye: () => {
      return "춰Hasta luego! No dudes en volver si necesitas m치s informaci칩n meteorol칩gica.";
    },
    
    help: () => {
      return `Puedo ayudarte con consultas meteorol칩gicas como:\n\n` +
             `- Consultar datos actuales: "쮺u치l es la temperatura ahora?"\n` +
             `- Analizar tendencias hist칩ricas: "Muestra la tendencia de humedad esta semana"\n` +
             `- Comparar periodos: "Compara la presi칩n de esta semana con la semana pasada"\n` +
             `- Predecir condiciones: "쯈u칠 tiempo har치 ma침ana?"\n` +
             `- Encontrar valores extremos: "쮺u치l fue la temperatura m치xima esta semana?"\n\n` +
             `쯉obre qu칠 par치metro meteorol칩gico te gustar칤a obtener informaci칩n?`;
    }
  };

  // Analiza los datos para generar una respuesta descriptiva
  const analyzeData = (parameter, chartData, periodInfo) => {
    if (chartData.length === 0) {
      return "No hay datos disponibles para el periodo seleccionado.";
    }
    
    // Calcular estad칤sticas
    const values = chartData.map(item => item.y);
    const sum = values.reduce((a, b) => a + b, 0);
    const average = sum / values.length;
    const max = Math.max(...values);
    const min = Math.min(...values);
    
    // Determinar tendencia
    const startValue = values[0];
    const endValue = values[values.length - 1];
    const trend = endValue > startValue ? "ascendente" : "descendente";
    const trendStrength = Math.abs(endValue - startValue) / startValue;
    
    // Generar respuesta
    let response = `En el periodo seleccionado (${periodInfo.type === 'day' ? periodInfo.value + ' d칤as' : periodInfo.type}):`;
    
    // Descripci칩n general
    response += `\n\n* Promedio de ${parameter}: ${average.toFixed(2)}`;
    if (parameter !== 'lluvia' && parameter !== 'direcci칩n') {
      response += ` ${parameter === 'presi칩n' ? 'hPa' : 
                  parameter === 'humedad' ? '%' : 
                  '춿C'}`;
    }
    
    response += `\n* Valor m치ximo: ${max.toFixed(2)}`;
    if (parameter !== 'lluvia' && parameter !== 'direcci칩n') {
      response += ` ${parameter === 'presi칩n' ? 'hPa' : 
                  parameter === 'humedad' ? '%' : 
                  '춿C'}`;
    }
    
    response += `\n* Valor m칤nimo: ${min.toFixed(2)}`;
    if (parameter !== 'lluvia' && parameter !== 'direcci칩n') {
      response += ` ${parameter === 'presi칩n' ? 'hPa' : 
                  parameter === 'humedad' ? '%' : 
                  '춿C'}`;
    }
    
    // An치lisis de tendencia
    if (trendStrength > 0.05) { // Si hay una tendencia significativa
      response += `\n\nLa tendencia es claramente ${trend} (${(trendStrength * 100).toFixed(1)}% de cambio).`;
      
      if (parameter === 'temperatura') {
        response += trend === 'ascendente' ? 
          ' Esto sugiere un calentamiento progresivo en el periodo analizado.' :
          ' Esto sugiere un enfriamiento progresivo en el periodo analizado.';
      } else if (parameter === 'humedad') {
        response += trend === 'ascendente' ? 
          ' El aumento de humedad podr칤a indicar mayor probabilidad de precipitaci칩n.' :
          ' La disminuci칩n de humedad sugiere condiciones m치s secas.';
      } else if (parameter === 'presi칩n') {
        response += trend === 'ascendente' ? 
          ' El aumento de presi칩n suele indicar condiciones clim치ticas estables y buen tiempo.' :
          ' La disminuci칩n de presi칩n suele preceder a condiciones clim치ticas inestables.';
      }
    } else {
      response += `\n\nLa tendencia es relativamente estable sin cambios significativos.`;
    }
    
    return response;
  };

  // Renderizar gr치ficos
  const renderChart = (parameter, chartData, chartId) => {
    const chartCtx = document.getElementById(chartId)?.getContext('2d');
    if (!chartCtx) return;
    
    // Determina el nombre del par치metro y colores
    let paramName = '';
    let color = '#4a90e2';
    let unit = '';
    
    switch (parameter) {
      case 'temperatura':
        paramName = 'Temperatura';
        color = '#FF6384';
        unit = '춿C';
        break;
      case 'humedad':
        paramName = 'Humedad';
        color = '#36A2EB';
        unit = '%';
        break;
      case 'presi칩n':
        paramName = 'Presi칩n Atmosf칠rica';
        color = '#FFCE56';
        unit = 'hPa';
        break;
      case 'lluvia':
        paramName = 'Precipitaci칩n';
        color = '#46BFBD';
        unit = 'Presencia';
        break;
      case 'viento':
        paramName = 'Viento';
        color = '#C9CBCF';
        unit = 'm/s';
        break;
      case 'gas':
        paramName = 'Nivel de Gas';
        color = '#FDB45C';
        unit = 'k풜';
        break;
      case 'direcci칩n':
        paramName = 'Direcci칩n del Viento';
        color = '#9966FF';
        unit = '춿';
        break;
      default:
        paramName = 'Medici칩n';
        unit = '';
    }
    
    // Crea el nuevo gr치fico
    const chart = new Chart(chartCtx, {
      type: 'line',
      data: {
        datasets: [{
          label: paramName,
          data: chartData,
          borderColor: color,
          backgroundColor: `${color}40`,
          borderWidth: 3,
          tension: 0.3,
          pointRadius: 3
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            display: false
          },
          tooltip: {
            mode: 'index',
            intersect: false
          }
        },
        scales: {
          x: {
            type: 'time',
            time: {
              unit: 'day'
            },
            title: {
              display: true,
              text: 'Fecha'
            }
          },
          y: {
            beginAtZero: false,
            title: {
              display: true,
              text: unit
            }
          }
        }
      }
    });
    
    // Almacenar instancia del gr치fico para actualizarla al cambiar de tema
    charts.push(chart);
  };
  
  // Renderizar gr치ficos de comparaci칩n
  const renderComparisonChart = (parameter, chartData1, chartData2, period1, period2, chartId) => {
    const chartCtx = document.getElementById(chartId)?.getContext('2d');
    if (!chartCtx) return;
    
    // Determina el nombre del par치metro y colores
    let paramName = '';
    let color1 = '#FF6384';
    let color2 = '#36A2EB';
    let unit = '';
    
    switch (parameter) {
      case 'temperatura':
        paramName = 'Temperatura';
        unit = '춿C';
        break;
      case 'humedad':
        paramName = 'Humedad';
        unit = '%';
        break;
      case 'presi칩n':
        paramName = 'Presi칩n Atmosf칠rica';
        unit = 'hPa';
        break;
      case 'lluvia':
        paramName = 'Precipitaci칩n';
        unit = 'Presencia';
        break;
      case 'viento':
        paramName = 'Viento';
        unit = 'm/s';
        break;
      case 'gas':
        paramName = 'Nivel de Gas';
        unit = 'k풜';
        break;
      case 'direcci칩n':
        paramName = 'Direcci칩n del Viento';
        unit = '춿';
        break;
      default:
        paramName = 'Medici칩n';
        unit = '';
    }
    
    // Crea el nuevo gr치fico
    const chart = new Chart(chartCtx, {
      type: 'line',
      data: {
        datasets: [
          {
            label: period1,
            data: chartData1,
            borderColor: color1,
            backgroundColor: `${color1}40`,
            borderWidth: 3,
            tension: 0.3,
            pointRadius: 3
          },
          {
            label: period2,
            data: chartData2,
            borderColor: color2,
            backgroundColor: `${color2}40`,
            borderWidth: 3,
            tension: 0.3,
            pointRadius: 3
          }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            position: 'top'
          },
          tooltip: {
            mode: 'index',
            intersect: false
          }
        },
        scales: {
          x: {
            type: 'time',
            time: {
              unit: 'day'
            },
            title: {
              display: true,
              text: 'Fecha'
            }
          },
          y: {
            beginAtZero: false,
            title: {
              display: true,
              text: unit
            }
          }
        }
      }
    });
    
    // Almacenar instancia del gr치fico para actualizarla al cambiar de tema
    charts.push(chart);
  };

  // Renderizar gr치ficos de extremos
  const renderExtremesChart = (parameter, chartData, maxDate, minDate, chartId) => {
    const chartCtx = document.getElementById(chartId)?.getContext('2d');
    if (!chartCtx) return;
    
    // Determina el nombre del par치metro y colores
    let paramName = '';
    let color = '#4a90e2';
    let unit = '';
    
    switch (parameter) {
      case 'temperatura':
        paramName = 'Temperatura';
        color = '#FF6384';
        unit = '춿C';
        break;
      case 'humedad':
        paramName = 'Humedad';
        color = '#36A2EB';
        unit = '%';
        break;
      case 'presi칩n':
        paramName = 'Presi칩n Atmosf칠rica';
        color = '#FFCE56';
        unit = 'hPa';
        break;
      case 'lluvia':
        paramName = 'Precipitaci칩n';
        color = '#46BFBD';
        unit = 'Presencia';
        break;
      case 'viento':
        paramName = 'Viento';
        color = '#C9CBCF';
        unit = 'm/s';
        break;
      case 'gas':
        paramName = 'Nivel de Gas';
        color = '#FDB45C';
        unit = 'k풜';
        break;
      case 'direcci칩n':
        paramName = 'Direcci칩n del Viento';
        color = '#9966FF';
        unit = '춿';
        break;
      default:
        paramName = 'Medici칩n';
        unit = '';
    }
    
    // Preparar datos con marcadores para m치ximos y m칤nimos
    const dataWithMarkers = chartData.map(item => ({
      x: item.x,
      y: item.y,
      pointBackgroundColor: item.x.toISOString() === maxDate || item.x.toISOString() === minDate ? 
                            (item.x.toISOString() === maxDate ? '#FF0000' : '#0000FF') : 
                            color
    }));
    
    // Crea el nuevo gr치fico
    const chart = new Chart(chartCtx, {
      type: 'line',
      data: {
        datasets: [{
          label: paramName,
          data: dataWithMarkers,
          borderColor: color,
          backgroundColor: `${color}40`,
          borderWidth: 3,
          tension: 0.3,
          pointRadius: function(context) {
            const index = context.dataIndex;
            const value = context.dataset.data[index];
            return value.pointBackgroundColor !== color ? 6 : 3;
          },
          pointBackgroundColor: function(context) {
            const index = context.dataIndex;
            const value = context.dataset.data[index];
            return value.pointBackgroundColor;
          }
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            display: false
          },
          tooltip: {
            mode: 'index',
            intersect: false
          }
        },
        scales: {
          x: {
            type: 'time',
            time: {
              unit: 'day'
            },
            title: {
              display: true,
              text: 'Fecha'
            }
          },
          y: {
            beginAtZero: false,
            title: {
              display: true,
              text: unit
            }
          }
        }
      }
    });
    
    // Almacenar instancia del gr치fico para actualizarla al cambiar de tema
    charts.push(chart);
  };

  // Procesar mensaje del usuario
  const processUserMessage = async (message) => {
    // Guardar en historial de conversaci칩n
    conversationContext.conversationHistory.push({
      role: 'user',
      content: message,
      timestamp: new Date().toISOString()
    });
    
    // Corregir ortograf칤a
    const { correctedMessage, hasCorrection } = spellingCorrection.correctMessage(message);
    
    // Mostrar mensaje de correcci칩n SOLO si hubo correcciones significativas
    if (hasCorrection) {
      addMessage(`游댌 Entiendo que quiz치s quisiste decir: "${correctedMessage}"`, false);
    }
    
    // Normalizar mensaje
    const normalizedMessage = correctedMessage.toLowerCase().replace(/[.,!?]/g, '');
    
    // An치lisis de 치mbito
    const domainAnalysis = semanticAnalysis.analyzeDomain(normalizedMessage);
    
    // An치lisis sem치ntico avanzado
    const entities = semanticAnalysis.identifyEntities(normalizedMessage);
    const intent = semanticAnalysis.analyzeIntent(normalizedMessage, entities, domainAnalysis);
    
    // Verificar si es una pregunta compuesta
    const isCompoundQuestion = (message.match(/y|adem치s|tambi칠n|tambien/g) || []).length > 0;
    
    try {
      // Procesar seg칰n la intenci칩n detectada
      if (intent && intent.confidence >= conversationContext.confidenceThreshold) {
        // Manejar intenci칩n reconocida
        if (intentHandlers[intent.type]) {
          return intentHandlers[intent.type](entities, conversationContext);
        }
      }
      
      // Si no se reconoci칩 la intenci칩n pero es una pregunta meteorol칩gica
      if (domainAnalysis.isWeatherQuestion) {
        // Intentar identificar par치metros incluso sin intenci칩n clara
        if (entities.parameters.length > 0) {
          // Si hay par치metros pero no intenci칩n clara, asumir consulta actual
          return intentHandlers.current_data({
            parameters: entities.parameters,
            periods: ['hoy']
          }, conversationContext);
        }
        
        // Si hay periodos pero no par치metros, pedir aclaraci칩n
        if (entities.periods.length > 0) {
          return "Para poder ayudarte, necesito saber qu칠 par치metro meteorol칩gico te interesa. Por ejemplo: 'temperatura', 'humedad' o 'presi칩n'.";
        }
      }
      
      // Si es un saludo aunque no se haya detectado claramente
      if (semanticAnalysis.isGreeting(normalizedMessage)) {
        return intentHandlers.greeting();
      }
      
      // Si es una despedida aunque no se haya detectado claramente
      if (semanticAnalysis.isGoodbye(normalizedMessage)) {
        return intentHandlers.goodbye();
      }
      
      // Si es una solicitud de ayuda aunque no se haya detectado claramente
      if (semanticAnalysis.isHelpRequest(normalizedMessage)) {
        return intentHandlers.help();
      }
      
      // Si no se identifica un 치mbito espec칤fico
      if (!domainAnalysis.isWeatherQuestion) {
        if (normalizedMessage.includes('pol칤tica') || normalizedMessage.includes('politica')) {
          return "Soy un asistente meteorol칩gico especializado. Para informaci칩n pol칤tica, te recomiendo consultar fuentes especializadas en pol칤tica y actualidad.";
        }
        if (normalizedMessage.includes('religi칩n') || normalizedMessage.includes('religion')) {
          return "Soy un asistente meteorol칩gico especializado. Para informaci칩n sobre religi칩n, te recomiendo consultar fuentes especializadas en este tema.";
        }
      }
      
      // Mensaje predeterminado si no se identifica una intenci칩n espec칤fica
      return "No estoy seguro de entender tu pregunta. Soy un asistente meteorol칩gico especializado. 쯇odr칤as reformular tu pregunta relacionada con el clima o las condiciones atmosf칠ricas? Por ejemplo, puedes preguntar sobre temperatura, humedad, presi칩n atmosf칠rica o viento.";
      
    } catch (error) {
      console.error('Error procesando mensaje:', error);
      return "丘멆잺 Ocurri칩 un error al procesar tu solicitud. Por favor, intenta nuevamente.";
    }
  };

  // Enviar mensaje
  const sendMessage = async () => {
    const message = userInput.value.trim();
    if (message === '' || !chatbotReady) return;
    
    // A침ade mensaje del usuario
    addMessage(message, true);
    userInput.value = '';
    
    // Muestra "escribiendo..."
    const loadingId = showLoading();
    
    try {
      // Procesa el mensaje
      const response = await processUserMessage(message);
      
      // Remueve el mensaje de "escribiendo..."
      document.getElementById(loadingId).remove();
      
      // Muestra la respuesta
      addMessage(response, false, 'local');
      
      // Renderizar gr치ficos si existen
      setTimeout(() => {
        document.querySelectorAll('.prediction-chart').forEach(canvas => {
          const parameter = canvas.dataset.parameter;
          const chartData = JSON.parse(canvas.dataset.chartData);
          renderChart(parameter, chartData, canvas.id);
        });
        
        document.querySelectorAll('.comparison-chart').forEach(canvas => {
          const parameter = canvas.dataset.parameter;
          const chartData1 = JSON.parse(canvas.dataset.chartData1);
          const chartData2 = JSON.parse(canvas.dataset.chartData2);
          const period1 = canvas.dataset.period1;
          const period2 = canvas.dataset.period2;
          renderComparisonChart(parameter, chartData1, chartData2, period1, period2, canvas.id);
        });
        
        document.querySelectorAll('.extremes-chart').forEach(canvas => {
          const parameter = canvas.dataset.parameter;
          const chartData = JSON.parse(canvas.dataset.chartData);
          const maxDate = canvas.dataset.maxDate;
          const minDate = canvas.dataset.minDate;
          renderExtremesChart(parameter, chartData, maxDate, minDate, canvas.id);
        });
      }, 100);
      
    } catch (error) {
      console.error('Error procesando mensaje:', error);
      document.getElementById(loadingId).remove();
      addMessage("丘멆잺 Ocurri칩 un error al procesar tu solicitud. Por favor, intenta nuevamente.", false);
    }
  };

  // Inicializar chatbot
  const initChatbot = async () => {
    try {
      updateStatus("Inicializando componentes...");
      
      // Carga datos hist칩ricos
      await loadHistoricalData();
      
      updateStatus("Chatbot listo para usar");
      chatbotReady = true;
      
      // Configurar sugerencias
      document.querySelectorAll('.suggestion').forEach(suggestion => {
        suggestion.addEventListener('click', () => {
          userInput.value = suggestion.textContent;
          sendMessage();
        });
      });
      
      // Hacer disponible para main.js
      window.updateChatbotCharts = () => {
        // Destruir y recrear los gr치ficos para actualizar colores
        charts.forEach(chart => {
          if (chart && chart.destroy) {
            chart.destroy();
          }
        });
        charts = [];
        
        // Volver a renderizar todos los gr치ficos
        setTimeout(() => {
          document.querySelectorAll('.prediction-chart').forEach(canvas => {
            const parameter = canvas.dataset.parameter;
            const chartData = JSON.parse(canvas.dataset.chartData);
            renderChart(parameter, chartData, canvas.id);
          });
          
          document.querySelectorAll('.comparison-chart').forEach(canvas => {
            const parameter = canvas.dataset.parameter;
            const chartData1 = JSON.parse(canvas.dataset.chartData1);
            const chartData2 = JSON.parse(canvas.dataset.chartData2);
            const period1 = canvas.dataset.period1;
            const period2 = canvas.dataset.period2;
            renderComparisonChart(parameter, chartData1, chartData2, period1, period2, canvas.id);
          });
          
          document.querySelectorAll('.extremes-chart').forEach(canvas => {
            const parameter = canvas.dataset.parameter;
            const chartData = JSON.parse(canvas.dataset.chartData);
            const maxDate = canvas.dataset.maxDate;
            const minDate = canvas.dataset.minDate;
            renderExtremesChart(parameter, chartData, maxDate, minDate, canvas.id);
          });
        }, 100);
      };
      
    } catch (error) {
      console.error('Error inicializando chatbot:', error);
      updateStatus("Error al inicializar el chatbot", true);
      chatbotReady = true;
      addMessage("丘멆잺 Hubo un problema al cargar los datos. Algunas funciones avanzadas podr칤an no estar disponibles.", false);
    }
  };

  // Event listeners
  sendButton.addEventListener('click', sendMessage);
  userInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') sendMessage();
  });
  
  // Inicializar el chatbot
  initChatbot();
</script>
</body>
</html>
