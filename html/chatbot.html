<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Chatbot Meteorológico - Horus</title>
  <link rel="stylesheet" href="../css/style.css" />
  <link rel="stylesheet" href="../css/chatbot.css" />
  <script src="../js/PapaParse.js"></script>
  <script src="../js/chart.js"></script>
</head>
<body class="light-mode chatbot-page">
<nav class="nav">
  <div class="nav-container">
    <div class="nav-buttons">
      <a href="../index.html" class="nav-btn"><span class="nav-icon">🏠</span> Inicio</a>
      <a href="mqtt.html" class="nav-btn">
        <span class="nav-icon">📡</span> Datos en Vivo
      </a>
      <a href="analisis.html" class="nav-btn">
        <span class="nav-icon">📊</span> Análisis
      </a>
      <a href="chatbot.html" class="nav-btn active">
        <span class="nav-icon">🤖</span> Chatbot
      </a>
    </div>
    <!-- Switch de Galahad -->
    <div class="nav-right">
      <label class="theme-switch">
        <input type="checkbox" class="theme-switch__checkbox">
        <div class="theme-switch__container">
          <div class="theme-switch__clouds"></div>
          <div class="theme-switch__stars-container">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 144 55" fill="none">
            </svg>
          </div>
          <div class="theme-switch__sun-moon-container">
            <div class="theme-switch__moon">
              <div class="theme-switch__spot"></div>
              <div class="theme-switch__spot"></div>
              <div class="theme-switch__spot"></div>
            </div>
          </div>
        </div>
      </label>
    </div>
  </div>
</nav>

<div class="container">
  <header>
    <h1>🤖 Horus AI - Análisis Avanzado</h1>
    <p>Un asistente inteligente con análisis semántico avanzado y procesamiento profundo de preguntas</p>
  </header>
  
  <main id="chat-container" class="chat-main-container">
    <div id="chat-messages" class="chat-messages">
      <div class="message bot welcome-message">
        <div class="bot-avatar">
          <span>🤖</span>
        </div>
        <div class="message-content">
          ¡Hola! Soy Horus AI, tu asistente meteorológico especializado.<br><br>
          <strong>Puedo ayudarte con:</strong>
          <ul>
            <li>Consultar la temperatura, humedad, presión y otros datos actuales</li>
            <li>Analizar tendencias históricas de los últimos días, semanas o meses</li>
            <li>Comparar condiciones meteorológicas entre diferentes periodos</li>
            <li>Predecir condiciones climáticas basado en datos históricos</li>
          </ul>
          <br>
          <strong>Ejemplos de preguntas:</strong>
          <div class="suggestion">¿Cuál es la temperatura actual?</div>
          <div class="suggestion">¿Cómo ha sido la humedad esta semana?</div>
          <div class="suggestion">Muestra la tendencia de presión de los últimos 7 días</div>
        </div>
        <div class="message-time">Ahora</div>
      </div>
    </div>
    
    <div class="chat-input-container">
      <input type="text" id="user-input" placeholder="Escribe tu pregunta sobre el clima...">
      <button id="send-button">Enviar</button>
    </div>
    
    <div class="status-bar">
      <div id="status-indicator" class="status-indicator"></div>
      <span id="status-text">Horus AI esperando tu pregunta...</span>
    </div>
  </main>
</div>

<style>
  /* Estilos para el contenedor del chat */
  .chat-main-container {
    max-width: 900px;
    margin: 0 auto;
    background: var(--card-bg);
    border-radius: var(--border-radius);
    overflow: hidden;
    box-shadow: var(--shadow);
  }

  /* Mensajes del chat */
  .chat-messages {
    height: 60vh;
    overflow-y: auto;
    padding: 15px;
    background: var(--dark-bg);
  }

  .message {
    display: flex;
    margin-bottom: 15px;
    animation: fadeIn 0.3s ease;
  }

  .message.user {
    justify-content: flex-end;
  }

  .message.bot {
    justify-content: flex-start;
  }

  .bot-avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: var(--primary);
    display: flex;
    align-items: center;
    justify-content: center;
    margin-right: 10px;
    flex-shrink: 0;
  }

  .bot-avatar span {
    font-size: 20px;
  }

  .message-content {
    background: var(--card-bg);
    color: var(--text);
    padding: 12px 15px;
    border-radius: 18px;
    max-width: 75%;
    line-height: 1.5;
  }

  .message.user .message-content {
    background: var(--primary);
    color: #000;
    border-bottom-right-radius: 5px;
  }

  .message-time {
    font-size: 11px;
    color: var(--text-secondary);
    margin-top: 5px;
    text-align: right;
    opacity: 0.7;
  }

  /* Barra de entrada */
  .chat-input-container {
    display: flex;
    padding: 10px 15px;
    background: var(--card-bg);
    border-top: 1px solid rgba(255, 255, 255, 0.05);
  }

  .chat-input-container input {
    flex: 1;
    padding: 12px 15px;
    border: none;
    background: var(--dark-bg);
    color: var(--text);
    border-radius: 20px 0 0 20px;
    font-size: 16px;
    outline: none;
    transition: var(--transition);
  }

  .chat-input-container input:focus {
    box-shadow: 0 0 0 2px var(--primary-glow);
  }

  .chat-input-container button {
    background: var(--primary);
    color: #000;
    border: none;
    padding: 12px 20px;
    border-radius: 0 20px 20px 0;
    cursor: pointer;
    font-weight: bold;
    transition: var(--transition);
  }

  .chat-input-container button:hover {
    background: #00d0e0;
    transform: translateY(-2px);
  }

  /* Barra de estado */
  .status-bar {
    padding: 8px 15px;
    background: rgba(0, 0, 0, 0.1);
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .status-indicator {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: #4CAF50;
    box-shadow: 0 0 6px rgba(76, 175, 80, 0.7);
  }

  .status-indicator.error {
    background: #f44336;
    box-shadow: 0 0 6px rgba(244, 67, 54, 0.7);
  }

  /* Sugerencias de preguntas */
  .suggestion {
    background: rgba(255, 255, 255, 0.1);
    padding: 8px 12px;
    border-radius: 12px;
    margin: 5px 0;
    cursor: pointer;
    transition: var(--transition);
  }

  .suggestion:hover {
    background: rgba(0, 234, 255, 0.2);
    transform: translateX(5px);
  }

  /* Efecto de escritura */
  .typing-indicator {
    display: inline-flex;
    gap: 4px;
    margin-right: 8px;
  }

  .typing-indicator span {
    width: 6px;
    height: 6px;
    background: var(--primary);
    border-radius: 50%;
    animation: typing 1s infinite;
  }

  .typing-indicator span:nth-child(2) {
    animation-delay: 0.2s;
  }

  .typing-indicator span:nth-child(3) {
    animation-delay: 0.4s;
  }

  @keyframes typing {
    0%, 100% { transform: translateY(0); opacity: 0.5; }
    50% { transform: translateY(-5px); opacity: 1; }
  }

  /* Análisis de datos */
  .analysis-header {
    margin-bottom: 15px;
  }

  .analysis-header h2 {
    font-size: 1.2rem;
    margin-bottom: 8px;
    color: var(--primary);
  }

  .analysis-header p {
    color: var(--text-secondary);
    font-size: 0.9rem;
  }

  .statistics-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
    margin-bottom: 20px;
  }

  .stat-item {
    background: rgba(0, 234, 255, 0.1);
    padding: 10px;
    border-radius: 8px;
    text-align: center;
  }

  .stat-value {
    font-size: 1.3rem;
    font-weight: bold;
    color: var(--primary);
    display: block;
    margin-top: 5px;
  }

  .trend-analysis {
    background: rgba(0, 0, 0, 0.2);
    padding: 15px;
    border-radius: 10px;
    margin-top: 15px;
  }

  .trend-analysis h3 {
    margin-top: 0;
    color: var(--primary);
  }

  .trend-description {
    color: var(--text-secondary);
  }

  .prediction-container {
    margin-top: 15px;
  }

  .prediction-reliability {
    margin-bottom: 10px;
    font-size: 0.9rem;
  }

  .reliability-bar {
    height: 6px;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 3px;
    margin-top: 4px;
  }

  .reliability-fill {
    height: 100%;
    background: var(--primary);
    border-radius: 3px;
    transition: width 0.5s ease;
  }

  .prediction-chart-container {
    height: 250px;
    margin-top: 10px;
  }

  .chart-title {
    font-weight: bold;
    margin-bottom: 8px;
    color: var(--primary);
    font-size: 1rem;
  }

  .source-badge {
    display: inline-block;
    margin-left: 5px;
    font-size: 0.8rem;
    opacity: 0.7;
  }

  .welcome-message {
    background: rgba(0, 234, 255, 0.05);
    border-radius: 15px;
    padding: 15px;
    border: 1px solid rgba(0, 234, 255, 0.2);
  }
  
  /* Análisis detallado */
  .detailed-analysis {
    margin-top: 15px;
    background: rgba(0, 0, 0, 0.1);
    padding: 15px;
    border-radius: 10px;
  }
  
  .detailed-analysis h3 {
    color: var(--primary);
    margin-top: 0;
  }
  
  .detailed-analysis p {
    line-height: 1.6;
    margin-bottom: 10px;
  }
  
  .confidence-indicator {
    display: inline-block;
    background: rgba(76, 175, 80, 0.2);
    color: #4CAF50;
    padding: 2px 8px;
    border-radius: 10px;
    font-size: 0.8rem;
    margin-top: 5px;
  }
</style>

<script>
  // Variables globales
  let historicalData = [];
  let chatbotReady = false;
  let charts = []; // Para almacenar instancias de gráficos
  
  // Contexto de conversación mejorado
  let conversationContext = {
    lastParameter: null,
    lastPeriod: null,
    lastQuestionType: null,
    conversationHistory: [],
    entityContext: {},
    temporalContext: null,
    spatialContext: null,
    confidenceThreshold: 0.65 // Umbral de confianza para aceptar una intención
  };

  // Elementos del DOM
  const chatMessages = document.getElementById('chat-messages');
  const userInput = document.getElementById('user-input');
  const sendButton = document.getElementById('send-button');
  const statusIndicator = document.getElementById('status-indicator');
  const statusText = document.getElementById('status-text');

  // Actualizar estado
  const updateStatus = (message, isError = false) => {
    statusText.textContent = message;
    if (isError) {
      statusIndicator.classList.add('error');
    } else {
      statusIndicator.classList.remove('error');
    }
  };

  // Añadir mensaje al chat
  const addMessage = (content, isUser = false, source = 'local') => {
    const messageDiv = document.createElement('div');
    messageDiv.classList.add('message');
    messageDiv.classList.add(isUser ? 'user' : 'bot');
    
    // Marca de fuente para mensajes del bot
    const sourceBadge = source !== 'local' 
      ? `<span class="source-badge" title="Información obtenida de: ${source}">${source === 'web' ? '🌐' : source}</span>` 
      : '';
      
    if (isUser) {
      messageDiv.innerHTML = `
        <div class="message-content">${content}</div>
        <div class="message-time">${new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</div>
      `;
    } else {
      messageDiv.innerHTML = `
        <div class="bot-avatar"><span>🤖</span></div>
        <div class="message-content">${content}${sourceBadge}</div>
        <div class="message-time">Ahora</div>
      `;
    }
    
    chatMessages.appendChild(messageDiv);
    chatMessages.scrollTop = chatMessages.scrollHeight;
    
    // Actualizar el tiempo "Ahora" a minutos reales después de 5 segundos
    setTimeout(() => {
      const timeElement = messageDiv.querySelector('.message-time');
      if (timeElement && timeElement.textContent === 'Ahora') {
        timeElement.textContent = new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
      }
    }, 5000);
    
    // Guardar en historial de conversación
    if (!isUser) {
      conversationContext.conversationHistory.push({
        role: 'assistant',
        content,
        timestamp: new Date().toISOString()
      });
    }
  };

  // Mostrar estado de carga
  const showLoading = (message = "Analizando tu pregunta") => {
    const loadingId = `loading-${Date.now()}`;
    const loadingDiv = document.createElement('div');
    loadingDiv.id = loadingId;
    loadingDiv.className = 'message bot';
    loadingDiv.innerHTML = `
      <div class="bot-avatar"><span>🤖</span></div>
      <div class="message-content">
        <div class="typing-indicator"><span></span><span></span><span></span></div>
        <div class="loading-text">${message}</div>
      </div>
      <div class="message-time">Escribiendo...</div>
    `;
    chatMessages.appendChild(loadingDiv);
    chatMessages.scrollTop = chatMessages.scrollHeight;
    return loadingId;
  };

  // Diccionario de sinónimos meteorológicos mejorado
  const weatherSynonyms = {
    temperatura: ['temp', 'calor', 'frío', 'frio', 'grados', '°', 'celsius', 'centígrados', 'centigrados', 'termómetro', 'termometro'],
    humedad: ['hum', 'vapor', 'agua', 'porcentaje de agua', '% agua', 'humedad relativa'],
    presión: ['pres', 'atmosférica', 'barométrica', 'barometrica', 'hpa', 'mb', 'presión atmosférica'],
    lluvia: ['precipitación', 'precipitacion', 'agua', 'llovizna', 'tormenta', 'lluvioso', 'precipitaciones', 'pluviometría', 'pluviometria'],
    viento: ['velocidad del viento', 'ráfagas', 'ráfaga', 'ráfagas de viento', 'velocidad viento', 'km/h', 'nudos', 'dirección del viento', 'direccion viento', 'brisa'],
    gas: ['calidad del aire', 'calidad aire', 'contaminación', 'contaminacion', 'pm2.5', 'pm10', 'partículas', 'particulas', 'co2', 'dióxido de carbono'],
    dirección: ['direccion', 'rumbo', 'orientación', 'orientacion', 'grados', 'norte', 'sur', 'este', 'oeste', 'cardinal'],
    análisis: ['analisis', 'tendencia', 'tendencias', 'evolución', 'comportamiento', 'patrón', 'patron', 'estadística', 'estadisticas'],
    predicción: ['prediccion', 'pronóstico', 'pronostico', 'previsión', 'prevision', 'futuro', 'mañana', 'siguiente', 'proyección', 'proyeccion'],
    actual: ['ahora', 'en este momento', 'en este instante', 'actualidad', 'presente', 'en directo', 'en tiempo real', 'hoy'],
    histórico: ['historico', 'pasado', 'antes', 'anterior', 'anteriores', 'días anteriores', 'semanas anteriores', 'últimos días'],
    comparar: ['comparación', 'comparar', 'compara', 'diferencia', 'vs', 'versus', 'comparativo', 'entre', 'y'],
    máximo: ['maximo', 'máximo', 'pico', 'peak', 'más alto', 'mayor', 'máx', 'max'],
    mínimo: ['minimo', 'mínimo', 'más bajo', 'menor', 'mín', 'min'],
    tendencia: ['tendencia', 'tendencias', 'evolución', 'comportamiento', 'patrón', 'patron', 'cambios', 'variación', 'variacion'],
    probabilidad: ['probabilidad', 'probable', 'posibilidad', 'posible', 'chance', 'oportunidad', 'riesgo']
  };

  // Mapeo de intenciones mejorado
  const intentMap = {
    current_data: {
      keywords: ['actual', 'ahora', 'en este momento', 'en directo', 'presente', 'en tiempo real', 'hoy'],
      parameters: ['temperatura', 'humedad', 'presión', 'lluvia', 'viento', 'gas', 'dirección'],
      required: []
    },
    historical_trend: {
      keywords: ['tendencia', 'evolución', 'comportamiento', 'análisis', 'analisis', 'patrón', 'patron', 'gráfico', 'grafico', 'historial', 'historico', 'histórico', 'evolucion', 'variacion'],
      parameters: ['temperatura', 'humedad', 'presión', 'lluvia', 'viento', 'gas'],
      required: ['period']
    },
    prediction: {
      keywords: ['predicción', 'prediccion', 'pronóstico', 'pronostico', 'previsión', 'prevision', 'futuro', 'mañana', 'siguiente', 'proyección', 'proyeccion', 'probabilidad', 'probable'],
      parameters: ['temperatura', 'humedad', 'presión', 'lluvia', 'viento'],
      required: []
    },
    comparison: {
      keywords: ['comparar', 'comparación', 'compara', 'diferencia', 'vs', 'versus', 'comparativo', 'entre', 'y', 'diferencia', 'distinto', 'igual'],
      parameters: ['temperatura', 'humedad', 'presión', 'lluvia', 'viento', 'gas'],
      required: ['periods']
    },
    max_min: {
      keywords: ['máximo', 'maximo', 'mínimo', 'minimo', 'pico', 'peak', 'mayor', 'menor', 'más alto', 'más bajo', 'máx', 'max', 'mín', 'min'],
      parameters: ['temperatura', 'humedad', 'presión', 'lluvia', 'viento', 'gas'],
      required: ['period']
    },
    correlation: {
      keywords: ['relación', 'correlación', 'correlacion', 'conexión', 'conexion', 'asociación', 'asociacion', 'afecta', 'influye', 'impacto', 'causa', 'provoca'],
      parameters: ['temperatura', 'humedad', 'presión', 'lluvia', 'viento', 'gas'],
      required: ['parameters']
    },
    greeting: {
      keywords: ['hola', 'buenos días', 'buenos dias', 'buenas tardes', 'hey', 'saludos', 'buen día', 'buen dia', 'buenas noches', 'que tal', 'como estas', 'cómo estás'],
      parameters: [],
      required: []
    },
    goodbye: {
      keywords: ['adiós', 'adios', 'gracias', 'chao', 'hasta luego', 'hasta pronto', 'nos vemos', 'bye', 'gracías', 'gracias', 'fue útil', 'fue util'],
      parameters: [],
      required: []
    },
    help: {
      keywords: ['ayuda', 'funciona', 'cómo', 'como', 'puedo', 'capaz', 'hacer', 'qué', 'que', 'preguntar', 'instrucciones', 'ejemplo', 'ejemplos', 'guía', 'manual', 'tutorial'],
      parameters: [],
      required: []
    },
    unrelated: {
      keywords: [],
      parameters: [],
      required: []
    }
  };

  // Mapeo de periodos
  const periodMap = {
    'hoy': { type: 'day', value: 1, unit: 'day' },
    'ayer': { type: 'day', value: 1, unit: 'day', offset: 1 },
    'últimas 24 horas': { type: 'hour', value: 24, unit: 'hour' },
    'últimas 12 horas': { type: 'hour', value: 12, unit: 'hour' },
    'esta mañana': { type: 'morning', value: 1, unit: 'day' },
    'esta tarde': { type: 'afternoon', value: 1, unit: 'day' },
    'esta noche': { type: 'night', value: 1, unit: 'day' },
    'esta semana': { type: 'week', value: 1, unit: 'week' },
    'esta semana pasada': { type: 'week', value: 1, unit: 'week', offset: 1 },
    'últimos 7 días': { type: 'day', value: 7, unit: 'day' },
    'últimos 14 días': { type: 'day', value: 14, unit: 'day' },
    'últimos 30 días': { type: 'day', value: 30, unit: 'day' },
    'este mes': { type: 'month', value: 1, unit: 'month' },
    'este año': { type: 'year', value: 1, unit: 'year' },
    'último mes': { type: 'month', value: 1, unit: 'month', offset: 1 },
    'último año': { type: 'year', value: 1, unit: 'year', offset: 1 },
    'última hora': { type: 'hour', value: 1, unit: 'hour' },
    'últimas 2 horas': { type: 'hour', value: 2, unit: 'hour' },
    'últimas 6 horas': { type: 'hour', value: 6, unit: 'hour' },
    'esta semana': { type: 'week', value: 1, unit: 'week' },
    'esta semana anterior': { type: 'week', value: 1, unit: 'week', offset: 1 },
    'este mes': { type: 'month', value: 1, unit: 'month' },
    'este mes pasado': { type: 'month', value: 1, unit: 'month', offset: 1 },
    'este año': { type: 'year', value: 1, unit: 'year' },
    'este año pasado': { type: 'year', value: 1, unit: 'year', offset: 1 }
  };

  // Diccionario para corrección ortográfica
  const spellingDictionary = {
    'tempertura': 'temperatura',
    'temperaruta': 'temperatura',
    'humedad': 'humedad',
    'humead': 'humedad',
    'umedad': 'humedad',
    'presion': 'presión',
    'presion': 'presión',
    'presion atmosferica': 'presión atmosférica',
    'presion atmosferica': 'presión atmosférica',
    'presion barometrica': 'presión barométrica',
    'presion barometrica': 'presión barométrica',
    'lluvia': 'lluvia',
    'llubia': 'lluvia',
    'lubia': 'lluvia',
    'viento': 'viento',
    'biento': 'viento',
    'bientto': 'viento',
    'gas': 'gas',
    'calidad del aire': 'calidad del aire',
    'calidad aire': 'calidad del aire',
    'direccion': 'dirección',
    'direccion del viento': 'dirección del viento',
    'direccion viento': 'dirección del viento',
    'termometro': 'termómetro',
    'termometro': 'termómetro',
    'pluviometria': 'pluviometría',
    'pluviometria': 'pluviometría',
    'co2': 'CO2',
    'dióxido de carbono': 'dióxido de carbono'
  };

  // Sistema de análisis semántico mejorado
  const semanticAnalysis = {
    // Analiza el dominio de la pregunta
    analyzeDomain: (text) => {
      const weatherKeywords = [
        'temperatura', 'calor', 'frío', 'frio', 'grados', 
        'humedad', 'agua', 'presión', 'atmosférica', 'barométrica',
        'lluvia', 'precipitación', 'viento', 'ráfagas', 'gas',
        'calidad del aire', 'dirección', 'clima', 'meteorológico',
        'meteorologico', 'tiempo', 'nublado', 'soleado', 'nubes',
        'nuboso', 'llovizna', 'tormenta', 'nublados', 'soleados',
        'nubosos', 'tormentas', 'lluvias', 'vientos', 'ráfagas',
        'caluroso', 'frio', 'frío', 'caliente', 'templado',
        'húmedo', 'seco', 'húmedos', 'secos', 'presión',
        'barómetro', 'pluviómetro', 'anemómetro', 'termómetro',
        'meteorología', 'climático', 'climáticos', 'climáticas',
        'climatología', 'pronóstico', 'pronostico', 'predicción',
        'prediccion', 'previsión', 'prevision', 'estacional',
        'estaciones', 'primavera', 'verano', 'otoño', 'invierno',
        'norte', 'sur', 'este', 'oeste', 'cardinales', 'brisa',
        'ciclón', 'huracán', 'tornado', 'tornados', 'ciclones',
        'huracanes', 'tormenta', 'tormentas', 'lluvia', 'lluvias',
        'nublado', 'nublados', 'nuboso', 'nubosos', 'soleado',
        'soleados', 'despejado', 'despejados', 'nublación',
        'nublaciones', 'precipitación', 'precipitaciones', 'humedad',
        'relativa', 'relativas', 'humedad relativa', 'presión',
        'atmosférica', 'atmosféricas', 'presión atmosférica',
        'barométrica', 'barométricas', 'presión barométrica',
        'viento', 'vientos', 'ráfaga', 'ráfagas', 'dirección',
        'direcciones', 'dirección del viento', 'velocidad',
        'velocidades', 'velocidad del viento', 'anemómetro',
        'termómetro', 'pluviómetro', 'barómetro', 'higrómetro',
        'gas', 'gases', 'calidad del aire', 'contaminación',
        'contaminacion', 'pm2.5', 'pm10', 'partículas', 'particulas',
        'co2', 'dióxido de carbono', 'ozono', 'no2', 'so2'
      ];
      
      let matchCount = 0;
      let totalKeywords = 0;
      const normalizedText = text.toLowerCase();
      
      weatherKeywords.forEach(keyword => {
        if (normalizedText.includes(keyword)) {
          matchCount++;
        }
        totalKeywords++;
      });
      
      // Calcular confianza basada en la proporción de coincidencias
      const confidence = Math.min(1.0, matchCount / Math.max(1, totalKeywords * 0.15));
      
      // Si encontramos al menos 1 palabra clave meteorológica, es una pregunta sobre clima
      return {
        isWeatherQuestion: matchCount > 0,
        confidence: confidence,
        matchCount: matchCount,
        totalKeywords: totalKeywords
      };
    },
    
    // Identifica entidades en el texto
    identifyEntities: (text) => {
      const entities = {
        parameters: [],
        periods: [],
        locations: [],
        numbers: [],
        comparisons: [],
        operations: []
      };
      
      const normalizedText = text.toLowerCase();
      
      // Identificar parámetros meteorológicos
      Object.keys(weatherSynonyms).forEach(param => {
        // Verificar el parámetro principal
        if (normalizedText.includes(param)) {
          entities.parameters.push(param);
        }
        
        // Verificar sinónimos
        weatherSynonyms[param].forEach(synonym => {
          if (normalizedText.includes(synonym)) {
            entities.parameters.push(param);
          }
        });
      });
      
      // Identificar periodos
      Object.keys(periodMap).forEach(period => {
        if (normalizedText.includes(period)) {
          entities.periods.push(period);
        }
      });
      
      // Identificar números
      const numberMatches = text.match(/\d+/g);
      if (numberMatches) {
        entities.numbers = numberMatches.map(num => parseInt(num));
      }
      
      // Identificar comparaciones
      if (normalizedText.includes('vs') || normalizedText.includes('versus')) {
        entities.comparisons.push('vs');
      }
      if (normalizedText.includes('tendencia') || normalizedText.includes('evolución')) {
        entities.comparisons.push('trend');
      }
      if (normalizedText.includes('correlación') || normalizedText.includes('relación')) {
        entities.comparisons.push('correlation');
      }
      
      // Identificar operaciones
      if (normalizedText.includes('máximo') || normalizedText.includes('maximo')) {
        entities.operations.push('max');
      }
      if (normalizedText.includes('mínimo') || normalizedText.includes('minimo')) {
        entities.operations.push('min');
      }
      if (normalizedText.includes('promedio') || normalizedText.includes('media')) {
        entities.operations.push('average');
      }
      if (normalizedText.includes('diferencia')) {
        entities.operations.push('difference');
      }
      
      // Eliminar duplicados
      entities.parameters = [...new Set(entities.parameters)];
      entities.periods = [...new Set(entities.periods)];
      entities.comparisons = [...new Set(entities.comparisons)];
      entities.operations = [...new Set(entities.operations)];
      
      return entities;
    },
    
    // Analiza la intención del usuario
    analyzeIntent: (text, entities, domainAnalysis) => {
      let bestIntent = null;
      let highestConfidence = 0;
      
      // Si es una pregunta meteorológica, analizar intenciones meteorológicas
      if (domainAnalysis.isWeatherQuestion) {
        // Analizar cada posible intención
        Object.keys(intentMap).forEach(intentType => {
          if (intentType === 'unrelated') return; // Saltar la intención unrelated en este paso
          
          const intent = intentMap[intentType];
          let confidence = 0;
          
          // Calcular coincidencia con palabras clave
          intent.keywords.forEach(keyword => {
            if (text.toLowerCase().includes(keyword)) {
              confidence += 0.2;
            }
          });
          
          // Aumentar confianza si se encontraron parámetros relevantes
          if (entities.parameters.length > 0 && intent.parameters.length > 0) {
            const commonParams = entities.parameters.filter(p => intent.parameters.includes(p));
            confidence += commonParams.length * 0.15;
          }
          
          // Aumentar confianza si se encontraron periodos y la intención los requiere
          if (intent.required.includes('period') && entities.periods.length > 0) {
            confidence += 0.2;
          }
          
          // Aumentar confianza si se encontraron múltiples periodos y la intención los requiere
          if (intent.required.includes('periods') && entities.periods.length > 1) {
            confidence += 0.25;
          }
          
          // Aumentar confianza si se encontraron operaciones específicas
          if (intentType === 'max_min' && entities.operations.includes('max')) {
            confidence += 0.15;
          }
          if (intentType === 'max_min' && entities.operations.includes('min')) {
            confidence += 0.15;
          }
          
          // Ajustar confianza según el dominio
          confidence *= domainAnalysis.confidence;
          
          // Verificar si es la mejor intención hasta ahora
          if (confidence > highestConfidence) {
            highestConfidence = confidence;
            bestIntent = {
              type: intentType,
              confidence: confidence,
              parameters: entities.parameters,
              periods: entities.periods
            };
          }
        });
      }
      
      // Si no se encontró una intención clara, verificar saludos, despedidas o ayuda
      if (!bestIntent || highestConfidence < 0.4) {
        if (this.isGreeting(text)) {
          return { type: 'greeting', confidence: 0.9, parameters: [], periods: [] };
        }
        if (this.isGoodbye(text)) {
          return { type: 'goodbye', confidence: 0.9, parameters: [], periods: [] };
        }
        if (this.isHelpRequest(text)) {
          return { type: 'help', confidence: 0.8, parameters: [], periods: [] };
        }
      }
      
      // Si no se encontró una intención clara pero hay parámetros, asumir que es una consulta actual
      if (!bestIntent && entities.parameters.length > 0) {
        return {
          type: 'current_data',
          confidence: 0.7,
          parameters: entities.parameters,
          periods: ['hoy']
        };
      }
      
      // Si no se encontró una intención clara pero hay periodos, asumir análisis histórico
      if (!bestIntent && entities.periods.length > 0) {
        return {
          type: 'historical_trend',
          confidence: 0.65,
          parameters: entities.parameters.length > 0 ? entities.parameters : ['temperatura'],
          periods: entities.periods
        };
      }
      
      // Si no se encontró una intención clara pero hay comparaciones, asumir comparación
      if (!bestIntent && entities.comparisons.length > 0) {
        return {
          type: 'comparison',
          confidence: 0.6,
          parameters: entities.parameters.length > 0 ? entities.parameters : ['temperatura'],
          periods: entities.periods.length >= 2 ? entities.periods.slice(0, 2) : 
                  (entities.periods.length === 1 ? [entities.periods[0], 'hoy'] : ['esta semana', 'hoy'])
        };
      }
      
      // Si hay parámetros pero no intención clara, intentar determinar la intención
      if (entities.parameters.length > 0 && !bestIntent) {
        // Si hay palabras como "máximo" o "mínimo", asumir max_min
        if (text.toLowerCase().includes('máximo') || text.toLowerCase().includes('maximo') ||
            text.toLowerCase().includes('mínimo') || text.toLowerCase().includes('minimo')) {
          return {
            type: 'max_min',
            confidence: 0.55,
            parameters: entities.parameters,
            periods: entities.periods.length > 0 ? entities.periods : ['últimos 7 días']
          };
        }
        
        // Si hay palabras como "tendencia" o "evolución", asumir historical_trend
        if (text.toLowerCase().includes('tendencia') || text.toLowerCase().includes('evolución') ||
            text.toLowerCase().includes('analizar') || text.toLowerCase().includes('analisis')) {
          return {
            type: 'historical_trend',
            confidence: 0.5,
            parameters: entities.parameters,
            periods: entities.periods.length > 0 ? entities.periods : ['últimos 7 días']
          };
        }
        
        // Si hay palabras como "mañana" o "futuro", asumir prediction
        if (text.toLowerCase().includes('mañana') || text.toLowerCase().includes('futuro') ||
            text.toLowerCase().includes('próximo') || text.toLowerCase().includes('siguiente')) {
          return {
            type: 'prediction',
            confidence: 0.5,
            parameters: entities.parameters,
            periods: []
          };
        }
        
        // Por defecto, asumir consulta actual
        return {
          type: 'current_data',
          confidence: 0.45,
          parameters: entities.parameters,
          periods: ['hoy']
        };
      }
      
      return bestIntent || { type: 'unrelated', confidence: 0, parameters: [], periods: [] };
    },
    
    // Verifica si es un saludo
    isGreeting: (text) => {
      const greetings = intentMap.greeting.keywords;
      const normalizedText = text.toLowerCase();
      
      return greetings.some(greeting => normalizedText.includes(greeting));
    },
    
    // Verifica si es una despedida
    isGoodbye: (text) => {
      const goodbyes = intentMap.goodbye.keywords;
      const normalizedText = text.toLowerCase();
      
      return goodbyes.some(goodbye => normalizedText.includes(goodbye));
    },
    
    // Verifica si es una solicitud de ayuda
    isHelpRequest: (text) => {
      const helpKeywords = intentMap.help.keywords;
      const normalizedText = text.toLowerCase();
      
      return helpKeywords.some(keyword => normalizedText.includes(keyword));
    },
    
    // Analiza preguntas compuestas
    analyzeCompoundQuestions: (text) => {
      const compoundIndicators = ['y', 'además', 'también', 'tambien', 'ademas', 'además de', 'ademas de', 'además que', 'ademas que'];
      return compoundIndicators.some(indicator => text.toLowerCase().includes(indicator));
    },
    
    // Analiza referencias en el contexto
    analyzeReferences: (text, context) => {
      const references = {
        parameters: [],
        temporal: [],
        spatial: []
      };
      
      // Analizar anáforas (referencias a elementos previos)
      if (context.lastParameter && (text.includes('eso') || text.includes('eso es') || text.includes('eso está'))) {
        references.parameters.push(context.lastParameter);
      }
      
      if (context.lastPeriod && (text.includes('entonces') || text.includes('en ese periodo') || text.includes('durante ese tiempo'))) {
        references.temporal.push(context.lastPeriod);
      }
      
      return references;
    },
    
    // Resuelve anáforas usando el contexto
    resolveAnaphora: (text, context) => {
      let resolvedText = text;
      const paramName = context.lastParameter || 'temperatura';
      
      // Reemplazar "eso" si hay contexto de parámetro
      if (context.lastParameter) {
        resolvedText = resolvedText.replace(/eso/g, paramName);
        resolvedText = resolvedText.replace(/eso es/g, `${paramName} es`);
        resolvedText = resolvedText.replace(/eso está/g, `${paramName} está`);
      }
      
      // Reemplazar "hoy" si hay contexto temporal
      if (context.temporalContext && (text.includes('ayer') || text.includes('mañana'))) {
        // Si el contexto es "hoy", y pregunta sobre "ayer", ajustamos
        if (context.temporalContext === 'today' && text.includes('ayer')) {
          resolvedText = resolvedText.replace(/ayer/g, 'hace un día');
        }
      }
      
      // Mejora: Reemplazar "la" + sustantivo por el parámetro específico
      if (context.lastParameter) {
        const paramReplacements = {
          'temp': ['la temperatura', 'el termómetro', 'los grados', 'el calor', 'el frío'],
          'humedad': ['la humedad', 'el vapor', 'el agua'],
          'presión': ['la presión', 'la atmosférica', 'la barométrica'],
          'lluvia': ['la lluvia', 'la precipitación', 'el agua'],
          'viento': ['el viento', 'las ráfagas', 'la brisa'],
          'gas': ['el gas', 'la calidad del aire', 'las partículas']
        };
        
        if (paramReplacements[paramName]) {
          paramReplacements[paramName].forEach(replacement => {
            resolvedText = resolvedText.replace(new RegExp(replacement, 'gi'), paramName);
          });
        }
      }
      
      return resolvedText;
    },
    
    // Analiza preguntas hipotéticas
    analyzeHypotheticals: (text) => {
      const hypotheticalIndicators = ['si', 'supongamos que', 'imagina que', 'qué pasaría si', 'que pasaria si', 'que pasaría si'];
      return hypotheticalIndicators.some(indicator => text.toLowerCase().includes(indicator));
    }
  };

  // Sistema de corrección ortográfica CORREGIDO
  const spellingCorrection = {
    // Calcula la distancia de Levenshtein entre dos strings
    levenshteinDistance: function(a, b) {
      if (a.length === 0) return b.length;
      if (b.length === 0) return a.length;
      
      const matrix = [];
      
      for (let i = 0; i <= b.length; i++) {
        matrix[i] = [i];
      }
      
      for (let j = 0; j <= a.length; j++) {
        matrix[0][j] = j;
      }
      
      for (let i = 1; i <= b.length; i++) {
        for (let j = 1; j <= a.length; j++) {
          if (b.charAt(i - 1) === a.charAt(j - 1)) {
            matrix[i][j] = matrix[i - 1][j - 1];
          } else {
            matrix[i][j] = Math.min(
              matrix[i - 1][j - 1] + 1, // Sustitución
              matrix[i][j - 1] + 1, // Inserción
              matrix[i - 1][j] + 1 // Eliminación
            );
          }
        }
      }
      
      return matrix[b.length][a.length];
    },
    
    // Corrige la ortografía de una palabra
    correctWord: function(word) {
      // Si la palabra está en el diccionario, devolver la corrección
      if (spellingDictionary[word.toLowerCase()]) {
        return spellingDictionary[word.toLowerCase()];
      }
      
      // Buscar en el diccionario de sinónimos
      for (const [correct, synonyms] of Object.entries(weatherSynonyms)) {
        for (const synonym of synonyms) {
          if (word.toLowerCase() === synonym) {
            return correct;
          }
          
          // Calcular distancia de Levenshtein para corrección aproximada
          const distance = this.levenshteinDistance(word.toLowerCase(), synonym);
          if (distance <= Math.max(1, Math.floor(synonym.length * 0.2))) {
            return correct;
          }
        }
      }
      
      return word;
    },
    
    // Corrige todo el mensaje
    correctMessage: function(message) {
      const words = message.split(/\s+/);
      let correctedWords = [];
      let foundCorrection = false;
      
      words.forEach(word => {
        // Mantener signos de puntuación
        const cleanWord = word.replace(/[.,!?;:]/g, '');
        const punctuation = word.match(/[.,!?;:]+$/);
        
        if (cleanWord.length > 2) {
          // CORRECCIÓN: Usar spellingCorrection.correctWord en lugar de this.correctWord
          const corrected = spellingCorrection.correctWord(cleanWord);
          if (corrected !== cleanWord) {
            correctedWords.push(corrected + (punctuation ? punctuation[0] : ''));
            foundCorrection = true;
          } else {
            correctedWords.push(word);
          }
        } else {
          correctedWords.push(word);
        }
      });
      
      return {
        correctedMessage: correctedWords.join(' '),
        hasCorrection: foundCorrection
      };
    }
  };

  // Cargar datos históricos (simulación)
  const loadHistoricalData = async () => {
    updateStatus("Cargando datos históricos...");
    
    return new Promise((resolve) => {
      // Simulación de carga de datos
      setTimeout(() => {
        // Generar datos simulados para los últimos 30 días
        const now = new Date();
        historicalData = [];
        
        for (let i = 29; i >= 0; i--) {
          const date = new Date(now);
          date.setDate(now.getDate() - i);
          
          historicalData.push({
            timestamp: date.toISOString(),
            temp: 20 + Math.random() * 10 - 5 * (i/30),
            hum: 60 + Math.random() * 20 - 10 * (i/30),
            pres: 1013 + Math.random() * 5 - 2 * (i/30),
            lluvia: i < 5 ? 1 : 0,
            wind: 5 + Math.random() * 10,
            wind_dir: Math.floor(Math.random() * 360),
            gas: 1.0 + Math.random() * 0.5
          });
        }
        
        resolve();
      }, 800);
    });
  };

  // Manejadores de intenciones
  const intentHandlers = {
    current_data: (entities, context) => {
      // Si no hay parámetros específicos, usar el último parámetro mencionado o uno por defecto
      let parameters = entities.parameters.length > 0 ? entities.parameters : 
                      (context.lastParameter ? [context.lastParameter] : ['temperatura']);
      
      // Actualizar contexto
      conversationContext.lastParameter = parameters[0];
      conversationContext.lastQuestionType = 'current_data';
      
      // Obtener el dato actual
      const latestData = historicalData[historicalData.length - 1];
      let response = '';
      
      parameters.forEach(param => {
        switch(param) {
          case 'temperatura':
            response += `La temperatura actual es de ${latestData.temp.toFixed(1)}°C.\n`;
            break;
          case 'humedad':
            response += `La humedad actual es del ${latestData.hum.toFixed(0)}%.\n`;
            break;
          case 'presión':
            response += `La presión atmosférica actual es de ${latestData.pres.toFixed(0)} hPa.\n`;
            break;
          case 'lluvia':
            response += `Actualmente ${latestData.lluvia ? 'está lloviendo' : 'no está lloviendo'}.\n`;
            break;
          case 'viento':
            response += `La velocidad del viento actual es de ${latestData.wind.toFixed(1)} m/s (${(latestData.wind * 3.6).toFixed(1)} km/h).\n`;
            break;
          case 'gas':
            response += `El nivel de gas actual es de ${latestData.gas.toFixed(2)} kΩ.\n`;
            break;
          case 'dirección':
            const directions = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'];
            const index = Math.round((latestData.wind_dir % 360) / 22.5) % 16;
            response += `La dirección del viento actual es ${directions[index]} (${latestData.wind_dir}°).\n`;
            break;
        }
      });
      
      // Añadir análisis contextual si es relevante
      if (parameters.length === 1) {
        const paramName = parameters[0];
        let contextAnalysis = '';
        
        switch(paramName) {
          case 'temperatura':
            if (latestData.temp > 25) {
              contextAnalysis = `Con esta temperatura, podrías considerar usar ropa ligera y mantenerse hidratado.`;
            } else if (latestData.temp < 10) {
              contextAnalysis = `Con esta temperatura, te recomendamos abrigarte adecuadamente para evitar el frío.`;
            }
            break;
          case 'humedad':
            if (latestData.hum > 70) {
              contextAnalysis = `La alta humedad puede hacer que la temperatura se sienta más alta de lo que realmente es.`;
            } else if (latestData.hum < 30) {
              contextAnalysis = `La baja humedad puede causar sequedad en la piel y las vías respiratorias.`;
            }
            break;
          case 'presión':
            if (latestData.pres < 1000) {
              contextAnalysis = `La presión atmosférica baja suele indicar condiciones climáticas inestables.`;
            } else if (latestData.pres > 1020) {
              contextAnalysis = `La presión atmosférica alta suele indicar condiciones climáticas estables y buen tiempo.`;
            }
            break;
        }
        
        if (contextAnalysis) {
          response += `\n${contextAnalysis}`;
        }
        
        response += `\n\n¿Te gustaría ver un análisis histórico de ${paramName} o una predicción para los próximos días?`;
      }
      
      return response.trim();
    },
    
    historical_trend: (entities, context) => {
      // Determinar el periodo
      let period = entities.periods.length > 0 ? entities.periods[0] : 
                  (context.lastPeriod ? context.lastPeriod : 'últimos 7 días');
      
      // Actualizar contexto
      conversationContext.lastPeriod = period;
      conversationContext.lastQuestionType = 'historical_trend';
      
      // Obtener datos para el periodo
      const periodInfo = periodMap[period] || periodMap['últimos 7 días'];
      const now = new Date();
      let startDate;
      
      if (periodInfo.type === 'day') {
        startDate = new Date(now);
        startDate.setDate(now.getDate() - periodInfo.value);
      } else if (periodInfo.type === 'week') {
        startDate = new Date(now);
        startDate.setDate(now.getDate() - (periodInfo.value * 7));
      } else if (periodInfo.type === 'month') {
        startDate = new Date(now);
        startDate.setMonth(now.getMonth() - periodInfo.value);
      }
      
      // Si no hay parámetros específicos, usar el último parámetro mencionado o uno por defecto
      let parameters = entities.parameters.length > 0 ? entities.parameters : 
                      (context.lastParameter ? [context.lastParameter] : ['temperatura']);
      
      // Preparar datos para el gráfico
      const chartData = historicalData
        .filter(data => new Date(data.timestamp) >= startDate)
        .map(data => ({
          x: new Date(data.timestamp),
          y: data[parameters[0] === 'presión' ? 'pres' : 
                 parameters[0] === 'lluvia' ? 'lluvia' : 
                 parameters[0]]
        }));
      
      // Generar la respuesta basada en el análisis de los datos
      const response = analyzeData(parameters[0], chartData, periodInfo);
      
      // Añade un gráfico de análisis
      const chartId = `prediction-chart-${Date.now()}`;
      const chartResponse = `
        <div class="prediction-chart-container">
          <div class="chart-title">Tendencia de ${parameters[0]} en ${period}</div>
          <canvas class="prediction-chart" id="${chartId}" 
                  data-parameter="${parameters[0]}" 
                  data-chart-data='${JSON.stringify(chartData)}'></canvas>
        </div>
      `;
      
      return response + chartResponse;
    },
    
    prediction: (entities, context) => {
      // Si no hay parámetros específicos, usar el último parámetro mencionado o uno por defecto
      let parameters = entities.parameters.length > 0 ? entities.parameters : 
                      (context.lastParameter ? [context.lastParameter] : ['temperatura']);
      
      // Actualizar contexto
      conversationContext.lastParameter = parameters[0];
      conversationContext.lastQuestionType = 'prediction';
      
      // Generar datos de predicción simulados
      const predictionData = [];
      const now = new Date();
      const latestData = historicalData[historicalData.length - 1];
      
      for (let i = 0; i < 5; i++) {
        const date = new Date(now);
        date.setDate(now.getDate() + i);
        
        let value;
        switch(parameters[0]) {
          case 'temperatura':
            value = latestData.temp + (Math.random() - 0.5) * 3;
            break;
          case 'humedad':
            value = latestData.hum + (Math.random() - 0.5) * 10;
            break;
          case 'presión':
            value = latestData.pres + (Math.random() - 0.5) * 3;
            break;
          case 'viento':
            value = latestData.wind + (Math.random() - 0.5) * 2;
            break;
          default:
            value = latestData.temp + (Math.random() - 0.5) * 3;
        }
        
        predictionData.push({
          x: date,
          y: value
        });
      }
      
      // Generar respuesta
      let response = '';
      const nextDay = new Date(now);
      nextDay.setDate(now.getDate() + 1);
      
      switch(parameters[0]) {
        case 'temperatura':
          response = `Para mañana ${nextDay.toLocaleDateString('es-ES', { weekday: 'long' })}, la temperatura se espera que esté entre ${(latestData.temp - 1).toFixed(1)}°C y ${(latestData.temp + 2).toFixed(1)}°C.\n\n`;
          response += `La tendencia a corto plazo sugiere ${latestData.temp < predictionData[1].y ? 'un aumento' : 'una disminución'} en la temperatura.\n\n`;
          break;
        case 'humedad':
          response = `Para mañana ${nextDay.toLocaleDateString('es-ES', { weekday: 'long' })}, la humedad se espera que esté alrededor del ${(latestData.hum + (Math.random() * 5 - 2.5)).toFixed(0)}%.\n\n`;
          response += `La tendencia a corto plazo sugiere ${latestData.hum < predictionData[1].y ? 'un aumento' : 'una disminución'} en la humedad.\n\n`;
          break;
        case 'presión':
          response = `Para mañana ${nextDay.toLocaleDateString('es-ES', { weekday: 'long' })}, la presión atmosférica se espera que esté alrededor de ${(latestData.pres + (Math.random() * 3 - 1.5)).toFixed(0)} hPa.\n\n`;
          response += `La tendencia a corto plazo sugiere ${latestData.pres < predictionData[1].y ? 'un aumento' : 'una disminución'} en la presión.\n\n`;
          break;
        case 'viento':
          response = `Para mañana ${nextDay.toLocaleDateString('es-ES', { weekday: 'long' })}, la velocidad del viento se espera que esté alrededor de ${(latestData.wind + (Math.random() * 2 - 1)).toFixed(1)} m/s.\n\n`;
          response += `La tendencia a corto plazo sugiere ${latestData.wind < predictionData[1].y ? 'un aumento' : 'una disminución'} en la velocidad del viento.\n\n`;
          break;
        default:
          response = `Para mañana ${nextDay.toLocaleDateString('es-ES', { weekday: 'long' })}, se espera que ${parameters[0]} muestre una tendencia ${latestData.temp < predictionData[1].y ? 'ascendente' : 'descendente'}.\n\n`;
      }
      
      response += `Esta predicción se basa en el análisis de los datos históricos de los últimos 30 días y tiene una confiabilidad estimada del 75%.`;
      
      // Añade un gráfico de predicción
      const chartId = `prediction-chart-${Date.now()}`;
      const reliability = 75;
      
      const chartResponse = `
        <div class="prediction-container">
          <div class="prediction-reliability">
            Confiabilidad de la predicción: ${reliability}% 
            <div class="reliability-bar">
              <div class="reliability-fill" style="width: ${reliability}%"></div>
            </div>
          </div>
          <div class="prediction-chart-container">
            <div class="chart-title">Predicción de ${parameters[0]} para los próximos 5 días</div>
            <canvas class="prediction-chart" id="${chartId}" 
                    data-parameter="${parameters[0]}" 
                    data-chart-data='${JSON.stringify(predictionData)}'></canvas>
          </div>
        </div>
      `;
      
      return response + chartResponse;
    },
    
    comparison: (entities, context) => {
      // Necesitamos al menos dos periodos para comparar
      if (entities.periods.length < 2) {
        return "Para hacer una comparación necesito dos periodos. Por ejemplo: 'Compara la temperatura de esta semana con la semana pasada'.";
      }
      
      const period1 = entities.periods[0];
      const period2 = entities.periods[1];
      
      // Actualizar contexto
      conversationContext.lastPeriod = period1;
      conversationContext.lastQuestionType = 'comparison';
      
      // Si no hay parámetros específicos, usar el último parámetro mencionado o uno por defecto
      let parameters = entities.parameters.length > 0 ? entities.parameters : 
                      (context.lastParameter ? [context.lastParameter] : ['temperatura']);
      
      // Obtener datos para ambos periodos
      const periodInfo1 = periodMap[period1] || periodMap['esta semana'];
      const periodInfo2 = periodMap[period2] || periodMap['últimos 7 días'];
      
      const now = new Date();
      let startDate1, startDate2;
      
      // Calcular fechas de inicio para ambos periodos
      if (periodInfo1.type === 'day') {
        startDate1 = new Date(now);
        startDate1.setDate(now.getDate() - periodInfo1.value);
      } else if (periodInfo1.type === 'week') {
        startDate1 = new Date(now);
        startDate1.setDate(now.getDate() - (periodInfo1.value * 7));
      } else if (periodInfo1.type === 'month') {
        startDate1 = new Date(now);
        startDate1.setMonth(now.getMonth() - periodInfo1.value);
      }
      
      if (periodInfo2.type === 'day') {
        startDate2 = new Date(now);
        startDate2.setDate(now.getDate() - periodInfo2.value);
      } else if (periodInfo2.type === 'week') {
        startDate2 = new Date(now);
        startDate2.setDate(now.getDate() - (periodInfo2.value * 7));
      } else if (periodInfo2.type === 'month') {
        startDate2 = new Date(now);
        startDate2.setMonth(now.getMonth() - periodInfo2.value);
      }
      
      // Obtener datos para ambos periodos
      const data1 = historicalData.filter(data => new Date(data.timestamp) >= startDate1);
      const data2 = historicalData.filter(data => new Date(data.timestamp) >= startDate2);
      
      // Calcular promedios
      const avg1 = data1.reduce((sum, item) => sum + item[parameters[0] === 'presión' ? 'pres' : 
                                     parameters[0] === 'lluvia' ? 'lluvia' : 
                                     parameters[0]], 0) / data1.length;
      const avg2 = data2.reduce((sum, item) => sum + item[parameters[0] === 'presión' ? 'pres' : 
                                     parameters[0] === 'lluvia' ? 'lluvia' : 
                                     parameters[0]], 0) / data2.length;
      
      // Generar respuesta
      let response = `Comparación de ${parameters[0]} entre ${period1} y ${period2}:\n\n`;
      
      response += `* ${period1.charAt(0).toUpperCase() + period1.slice(1)}: ${avg1.toFixed(2)}`;
      if (parameters[0] !== 'lluvia' && parameters[0] !== 'dirección') {
        response += ` ${parameters[0] === 'presión' ? 'hPa' : 
                    parameters[0] === 'humedad' ? '%' : 
                    '°C'}`;
      }
      response += `\n`;
      
      response += `* ${period2.charAt(0).toUpperCase() + period2.slice(1)}: ${avg2.toFixed(2)}`;
      if (parameters[0] !== 'lluvia' && parameters[0] !== 'dirección') {
        response += ` ${parameters[0] === 'presión' ? 'hPa' : 
                    parameters[0] === 'humedad' ? '%' : 
                    '°C'}`;
      }
      response += `\n\n`;
      
      const difference = avg1 - avg2;
      if (Math.abs(difference) > 0.01) {
        const percentChange = (Math.abs(difference) / avg2) * 100;
        if (difference > 0) {
          response += `La ${parameters[0]} fue ${percentChange.toFixed(1)}% mayor en ${period1} que en ${period2}.`;
        } else {
          response += `La ${parameters[0]} fue ${percentChange.toFixed(1)}% menor en ${period1} que en ${period2}.`;
        }
      } else {
        response += `La ${parameters[0]} fue muy similar en ambos periodos.`;
      }
      
      // Preparar datos para el gráfico comparativo
      const chartData1 = data1.map(data => ({
        x: new Date(data.timestamp),
        y: data[parameters[0] === 'presión' ? 'pres' : 
               parameters[0] === 'lluvia' ? 'lluvia' : 
               parameters[0]]
      }));
      
      const chartData2 = data2.map(data => ({
        x: new Date(data.timestamp),
        y: data[parameters[0] === 'presión' ? 'pres' : 
               parameters[0] === 'lluvia' ? 'lluvia' : 
               parameters[0]]
      }));
      
      // Añade un gráfico comparativo
      const chartId = `comparison-chart-${Date.now()}`;
      const chartResponse = `
        <div class="comparison-chart-container">
          <div class="chart-title">Comparación de ${parameters[0]}: ${period1} vs ${period2}</div>
          <canvas class="comparison-chart" id="${chartId}" 
                  data-parameter="${parameters[0]}" 
                  data-chart-data1='${JSON.stringify(chartData1)}'
                  data-chart-data2='${JSON.stringify(chartData2)}'
                  data-period1="${period1}"
                  data-period2="${period2}"></canvas>
        </div>
      `;
      
      return response + chartResponse;
    },
    
    max_min: (entities, context) => {
      // Determinar el periodo
      let period = entities.periods.length > 0 ? entities.periods[0] : 
                  (context.lastPeriod ? context.lastPeriod : 'últimos 7 días');
      
      // Actualizar contexto
      conversationContext.lastPeriod = period;
      conversationContext.lastQuestionType = 'max_min';
      
      // Obtener datos para el periodo
      const periodInfo = periodMap[period] || periodMap['últimos 7 días'];
      const now = new Date();
      let startDate;
      
      if (periodInfo.type === 'day') {
        startDate = new Date(now);
        startDate.setDate(now.getDate() - periodInfo.value);
      } else if (periodInfo.type === 'week') {
        startDate = new Date(now);
        startDate.setDate(now.getDate() - (periodInfo.value * 7));
      } else if (periodInfo.type === 'month') {
        startDate = new Date(now);
        startDate.setMonth(now.getMonth() - periodInfo.value);
      }
      
      // Si no hay parámetros específicos, usar el último parámetro mencionado o uno por defecto
      let parameters = entities.parameters.length > 0 ? entities.parameters : 
                      (context.lastParameter ? [context.lastParameter] : ['temperatura']);
      
      // Obtener datos para el periodo
      const periodData = historicalData.filter(data => new Date(data.timestamp) >= startDate);
      
      // Encontrar máximos y mínimos
      let max = -Infinity;
      let min = Infinity;
      let maxDate, minDate;
      
      periodData.forEach(data => {
        const value = data[parameters[0] === 'presión' ? 'pres' : 
                         parameters[0] === 'lluvia' ? 'lluvia' : 
                         parameters[0]];
                         
        if (value > max) {
          max = value;
          maxDate = data.timestamp;
        }
        
        if (value < min) {
          min = value;
          minDate = data.timestamp;
        }
      });
      
      // Generar respuesta
      let response = `En ${period}, el valor máximo de ${parameters[0]} fue de ${max.toFixed(2)}`;
      
      if (parameters[0] !== 'lluvia' && parameters[0] !== 'dirección') {
        response += ` ${parameters[0] === 'presión' ? 'hPa' : 
                    parameters[0] === 'humedad' ? '%' : 
                    '°C'}`;
      }
      
      response += ` registrado el ${new Date(maxDate).toLocaleDateString('es-ES', { 
        weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' 
      })}.\n\n`;
      
      response += `El valor mínimo fue de ${min.toFixed(2)}`;
      
      if (parameters[0] !== 'lluvia' && parameters[0] !== 'dirección') {
        response += ` ${parameters[0] === 'presión' ? 'hPa' : 
                    parameters[0] === 'humedad' ? '%' : 
                    '°C'}`;
      }
      
      response += ` registrado el ${new Date(minDate).toLocaleDateString('es-ES', { 
        weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' 
      })}.`;
      
      // Preparar datos para el gráfico
      const chartData = historicalData
        .filter(data => new Date(data.timestamp) >= startDate)
        .map(data => ({
          x: new Date(data.timestamp),
          y: data[parameters[0] === 'presión' ? 'pres' : 
                 parameters[0] === 'lluvia' ? 'lluvia' : 
                 parameters[0]]
        }));
      
      // Añade un gráfico con marcadores de máximos y mínimos
      const chartId = `extremes-chart-${Date.now()}`;
      const chartResponse = `
        <div class="extremes-chart-container">
          <div class="chart-title">Valores extremos de ${parameters[0]} en ${period}</div>
          <canvas class="extremes-chart" id="${chartId}" 
                  data-parameter="${parameters[0]}" 
                  data-chart-data='${JSON.stringify(chartData)}'
                  data-max-date="${maxDate}"
                  data-min-date="${minDate}"></canvas>
        </div>
      `;
      
      return response + chartResponse;
    },
    
    correlation: (entities, context) => {
      try {
        // Necesitamos al menos dos parámetros para analizar correlación
        if (entities.parameters.length < 2) {
          return "Para analizar correlación necesito dos parámetros meteorológicos. Por ejemplo: '¿Cómo se relaciona la temperatura con la humedad?'";
        }
        
        const parameter1 = entities.parameters[0];
        const parameter2 = entities.parameters[1];
        
        // Actualizar contexto
        conversationContext.lastParameter = parameter1;
        conversationContext.lastQuestionType = 'correlation';
        
        // Obtener datos para el periodo (usar últimos 30 días por defecto)
        const now = new Date();
        const startDate = new Date(now);
        startDate.setDate(now.getDate() - 30);
        
        const periodData = historicalData.filter(data => new Date(data.timestamp) >= startDate);
        
        // Calcular correlación
        const values1 = periodData.map(data => 
          data[parameter1 === 'presión' ? 'pres' : 
              parameter1 === 'lluvia' ? 'lluvia' : 
              parameter1]
        );
        
        const values2 = periodData.map(data => 
          data[parameter2 === 'presión' ? 'pres' : 
              parameter2 === 'lluvia' ? 'lluvia' : 
              parameter2]
        );
        
        // Calcular media
        const mean1 = values1.reduce((a, b) => a + b, 0) / values1.length;
        const mean2 = values2.reduce((a, b) => a + b, 0) / values2.length;
        
        // Calcular covarianza y desviación estándar
        let covariance = 0;
        let stdDev1 = 0;
        let stdDev2 = 0;
        
        for (let i = 0; i < values1.length; i++) {
          const diff1 = values1[i] - mean1;
          const diff2 = values2[i] - mean2;
          
          covariance += diff1 * diff2;
          stdDev1 += diff1 * diff1;
          stdDev2 += diff2 * diff2;
        }
        
        covariance /= values1.length;
        stdDev1 = Math.sqrt(stdDev1 / values1.length);
        stdDev2 = Math.sqrt(stdDev2 / values1.length);
        
        // Calcular coeficiente de correlación de Pearson
        const correlationCoefficient = covariance / (stdDev1 * stdDev2);
        
        // Generar respuesta basada en el coeficiente
        let response = `<div class="detailed-analysis">`;
        response += `<h3>Análisis de Correlación</h3>`;
        
        // Mapear nombres de parámetros a términos más descriptivos
        const paramNameMap = {
          'temperatura': 'la temperatura',
          'humedad': 'la humedad',
          'presión': 'la presión atmosférica',
          'lluvia': 'la lluvia',
          'viento': 'la velocidad del viento',
          'gas': 'el nivel de gas'
        };
        
        const param1Name = paramNameMap[parameter1] || parameter1;
        const param2Name = paramNameMap[parameter2] || parameter2;
        
        response += `<p>He analizado la relación entre ${param1Name} y ${param2Name} durante los últimos 30 días.</p>`;
        
        // Interpretar el coeficiente de correlación
        if (Math.abs(correlationCoefficient) > 0.7) {
          response += `<p>Existe una <strong>fuerte correlación</strong> entre estos dos parámetros, con un coeficiente de ${correlationCoefficient.toFixed(2)}.</p>`;
        } else if (Math.abs(correlationCoefficient) > 0.4) {
          response += `<p>Existe una <strong>correlación moderada</strong> entre estos dos parámetros, con un coeficiente de ${correlationCoefficient.toFixed(2)}.</p>`;
        } else if (Math.abs(correlationCoefficient) > 0.2) {
          response += `<p>Existe una <strong>ligera correlación</strong> entre estos dos parámetros, con un coeficiente de ${correlationCoefficient.toFixed(2)}.</p>`;
        } else {
          response += `<p>No hay una correlación significativa entre estos dos parámetros, con un coeficiente de ${correlationCoefficient.toFixed(2)}.</p>`;
        }
        
        // Interpretación contextual
        if (correlationCoefficient > 0.5) {
          response += `<p>Esto significa que cuando ${param1Name} aumenta, ${param2Name} tiende a aumentar también.</p>`;
        } else if (correlationCoefficient < -0.5) {
          response += `<p>Esto significa que cuando ${param1Name} aumenta, ${param2Name} tiende a disminuir.</p>`;
        } else {
          response += `<p>Los cambios en ${param1Name} no parecen tener una relación clara con los cambios en ${param2Name}.</p>`;
        }
        
        // Información adicional basada en pares específicos
        if ((parameter1 === 'temperatura' && parameter2 === 'humedad') || 
            (parameter1 === 'humedad' && parameter2 === 'temperatura')) {
          if (correlationCoefficient < 0) {
            response += `<p>Es común observar una correlación negativa entre temperatura y humedad, ya que el aire caliente puede contener más vapor de agua, pero la humedad relativa disminuye a medida que la temperatura aumenta.</p>`;
          }
        }
        
        if ((parameter1 === 'presión' && parameter2 === 'lluvia') || 
            (parameter1 === 'lluvia' && parameter2 === 'presión')) {
          if (correlationCoefficient < 0) {
            response += `<p>Es típico observar que la presión atmosférica baja antes de una lluvia, lo que explica la correlación negativa.</p>`;
          }
        }
        
        if ((parameter1 === 'temperatura' && parameter2 === 'presión') || 
            (parameter1 === 'presión' && parameter2 === 'temperatura')) {
          if (Math.abs(correlationCoefficient) < 0.3) {
            response += `<p>La temperatura y la presión atmosférica suelen tener una relación compleja que depende de muchos factores, por lo que no siempre se observa una correlación clara.</p>`;
          }
        }
        
        // Añadir información de confianza
        const confidence = Math.min(1, Math.abs(correlationCoefficient) * 0.8 + 0.2);
        response += `<div class="confidence-indicator">Confianza del análisis: ${(confidence * 100).toFixed(0)}%</div>`;
        
        // Preparar datos para el gráfico
        const chartData = periodData.map((data, index) => ({
          x: new Date(data.timestamp),
          y1: data[parameter1 === 'presión' ? 'pres' : 
                 parameter1 === 'lluvia' ? 'lluvia' : 
                 parameter1],
          y2: data[parameter2 === 'presión' ? 'pres' : 
                 parameter2 === 'lluvia' ? 'lluvia' : 
                 parameter2]
        }));
        
        // Añade un gráfico de correlación
        const chartId = `correlation-chart-${Date.now()}`;
        response += `
          <div class="prediction-chart-container">
            <div class="chart-title">Relación entre ${parameter1} y ${parameter2}</div>
            <canvas class="prediction-chart" id="${chartId}" 
                    data-parameter1="${parameter1}"
                    data-parameter2="${parameter2}"
                    data-chart-data='${JSON.stringify(chartData)}'></canvas>
          </div>
        `;
        
        response += `</div>`;
        
        return response;
      } catch (error) {
        console.error('Error en análisis de correlación:', error);
        return "⚠️ Ocurrió un error al analizar la correlación. Por favor, intenta nuevamente.";
      }
    },
    
    greeting: () => {
      const hours = new Date().getHours();
      let greeting;
      
      if (hours < 12) {
        greeting = "¡Buenos días! ";
      } else if (hours < 18) {
        greeting = "¡Buenas tardes! ";
      } else {
        greeting = "¡Buenas noches! ";
      }
      
      return `${greeting}Soy Horus AI, tu asistente meteorológico especializado. ¿En qué puedo ayudarte hoy?`;
    },
    
    goodbye: () => {
      return "¡Hasta luego! No dudes en volver si necesitas más información meteorológica.";
    },
    
    help: () => {
      return `Puedo ayudarte con consultas meteorológicas como:\n\n` +
             `- Consultar datos actuales: "¿Cuál es la temperatura ahora?"\n` +
             `- Analizar tendencias históricas: "Muestra la tendencia de humedad esta semana"\n` +
             `- Comparar periodos: "Compara la presión de esta semana con la semana pasada"\n` +
             `- Predecir condiciones: "¿Qué tiempo hará mañana?"\n` +
             `- Encontrar valores extremos: "¿Cuál fue la temperatura máxima esta semana?"\n` +
             `- Analizar correlaciones: "¿Cómo se relaciona la temperatura con la humedad?"\n\n` +
             `¿Sobre qué parámetro meteorológico te gustaría obtener información?`;
    },
    
    unrelated: (entities, context) => {
      return "No estoy seguro de entender tu pregunta. Soy un asistente meteorológico especializado. ¿Podrías reformular tu pregunta relacionada con el clima o las condiciones atmosféricas? Por ejemplo, puedes preguntar sobre temperatura, humedad, presión atmosférica o viento.";
    }
  };

  // Analiza los datos para generar una respuesta descriptiva
  const analyzeData = (parameter, chartData, periodInfo) => {
    if (chartData.length === 0) {
      return "No hay datos disponibles para el periodo seleccionado.";
    }
    
    // Calcular estadísticas
    const values = chartData.map(item => item.y);
    const sum = values.reduce((a, b) => a + b, 0);
    const average = sum / values.length;
    const max = Math.max(...values);
    const min = Math.min(...values);
    
    // Determinar tendencia
    const startValue = values[0];
    const endValue = values[values.length - 1];
    const trend = endValue > startValue ? "ascendente" : "descendente";
    const trendStrength = Math.abs(endValue - startValue) / startValue;
    
    // Generar respuesta
    let response = `<div class="detailed-analysis">`;
    response += `<h3>Análisis de ${parameter.charAt(0).toUpperCase() + parameter.slice(1)}</h3>`;
    
    // Descripción general
    response += `<p>En el periodo seleccionado (${periodInfo.type === 'day' ? periodInfo.value + ' días' : periodInfo.type}):</p>`;
    response += `<div class="statistics-grid">`;
    response += `<div class="stat-item"><strong>Promedio</strong><br><span class="stat-value">${average.toFixed(1)}`;
    if (parameter !== 'lluvia' && parameter !== 'dirección') {
      response += ` ${parameter === 'presión' ? 'hPa' : 
                  parameter === 'humedad' ? '%' : 
                  '°C'}`;
    }
    response += `</span></div>`;
    
    response += `<div class="stat-item"><strong>Máximo</strong><br><span class="stat-value">${max.toFixed(1)}`;
    if (parameter !== 'lluvia' && parameter !== 'dirección') {
      response += ` ${parameter === 'presión' ? 'hPa' : 
                  parameter === 'humedad' ? '%' : 
                  '°C'}`;
    }
    response += `</span></div>`;
    
    response += `<div class="stat-item"><strong>Mínimo</strong><br><span class="stat-value">${min.toFixed(1)}`;
    if (parameter !== 'lluvia' && parameter !== 'dirección') {
      response += ` ${parameter === 'presión' ? 'hPa' : 
                  parameter === 'humedad' ? '%' : 
                  '°C'}`;
    }
    response += `</span></div>`;
    response += `</div>`;
    
    // Análisis de tendencia
    if (trendStrength > 0.05) { // Si hay una tendencia significativa
      response += `<div class="trend-analysis">`;
      response += `<h3>Tendencia</h3>`;
      response += `<p>La tendencia es claramente ${trend} (${(trendStrength * 100).toFixed(1)}% de cambio).</p>`;
      
      if (parameter === 'temperatura') {
        response += trend === 'ascendente' ? 
          '<p>Esto sugiere un calentamiento progresivo en el periodo analizado. Podrías considerar ajustar tu ropa o planificar actividades al aire libre en los momentos más frescos del día.</p>' :
          '<p>Esto sugiere un enfriamiento progresivo en el periodo analizado. Podrías considerar abrigarte adecuadamente para las actividades al aire libre.</p>';
      } else if (parameter === 'humedad') {
        response += trend === 'ascendente' ? 
          '<p>El aumento de humedad podría indicar mayor probabilidad de precipitación. Considera llevar paraguas si planeas estar al aire libre.</p>' :
          '<p>La disminución de humedad sugiere condiciones más secas. Podrías necesitar hidratarte más frecuentemente.</p>';
      } else if (parameter === 'presión') {
        response += trend === 'ascendente' ? 
          '<p>El aumento de presión suele indicar condiciones climáticas estables y buen tiempo. Es un buen momento para actividades al aire libre.</p>' :
          '<p>La disminución de presión suele preceder a condiciones climáticas inestables. Podrías considerar prepararte para posibles cambios en el clima.</p>';
      }
      
      response += `</div>`;
    } else {
      response += `<div class="trend-analysis">`;
      response += `<h3>Tendencia</h3>`;
      response += `<p>La tendencia es relativamente estable sin cambios significativos.</p>`;
      response += `<p>Las condiciones meteorológicas permanecen consistentes durante el periodo analizado.</p>`;
      response += `</div>`;
    }
    
    // Añadir información contextual adicional
    response += `<div class="trend-analysis">`;
    response += `<h3>Recomendaciones</h3>`;
    
    switch(parameter) {
      case 'temperatura':
        if (average > 25) {
          response += `<p>Con temperaturas promedio por encima de 25°C, te recomendamos usar ropa ligera y mantener una buena hidratación.</p>`;
        } else if (average < 10) {
          response += `<p>Con temperaturas promedio por debajo de 10°C, te recomendamos abrigarte adecuadamente para protegerte del frío.</p>`;
        } else {
          response += `<p>Las temperaturas están dentro de un rango moderado. Considera vestir capas de ropa para adaptarte a los cambios durante el día.</p>`;
        }
        break;
      case 'humedad':
        if (average > 70) {
          response += `<p>La alta humedad puede hacer que la temperatura se sienta más alta de lo que realmente es. Considera usar ropa transpirable.</p>`;
        } else if (average < 30) {
          response += `<p>La baja humedad puede causar sequedad en la piel y las vías respiratorias. Considera usar humectante y mantenerte hidratado.</p>`;
        } else {
          response += `<p>La humedad está en un nivel moderado, lo que suele ser cómodo para la mayoría de las personas.</p>`;
        }
        break;
      case 'presión':
        if (average < 1000) {
          response += `<p>La presión atmosférica baja suele indicar condiciones climáticas inestables. Mantente atento a posibles cambios en el clima.</p>`;
        } else if (average > 1020) {
          response += `<p>La presión atmosférica alta suele indicar condiciones climáticas estables y buen tiempo. Es un buen momento para actividades al aire libre.</p>`;
        } else {
          response += `<p>La presión atmosférica está en un nivel normal, indicando condiciones climáticas estables.</p>`;
        }
        break;
    }
    
    response += `</div>`;
    response += `</div>`;
    
    return response;
  };

  // Renderizar gráficos
  const renderChart = (parameter, chartData, chartId) => {
    const chartCtx = document.getElementById(chartId)?.getContext('2d');
    if (!chartCtx) return;
    
    // Determina el nombre del parámetro y colores
    let paramName = '';
    let color = '#4a90e2';
    let unit = '';
    
    switch (parameter) {
      case 'temperatura':
        paramName = 'Temperatura';
        color = '#FF6384';
        unit = '°C';
        break;
      case 'humedad':
        paramName = 'Humedad';
        color = '#36A2EB';
        unit = '%';
        break;
      case 'presión':
        paramName = 'Presión Atmosférica';
        color = '#FFCE56';
        unit = 'hPa';
        break;
      case 'lluvia':
        paramName = 'Precipitación';
        color = '#46BFBD';
        unit = 'Presencia';
        break;
      case 'viento':
        paramName = 'Viento';
        color = '#C9CBCF';
        unit = 'm/s';
        break;
      case 'gas':
        paramName = 'Nivel de Gas';
        color = '#FDB45C';
        unit = 'kΩ';
        break;
      case 'dirección':
        paramName = 'Dirección del Viento';
        color = '#9966FF';
        unit = '°';
        break;
      default:
        paramName = 'Medición';
        unit = '';
    }
    
    // Crea el nuevo gráfico
    const chart = new Chart(chartCtx, {
      type: 'line',
      data: {
        datasets: [{
          label: paramName,
          data: chartData,
          borderColor: color,
          backgroundColor: `${color}40`,
          borderWidth: 3,
          tension: 0.3,
          pointRadius: 3
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            display: false
          },
          tooltip: {
            mode: 'index',
            intersect: false
          }
        },
        scales: {
          x: {
            type: 'time',
            time: {
              unit: 'day'
            },
            title: {
              display: true,
              text: 'Fecha'
            }
          },
          y: {
            beginAtZero: false,
            title: {
              display: true,
              text: unit
            }
          }
        }
      }
    });
    
    // Almacenar instancia del gráfico para actualizarla al cambiar de tema
    charts.push(chart);
  };
  
  // Renderizar gráficos de comparación
  const renderComparisonChart = (parameter, chartData1, chartData2, period1, period2, chartId) => {
    const chartCtx = document.getElementById(chartId)?.getContext('2d');
    if (!chartCtx) return;
    
    // Determina el nombre del parámetro y colores
    let paramName = '';
    let color1 = '#FF6384';
    let color2 = '#36A2EB';
    let unit = '';
    
    switch (parameter) {
      case 'temperatura':
        paramName = 'Temperatura';
        unit = '°C';
        break;
      case 'humedad':
        paramName = 'Humedad';
        unit = '%';
        break;
      case 'presión':
        paramName = 'Presión Atmosférica';
        unit = 'hPa';
        break;
      case 'lluvia':
        paramName = 'Precipitación';
        unit = 'Presencia';
        break;
      case 'viento':
        paramName = 'Viento';
        unit = 'm/s';
        break;
      case 'gas':
        paramName = 'Nivel de Gas';
        unit = 'kΩ';
        break;
      case 'dirección':
        paramName = 'Dirección del Viento';
        unit = '°';
        break;
      default:
        paramName = 'Medición';
        unit = '';
    }
    
    // Crea el nuevo gráfico
    const chart = new Chart(chartCtx, {
      type: 'line',
      data: {
        datasets: [
          {
            label: period1,
            data: chartData1,
            borderColor: color1,
            backgroundColor: `${color1}40`,
            borderWidth: 3,
            tension: 0.3,
            pointRadius: 3
          },
          {
            label: period2,
            data: chartData2,
            borderColor: color2,
            backgroundColor: `${color2}40`,
            borderWidth: 3,
            tension: 0.3,
            pointRadius: 3
          }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            position: 'top'
          },
          tooltip: {
            mode: 'index',
            intersect: false
          }
        },
        scales: {
          x: {
            type: 'time',
            time: {
              unit: 'day'
            },
            title: {
              display: true,
              text: 'Fecha'
            }
          },
          y: {
            beginAtZero: false,
            title: {
              display: true,
              text: unit
            }
          }
        }
      }
    });
    
    // Almacenar instancia del gráfico para actualizarla al cambiar de tema
    charts.push(chart);
  };

  // Renderizar gráficos de extremos
  const renderExtremesChart = (parameter, chartData, maxDate, minDate, chartId) => {
    const chartCtx = document.getElementById(chartId)?.getContext('2d');
    if (!chartCtx) return;
    
    // Determina el nombre del parámetro y colores
    let paramName = '';
    let color = '#4a90e2';
    let unit = '';
    
    switch (parameter) {
      case 'temperatura':
        paramName = 'Temperatura';
        color = '#FF6384';
        unit = '°C';
        break;
      case 'humedad':
        paramName = 'Humedad';
        color = '#36A2EB';
        unit = '%';
        break;
      case 'presión':
        paramName = 'Presión Atmosférica';
        color = '#FFCE56';
        unit = 'hPa';
        break;
      case 'lluvia':
        paramName = 'Precipitación';
        color = '#46BFBD';
        unit = 'Presencia';
        break;
      case 'viento':
        paramName = 'Viento';
        color = '#C9CBCF';
        unit = 'm/s';
        break;
      case 'gas':
        paramName = 'Nivel de Gas';
        color = '#FDB45C';
        unit = 'kΩ';
        break;
      case 'dirección':
        paramName = 'Dirección del Viento';
        color = '#9966FF';
        unit = '°';
        break;
      default:
        paramName = 'Medición';
        unit = '';
    }
    
    // Preparar datos con marcadores para máximos y mínimos
    const dataWithMarkers = chartData.map(item => ({
      x: item.x,
      y: item.y,
      pointBackgroundColor: item.x.toISOString() === maxDate || item.x.toISOString() === minDate ? 
                            (item.x.toISOString() === maxDate ? '#FF0000' : '#0000FF') : 
                            color
    }));
    
    // Crea el nuevo gráfico
    const chart = new Chart(chartCtx, {
      type: 'line',
      data: {
        datasets: [{
          label: paramName,
          data: dataWithMarkers,
          borderColor: color,
          backgroundColor: `${color}40`,
          borderWidth: 3,
          tension: 0.3,
          pointRadius: function(context) {
            const index = context.dataIndex;
            const value = context.dataset.data[index];
            return value.pointBackgroundColor !== color ? 6 : 3;
          },
          pointBackgroundColor: function(context) {
            const index = context.dataIndex;
            const value = context.dataset.data[index];
            return value.pointBackgroundColor;
          }
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            display: false
          },
          tooltip: {
            mode: 'index',
            intersect: false
          }
        },
        scales: {
          x: {
            type: 'time',
            time: {
              unit: 'day'
            },
            title: {
              display: true,
              text: 'Fecha'
            }
          },
          y: {
            beginAtZero: false,
            title: {
              display: true,
              text: unit
            }
          }
        }
      }
    });
    
    // Almacenar instancia del gráfico para actualizarla al cambiar de tema
    charts.push(chart);
  };

  // Renderizar gráficos de correlación
  const renderCorrelationChart = (parameter1, parameter2, chartData, chartId) => {
    const chartCtx = document.getElementById(chartId)?.getContext('2d');
    if (!chartCtx) return;
    
    // Determina los nombres de los parámetros y colores
    let paramName1 = '';
    let paramName2 = '';
    let color1 = '#FF6384';
    let color2 = '#36A2EB';
    let unit1 = '';
    let unit2 = '';
    
    const getParameterInfo = (parameter) => {
      switch (parameter) {
        case 'temperatura':
          return { name: 'Temperatura', color: '#FF6384', unit: '°C' };
        case 'humedad':
          return { name: 'Humedad', color: '#36A2EB', unit: '%' };
        case 'presión':
          return { name: 'Presión Atmosférica', color: '#FFCE56', unit: 'hPa' };
        case 'lluvia':
          return { name: 'Precipitación', color: '#46BFBD', unit: 'Presencia' };
        case 'viento':
          return { name: 'Viento', color: '#C9CBCF', unit: 'm/s' };
        case 'gas':
          return { name: 'Nivel de Gas', color: '#FDB45C', unit: 'kΩ' };
        case 'dirección':
          return { name: 'Dirección del Viento', color: '#9966FF', unit: '°' };
        default:
          return { name: 'Medición', color: '#4a90e2', unit: '' };
      }
    };
    
    const info1 = getParameterInfo(parameter1);
    const info2 = getParameterInfo(parameter2);
    
    paramName1 = info1.name;
    color1 = info1.color;
    unit1 = info1.unit;
    
    paramName2 = info2.name;
    color2 = info2.color;
    unit2 = info2.unit;
    
    // Crea el nuevo gráfico
    const chart = new Chart(chartCtx, {
      type: 'line',
      data: {
        datasets: [
          {
            label: paramName1,
            data: chartData.map(item => ({ x: item.x, y: item.y1 })),
            borderColor: color1,
            backgroundColor: `${color1}40`,
            borderWidth: 3,
            tension: 0.3,
            pointRadius: 3
          },
          {
            label: paramName2,
            data: chartData.map(item => ({ x: item.x, y: item.y2 })),
            borderColor: color2,
            backgroundColor: `${color2}40`,
            borderWidth: 3,
            tension: 0.3,
            pointRadius: 3
          }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            position: 'top'
          },
          tooltip: {
            mode: 'index',
            intersect: false
          }
        },
        scales: {
          x: {
            type: 'time',
            time: {
              unit: 'day'
            },
            title: {
              display: true,
              text: 'Fecha'
            }
          },
          y: {
            beginAtZero: false,
            title: {
              display: true,
              text: `${unit1} / ${unit2}`
            }
          }
        }
      }
    });
    
    // Almacenar instancia del gráfico para actualizarla al cambiar de tema
    charts.push(chart);
  };

  // Procesar mensaje del usuario
  const processUserMessage = async (message) => {
    // Guardar en historial de conversación
    conversationContext.conversationHistory.push({
      role: 'user',
      content: message,
      timestamp: new Date().toISOString()
    });
    
    // Corregir ortografía
    const { correctedMessage, hasCorrection } = spellingCorrection.correctMessage(message);
    
    // Mostrar mensaje de corrección SOLO si hubo correcciones significativas
    if (hasCorrection) {
      addMessage(`🔍 Entiendo que quizás quisiste decir: "${correctedMessage}"`, false);
    }
    
    // Normalizar mensaje
    const normalizedMessage = correctedMessage.toLowerCase().replace(/[.,!?]/g, '');
    
    // Análisis de ámbito
    const domainAnalysis = semanticAnalysis.analyzeDomain(normalizedMessage);
    
    // Verificar referencias
    const references = semanticAnalysis.analyzeReferences(normalizedMessage, conversationContext);
    
    // Resolver anáforas
    const resolvedMessage = semanticAnalysis.resolveAnaphora(normalizedMessage, conversationContext);
    
    // Verificar si es hipotética
    const isHypothetical = semanticAnalysis.analyzeHypotheticals(normalizedMessage);
    
    // Identificar entidades
    const entities = semanticAnalysis.identifyEntities(resolvedMessage);
    
    // Analizar intención
    const intent = semanticAnalysis.analyzeIntent(resolvedMessage, entities, domainAnalysis);
    
    // Verificar preguntas compuestas
    const isCompoundQuestion = semanticAnalysis.analyzeCompoundQuestions(normalizedMessage);
    
    // Entidades para la respuesta
    const detectedEntities = {
      parameters: entities.parameters,
      temporal: entities.periods,
      comparisons: entities.comparisons,
      operations: entities.operations
    };
    
    // Actualizar contexto temporal si se identifica uno
    if (entities.periods.length > 0) {
      conversationContext.temporalContext = entities.periods[0];
    }
    
    // Actualizar contexto de parámetros si se identifican
    if (entities.parameters.length > 0) {
      conversationContext.lastParameter = entities.parameters[0];
    }
    
    // Si hay referencias, actualizar contexto
    if (references.parameters.length > 0) {
      conversationContext.lastParameter = references.parameters[0];
    }
    
    // Si hay contexto de parámetro pero no se identificó en la pregunta, usar el contexto
    if (conversationContext.lastParameter && entities.parameters.length === 0) {
      entities.parameters = [conversationContext.lastParameter];
    }
    
    // Si hay contexto temporal pero no se identificó en la pregunta, usar el contexto
    if (conversationContext.lastPeriod && entities.periods.length === 0) {
      entities.periods = [conversationContext.lastPeriod];
    }
    
    try {
      // Procesar según la intención detectada
      if (intent && intent.confidence >= conversationContext.confidenceThreshold) {
        // Manejar intención reconocida
        if (intentHandlers[intent.type]) {
          return intentHandlers[intent.type](entities, conversationContext);
        }
      }
      
      // Si no se reconoció la intención pero es una pregunta meteorológica
      if (domainAnalysis.isWeatherQuestion) {
        // Intentar identificar parámetros incluso sin intención clara
        if (entities.parameters.length > 0) {
          // Si hay parámetros pero no intención clara, asumir consulta actual
          return intentHandlers.current_data({
            parameters: entities.parameters,
            periods: ['hoy']
          }, conversationContext);
        }
        
        // Si hay periodos pero no parámetros, pedir aclaración
        if (entities.periods.length > 0) {
          return "Para poder ayudarte, necesito saber qué parámetro meteorológico te interesa. Por ejemplo: 'temperatura', 'humedad' o 'presión'.";
        }
      }
      
      // Si es un saludo aunque no se haya detectado claramente
      if (semanticAnalysis.isGreeting(normalizedMessage)) {
        return intentHandlers.greeting();
      }
      
      // Si es una despedida aunque no se haya detectado claramente
      if (semanticAnalysis.isGoodbye(normalizedMessage)) {
        return intentHandlers.goodbye();
      }
      
      // Si es una solicitud de ayuda aunque no se haya detectado claramente
      if (semanticAnalysis.isHelpRequest(normalizedMessage)) {
        return intentHandlers.help();
      }
      
      // Si no se identifica un ámbito específico
      if (!domainAnalysis.isWeatherQuestion) {
        if (normalizedMessage.includes('política') || normalizedMessage.includes('politica')) {
          return "Soy un asistente meteorológico especializado. Para información política, te recomiendo consultar fuentes especializadas en política y actualidad.";
        }
        if (normalizedMessage.includes('religión') || normalizedMessage.includes('religion')) {
          return "Soy un asistente meteorológico especializado. Para información sobre religión, te recomiendo consultar fuentes especializadas en este tema.";
        }
      }
      
      // Si es una pregunta hipotética
      if (isHypothetical) {
        return "Como asistente meteorológico, solo puedo proporcionar información basada en datos reales y análisis históricos. No puedo especular sobre escenarios hipotéticos que no estén respaldados por datos climáticos.";
      }
      
      // Si es una pregunta compuesta
      if (isCompoundQuestion) {
        return "Para poder ayudarte mejor, por favor divide tu pregunta en partes más específicas. Por ejemplo, en lugar de preguntar sobre varios parámetros a la vez, enfócate en uno primero.";
      }
      
      // Si hay entidades detectadas pero no intención clara
      if (detectedEntities.parameters.length > 0 || 
          detectedEntities.temporal.length > 0 || 
          detectedEntities.comparisons.length > 0) {
        let response = "He detectado algunos elementos relevantes en tu pregunta, pero no estoy seguro de entender exactamente qué necesitas.\n\n";
        
        if (detectedEntities.parameters.length > 0) {
          response += `* Parámetros meteorológicos: ${detectedEntities.parameters.join(', ')}\n`;
        }
        if (detectedEntities.temporal.length > 0) {
          response += `* Periodos de tiempo: ${detectedEntities.temporal.join(', ')}\n`;
        }
        if (detectedEntities.comparisons.length > 0) {
          response += `* Tipos de comparación: ${detectedEntities.comparisons.map(c => 
            c === 'vs' ? 'comparación directa' : 
            c === 'trend' ? 'tendencia' : 
            c === 'correlation' ? 'correlación' : c).join(', ')}\n`;
        }
        if (detectedEntities.operations.length > 0) {
          response += `* Operaciones solicitadas: ${detectedEntities.operations.join(', ')}\n`;
        }
        
        response += `\n¿Podrías reformular tu pregunta para que sea más específica?`;
        
        return response;
      }
      
      // Si no hay contexto previo y no es claramente fuera de ámbito, asumimos que es general
      return "No estoy seguro de entender tu pregunta. Soy un asistente meteorológico especializado. ¿Podrías reformular tu pregunta relacionada con el clima o las condiciones atmosféricas? Por ejemplo, puedes preguntar sobre temperatura, humedad, presión atmosférica o viento.";
      
    } catch (error) {
      console.error('Error procesando mensaje:', error);
      return "⚠️ Ocurrió un error al procesar tu solicitud. Por favor, intenta nuevamente.";
    }
  };

  // Enviar mensaje
  const sendMessage = async () => {
    const message = userInput.value.trim();
    if (message === '' || !chatbotReady) return;
    
    // Añade mensaje del usuario
    addMessage(message, true);
    userInput.value = '';
    
    // Muestra "escribiendo..."
    const loadingId = showLoading();
    
    try {
      // Procesa el mensaje
      const response = await processUserMessage(message);
      
      // Remueve el mensaje de "escribiendo..."
      document.getElementById(loadingId).remove();
      
      // Muestra la respuesta
      addMessage(response, false, 'local');
      
      // Renderizar gráficos si existen
      setTimeout(() => {
        document.querySelectorAll('.prediction-chart').forEach(canvas => {
          const parameter = canvas.dataset.parameter;
          const chartData = JSON.parse(canvas.dataset.chartData);
          renderChart(parameter, chartData, canvas.id);
        });
        
        document.querySelectorAll('.comparison-chart').forEach(canvas => {
          const parameter = canvas.dataset.parameter;
          const chartData1 = JSON.parse(canvas.dataset.chartData1);
          const chartData2 = JSON.parse(canvas.dataset.chartData2);
          const period1 = canvas.dataset.period1;
          const period2 = canvas.dataset.period2;
          renderComparisonChart(parameter, chartData1, chartData2, period1, period2, canvas.id);
        });
        
        document.querySelectorAll('.extremes-chart').forEach(canvas => {
          const parameter = canvas.dataset.parameter;
          const chartData = JSON.parse(canvas.dataset.chartData);
          const maxDate = canvas.dataset.maxDate;
          const minDate = canvas.dataset.minDate;
          renderExtremesChart(parameter, chartData, maxDate, minDate, canvas.id);
        });
        
        document.querySelectorAll('.correlation-chart').forEach(canvas => {
          const parameter1 = canvas.dataset.parameter1;
          const parameter2 = canvas.dataset.parameter2;
          const chartData = JSON.parse(canvas.dataset.chartData);
          renderCorrelationChart(parameter1, parameter2, chartData, canvas.id);
        });
      }, 100);
      
    } catch (error) {
      console.error('Error procesando mensaje:', error);
      document.getElementById(loadingId).remove();
      addMessage("⚠️ Ocurrió un error al procesar tu solicitud. Por favor, intenta nuevamente.", false);
    }
  };

  // Inicializar chatbot
  const initChatbot = async () => {
    try {
      // Carga datos históricos
      await loadHistoricalData();
      
      chatbotReady = true;
      
      // Configurar sugerencias
      document.querySelectorAll('.suggestion').forEach(suggestion => {
        suggestion.addEventListener('click', () => {
          userInput.value = suggestion.textContent;
          sendMessage();
        });
      });
      
      // Hacer disponible para main.js
      window.updateChatbotCharts = () => {
        // Destruir y recrear los gráficos para actualizar colores
        charts.forEach(chart => {
          if (chart && chart.destroy) {
            chart.destroy();
          }
        });
        charts = [];
        
        // Volver a renderizar todos los gráficos
        setTimeout(() => {
          document.querySelectorAll('.prediction-chart').forEach(canvas => {
            const parameter = canvas.dataset.parameter;
            const chartData = JSON.parse(canvas.dataset.chartData);
            renderChart(parameter, chartData, canvas.id);
          });
          
          document.querySelectorAll('.comparison-chart').forEach(canvas => {
            const parameter = canvas.dataset.parameter;
            const chartData1 = JSON.parse(canvas.dataset.chartData1);
            const chartData2 = JSON.parse(canvas.dataset.chartData2);
            const period1 = canvas.dataset.period1;
            const period2 = canvas.dataset.period2;
            renderComparisonChart(parameter, chartData1, chartData2, period1, period2, canvas.id);
          });
          
          document.querySelectorAll('.extremes-chart').forEach(canvas => {
            const parameter = canvas.dataset.parameter;
            const chartData = JSON.parse(canvas.dataset.chartData);
            const maxDate = canvas.dataset.maxDate;
            const minDate = canvas.dataset.minDate;
            renderExtremesChart(parameter, chartData, maxDate, minDate, canvas.id);
          });
          
          document.querySelectorAll('.correlation-chart').forEach(canvas => {
            const parameter1 = canvas.dataset.parameter1;
            const parameter2 = canvas.dataset.parameter2;
            const chartData = JSON.parse(canvas.dataset.chartData);
            renderCorrelationChart(parameter1, parameter2, chartData, canvas.id);
          });
        }, 100);
      };
      
    } catch (error) {
      console.error('Error inicializando chatbot:', error);
      chatbotReady = true;
      addMessage("⚠️ Hubo un problema al cargar los datos. Algunas funciones avanzadas podrían no estar disponibles.", false);
    }
  };

  // Event listeners
  sendButton.addEventListener('click', sendMessage);
  userInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') sendMessage();
  });
  
  // Inicializar el chatbot
  initChatbot();
</script>
</body>
</html>
