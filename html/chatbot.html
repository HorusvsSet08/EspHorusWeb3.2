<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Chatbot Meteorol√≥gico - Horus</title>
  <link rel="stylesheet" href="../css/style.css" />
  <link rel="stylesheet" href="../css/chatbot.css" />
  <script src="../js/PapaParse.js"></script>
  <script src="../js/chart.js"></script>
</head>
<body class="light-mode chatbot-page">
<nav class="nav">
  <div class="nav-container">
    <div class="nav-buttons">
      <a href="../index.html" class="nav-btn"><span class="nav-icon">üè†</span> Inicio</a>
      <a href="mqtt.html" class="nav-btn">
        <span class="nav-icon">üì°</span> Datos en Vivo
      </a>
      <a href="analisis.html" class="nav-btn">
        <span class="nav-icon">üìä</span> An√°lisis
      </a>
      <a href="chatbot.html" class="nav-btn active">
        <span class="nav-icon">ü§ñ</span> Chatbot
      </a>
    </div>
    <!-- Switch de Galahad -->
    <div class="nav-right">
      <label class="theme-switch">
        <input type="checkbox" class="theme-switch__checkbox">
        <div class="theme-switch__container">
          <div class="theme-switch__clouds"></div>
          <div class="theme-switch__stars-container">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 144 55" fill="none">
            </svg>
          </div>
          <div class="theme-switch__sun-moon-container">
            <div class="theme-switch__moon">
              <div class="theme-switch__spot"></div>
              <div class="theme-switch__spot"></div>
              <div class="theme-switch__spot"></div>
            </div>
          </div>
        </div>
      </label>
    </div>
  </div>
</nav>

<div class="container">
  <header>
    <h1>ü§ñ Horus AI - Asistente Inteligente</h1>
    <p>Un asistente con an√°lisis meteorol√≥gico avanzado y soporte para preguntas generales</p>
  </header>
  
  <main id="chat-container" class="chat-main-container">
    <div id="chat-messages" class="chat-messages">
      <div class="message bot welcome-message">
        <div class="bot-avatar">
          <span>ü§ñ</span>
        </div>
        <div class="message-content">
          ¬°Hola! Soy Horus AI, tu asistente inteligente especializado en meteorolog√≠a.<br><br>
          <strong>Puedo ayudarte con:</strong>
          <ul>
            <li>Consultar la temperatura, humedad, presi√≥n y otros datos actuales</li>
            <li>Analizar tendencias hist√≥ricas de los √∫ltimos d√≠as, semanas o meses</li>
            <li>Comparar condiciones meteorol√≥gicas entre diferentes periodos</li>
            <li>Predecir condiciones clim√°ticas basado en datos hist√≥ricos</li>
            <li>Responder preguntas generales sobre el sistema Horus</li>
            <li>Ayudar con preguntas b√°sicas no relacionadas con el clima</li>
          </ul>
          <br>
          <strong>Ejemplos de preguntas:</strong>
          <div class="suggestion">¬øCu√°l es la temperatura actual?</div>
          <div class="suggestion">¬øC√≥mo funciona este sistema?</div>
          <div class="suggestion">Muestra la tendencia de presi√≥n de los √∫ltimos 7 d√≠as</div>
        </div>
        <div class="message-time">Ahora</div>
      </div>
    </div>
    
    <div class="chat-input-container">
      <input type="text" id="user-input" placeholder="Escribe tu pregunta...">
      <button id="send-button">Enviar</button>
    </div>
    
    <div class="status-bar">
      <div id="status-indicator" class="status-indicator"></div>
      <span id="status-text">Horus AI esperando tu pregunta...</span>
    </div>
  </main>
</div>

<style>
  /* Estilos para el contenedor del chat */
  .chat-main-container {
    max-width: 900px;
    margin: 0 auto;
    background: var(--card-bg);
    border-radius: var(--border-radius);
    overflow: hidden;
    box-shadow: var(--shadow);
  }

  /* Mensajes del chat */
  .chat-messages {
    height: 60vh;
    overflow-y: auto;
    padding: 15px;
    background: var(--dark-bg);
  }

  .message {
    display: flex;
    margin-bottom: 15px;
    animation: fadeIn 0.3s ease;
  }

  .message.user {
    justify-content: flex-end;
  }

  .message.bot {
    justify-content: flex-start;
  }

  .bot-avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: var(--primary);
    display: flex;
    align-items: center;
    justify-content: center;
    margin-right: 10px;
    flex-shrink: 0;
  }

  .bot-avatar span {
    font-size: 20px;
  }

  .message-content {
    background: var(--card-bg);
    color: var(--text);
    padding: 12px 15px;
    border-radius: 18px;
    max-width: 75%;
    line-height: 1.5;
  }

  .message.user .message-content {
    background: var(--primary);
    color: #000;
    border-bottom-right-radius: 5px;
  }

  .message-time {
    font-size: 11px;
    color: var(--text-secondary);
    margin-top: 5px;
    text-align: right;
    opacity: 0.7;
  }

  /* Barra de entrada */
  .chat-input-container {
    display: flex;
    padding: 10px 15px;
    background: var(--card-bg);
    border-top: 1px solid rgba(255, 255, 255, 0.05);
  }

  .chat-input-container input {
    flex: 1;
    padding: 12px 15px;
    border: none;
    background: var(--dark-bg);
    color: var(--text);
    border-radius: 20px 0 0 20px;
    font-size: 16px;
    outline: none;
    transition: var(--transition);
  }

  .chat-input-container input:focus {
    box-shadow: 0 0 0 2px var(--primary-glow);
  }

  .chat-input-container button {
    background: var(--primary);
    color: #000;
    border: none;
    padding: 12px 20px;
    border-radius: 0 20px 20px 0;
    cursor: pointer;
    font-weight: bold;
    transition: var(--transition);
  }

  .chat-input-container button:hover {
    background: #00d0e0;
    transform: translateY(-2px);
  }

  /* Barra de estado */
  .status-bar {
    padding: 8px 15px;
    background: rgba(0, 0, 0, 0.1);
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .status-indicator {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: #4CAF50;
    box-shadow: 0 0 6px rgba(76, 175, 80, 0.7);
  }

  .status-indicator.error {
    background: #f44336;
    box-shadow: 0 0 6px rgba(244, 67, 54, 0.7);
  }

  /* Sugerencias de preguntas */
  .suggestion {
    background: rgba(255, 255, 255, 0.1);
    padding: 8px 12px;
    border-radius: 12px;
    margin: 5px 0;
    cursor: pointer;
    transition: var(--transition);
  }

  .suggestion:hover {
    background: rgba(0, 234, 255, 0.2);
    transform: translateX(5px);
  }

  /* Efecto de escritura */
  .typing-indicator {
    display: inline-flex;
    gap: 4px;
    margin-right: 8px;
  }

  .typing-indicator span {
    width: 6px;
    height: 6px;
    background: var(--primary);
    border-radius: 50%;
    animation: typing 1s infinite;
  }

  .typing-indicator span:nth-child(2) {
    animation-delay: 0.2s;
  }

  .typing-indicator span:nth-child(3) {
    animation-delay: 0.4s;
  }

  @keyframes typing {
    0%, 100% { transform: translateY(0); opacity: 0.5; }
    50% { transform: translateY(-5px); opacity: 1; }
  }

  /* An√°lisis de datos */
  .analysis-header {
    margin-bottom: 15px;
  }

  .analysis-header h2 {
    font-size: 1.2rem;
    margin-bottom: 8px;
    color: var(--primary);
  }

  .analysis-header p {
    color: var(--text-secondary);
    font-size: 0.9rem;
  }

  .statistics-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
    margin-bottom: 20px;
  }

  .stat-item {
    background: rgba(0, 234, 255, 0.1);
    padding: 10px;
    border-radius: 8px;
    text-align: center;
  }

  .stat-value {
    font-size: 1.3rem;
    font-weight: bold;
    color: var(--primary);
    display: block;
    margin-top: 5px;
  }

  .trend-analysis {
    background: rgba(0, 0, 0, 0.2);
    padding: 15px;
    border-radius: 10px;
    margin-top: 15px;
  }

  .trend-analysis h3 {
    margin-top: 0;
    color: var(--primary);
  }

  .trend-description {
    color: var(--text-secondary);
  }

  .prediction-container {
    margin-top: 15px;
  }

  .prediction-reliability {
    margin-bottom: 10px;
    font-size: 0.9rem;
  }

  .reliability-bar {
    height: 6px;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 3px;
    margin-top: 4px;
  }

  .reliability-fill {
    height: 100%;
    background: var(--primary);
    border-radius: 3px;
    transition: width 0.5s ease;
  }

  .prediction-chart-container {
    height: 250px;
    margin-top: 10px;
  }

  .chart-title {
    font-weight: bold;
    margin-bottom: 8px;
    color: var(--primary);
    font-size: 1rem;
  }

  .source-badge {
    display: inline-block;
    margin-left: 5px;
    font-size: 0.8rem;
    opacity: 0.7;
  }

  .welcome-message {
    background: rgba(0, 234, 255, 0.05);
    border-radius: 15px;
    padding: 15px;
    border: 1px solid rgba(0, 234, 255, 0.2);
  }
  
  /* An√°lisis detallado */
  .detailed-analysis {
    margin-top: 15px;
    background: rgba(0, 0, 0, 0.1);
    padding: 15px;
    border-radius: 10px;
  }
  
  .detailed-analysis h3 {
    color: var(--primary);
    margin-top: 0;
  }
  
  .detailed-analysis p {
    line-height: 1.6;
    margin-bottom: 10px;
  }
  
  .confidence-indicator {
    display: inline-block;
    background: rgba(76, 175, 80, 0.2);
    color: #4CAF50;
    padding: 2px 8px;
    border-radius: 10px;
    font-size: 0.8rem;
    margin-top: 5px;
  }
  
  /* Soporte para preguntas generales */
  .general-answer {
    margin-top: 15px;
    background: rgba(0, 150, 255, 0.1);
    padding: 15px;
    border-radius: 10px;
  }
  
  .general-answer h3 {
    color: var(--primary);
    margin-top: 0;
  }
  
  .general-answer p {
    line-height: 1.6;
  }
  
  .general-answer ul {
    padding-left: 20px;
    margin: 10px 0;
  }
  
  .general-answer li {
    margin-bottom: 5px;
  }
  
  .system-info {
    margin-top: 15px;
    background: rgba(76, 175, 80, 0.1);
    padding: 15px;
    border-radius: 10px;
  }
  
  .system-info h3 {
    color: #4CAF50;
    margin-top: 0;
  }
  
  .system-info p {
    line-height: 1.6;
  }
  
  /* Soporte para preguntas fuera del √°mbito */
  .out-of-scope {
    margin-top: 15px;
    background: rgba(244, 67, 54, 0.1);
    padding: 15px;
    border-radius: 10px;
  }
  
  .out-of-scope h3 {
    color: #f44336;
    margin-top: 0;
  }
  
  .out-of-scope p {
    line-height: 1.6;
  }
</style>

<script>
  // Variables globales
  let historicalData = [];
  let chatbotReady = false;
  let charts = []; // Para almacenar instancias de gr√°ficos
  
  // Contexto de conversaci√≥n mejorado
  let conversationContext = {
    lastParameter: null,
    lastPeriod: null,
    lastQuestionType: null,
    conversationHistory: [],
    entityContext: {},
    temporalContext: null,
    spatialContext: null,
    confidenceThreshold: 0.65 // Umbral de confianza para aceptar una intenci√≥n
  };

  // Elementos del DOM
  const chatMessages = document.getElementById('chat-messages');
  const userInput = document.getElementById('user-input');
  const sendButton = document.getElementById('send-button');
  const statusIndicator = document.getElementById('status-indicator');
  const statusText = document.getElementById('status-text');

  // Actualizar estado
  const updateStatus = (message, isError = false) => {
    statusText.textContent = message;
    if (isError) {
      statusIndicator.classList.add('error');
    } else {
      statusIndicator.classList.remove('error');
    }
  };

  // A√±adir mensaje al chat
  const addMessage = (content, isUser = false, source = 'local') => {
    const messageDiv = document.createElement('div');
    messageDiv.classList.add('message');
    messageDiv.classList.add(isUser ? 'user' : 'bot');
    
    // Marca de fuente para mensajes del bot
    const sourceBadge = source !== 'local' 
      ? `<span class="source-badge" title="Informaci√≥n obtenida de: ${source}">${source === 'web' ? 'üåê' : source}</span>` 
      : '';
      
    if (isUser) {
      messageDiv.innerHTML = `
        <div class="message-content">${content}</div>
        <div class="message-time">${new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</div>
      `;
    } else {
      messageDiv.innerHTML = `
        <div class="bot-avatar"><span>ü§ñ</span></div>
        <div class="message-content">${content}${sourceBadge}</div>
        <div class="message-time">Ahora</div>
      `;
    }
    
    chatMessages.appendChild(messageDiv);
    chatMessages.scrollTop = chatMessages.scrollHeight;
    
    // Actualizar el tiempo "Ahora" a minutos reales despu√©s de 5 segundos
    setTimeout(() => {
      const timeElement = messageDiv.querySelector('.message-time');
      if (timeElement && timeElement.textContent === 'Ahora') {
        timeElement.textContent = new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
      }
    }, 5000);
    
    // Guardar en historial de conversaci√≥n
    if (!isUser) {
      conversationContext.conversationHistory.push({
        role: 'assistant',
        content,
        timestamp: new Date().toISOString()
      });
    }
  };

  // Mostrar estado de carga
  const showLoading = (message = "Analizando tu pregunta") => {
    const loadingId = `loading-${Date.now()}`;
    const loadingDiv = document.createElement('div');
    loadingDiv.id = loadingId;
    loadingDiv.className = 'message bot';
    loadingDiv.innerHTML = `
      <div class="bot-avatar"><span>ü§ñ</span></div>
      <div class="message-content">
        <div class="typing-indicator"><span></span><span></span><span></span></div>
        <div class="loading-text">${message}</div>
      </div>
      <div class="message-time">Escribiendo...</div>
    `;
    chatMessages.appendChild(loadingDiv);
    chatMessages.scrollTop = chatMessages.scrollHeight;
    return loadingId;
  };

  // Diccionario de sin√≥nimos meteorol√≥gicos mejorado
  const weatherSynonyms = {
    temperatura: ['temp', 'calor', 'fr√≠o', 'frio', 'grados', '¬∞', 'celsius', 'cent√≠grados', 'centigrados', 'term√≥metro', 'termometro'],
    humedad: ['hum', 'vapor', 'agua', 'porcentaje de agua', '% agua', 'humedad relativa'],
    presi√≥n: ['pres', 'atmosf√©rica', 'barom√©trica', 'barometrica', 'hpa', 'mb', 'presi√≥n atmosf√©rica'],
    lluvia: ['precipitaci√≥n', 'precipitacion', 'agua', 'llovizna', 'tormenta', 'lluvioso', 'precipitaciones', 'pluviometr√≠a', 'pluviometria'],
    viento: ['velocidad del viento', 'r√°fagas', 'r√°faga', 'r√°fagas de viento', 'velocidad viento', 'km/h', 'nudos', 'direcci√≥n del viento', 'direccion viento', 'brisa'],
    gas: ['calidad del aire', 'calidad aire', 'contaminaci√≥n', 'contaminacion', 'pm2.5', 'pm10', 'part√≠culas', 'particulas', 'co2', 'di√≥xido de carbono'],
    direcci√≥n: ['direccion', 'rumbo', 'orientaci√≥n', 'orientacion', 'grados', 'norte', 'sur', 'este', 'oeste', 'cardinal'],
    an√°lisis: ['analisis', 'tendencia', 'tendencias', 'evoluci√≥n', 'comportamiento', 'patr√≥n', 'patron', 'estad√≠stica', 'estadisticas'],
    predicci√≥n: ['prediccion', 'pron√≥stico', 'pronostico', 'previsi√≥n', 'prevision', 'futuro', 'ma√±ana', 'siguiente', 'proyecci√≥n', 'proyeccion'],
    actual: ['ahora', 'en este momento', 'en este instante', 'actualidad', 'presente', 'en directo', 'en tiempo real', 'hoy'],
    hist√≥rico: ['historico', 'pasado', 'antes', 'anterior', 'anteriores', 'd√≠as anteriores', 'semanas anteriores', '√∫ltimos d√≠as'],
    comparar: ['comparaci√≥n', 'comparar', 'compara', 'diferencia', 'vs', 'versus', 'comparativo', 'entre', 'y'],
    m√°ximo: ['maximo', 'm√°ximo', 'pico', 'peak', 'm√°s alto', 'mayor', 'm√°x', 'max'],
    m√≠nimo: ['minimo', 'm√≠nimo', 'm√°s bajo', 'menor', 'm√≠n', 'min'],
    tendencia: ['tendencia', 'tendencias', 'evoluci√≥n', 'comportamiento', 'patr√≥n', 'patron', 'cambios', 'variaci√≥n', 'variacion'],
    probabilidad: ['probabilidad', 'probable', 'posibilidad', 'posible', 'chance', 'oportunidad', 'riesgo']
  };

  // Diccionario de t√©rminos generales
  const generalTerms = {
    // Sistema Horus
    horus: ['horus', 'sistema horus', 'estaci√≥n horus', 'estacion horus', 'estaci√≥n meteorol√≥gica', 'estacion meteorologica', 'sistema meteorol√≥gico', 'sistema meteorologico'],
    
    // Informaci√≥n general
    about: ['qu√© es', 'que es', 'qu√© es esto', 'que es esto', 'para qu√© sirve', 'para que sirve', 'qu√© hace', 'que hace', 'funciona', 'c√≥mo funciona', 'como funciona'],
    
    // Ayuda
    help: ['ayuda', 'funciona', 'c√≥mo', 'como', 'puedo', 'capaz', 'hacer', 'qu√©', 'que', 'preguntar', 'instrucciones', 'ejemplo', 'ejemplos', 'gu√≠a', 'manual', 'tutorial'],
    
    // Saludos
    greeting: ['hola', 'buenos d√≠as', 'buenos dias', 'buenas tardes', 'hey', 'saludos', 'buen d√≠a', 'buen dia', 'buenas noches', 'que tal', 'como estas', 'c√≥mo est√°s'],
    
    // Despedidas
    goodbye: ['adi√≥s', 'adios', 'gracias', 'chao', 'hasta luego', 'hasta pronto', 'nos vemos', 'bye', 'grac√≠as', 'gracias', 'fue √∫til', 'fue util'],
    
    // Soporte t√©cnico
    support: ['problema', 'error', 'no funciona', 'fallo', 'bug', 'no carga', 'lento', 'lentitud', 'lenta', 'lento', 'no responde', 'no me deja', 'no puedo'],
    
    // Informaci√≥n personal
    personal: ['qui√©n eres', 'quien eres', 'qui√©n eres t√∫', 'quien eres tu', 'qui√©n te hizo', 'quien te hizo', 'qui√©n te cre√≥', 'quien te creo', 'tu creador', 'tu creador es'],
    
    // Preguntas generales
    general: ['cu√°l es tu nombre', 'cual es tu nombre', 'c√≥mo te llamas', 'como te llamas', 'qu√© edad tienes', 'que edad tienes', 'd√≥nde vives', 'donde vives', 'qu√© hora es', 'que hora es'],
    
    // Soporte para preguntas fuera del √°mbito
    outOfScope: {
      salud: ['salud', 'm√©dico', 'doctor', 'enfermedad', 'enfermo', 'hospital', 'farmacia', 'medicina', 'medicamento', 'cura'],
      tecnolog√≠a: ['tecnolog√≠a', 'tecnologia', 'computadora', 'ordenador', 'pc', 'laptop', 'smartphone', 'm√≥vil', 'celular', 'internet', 'wifi', 'redes'],
      deportes: ['deportes', 'f√∫tbol', 'futbol', 'baloncesto', 'tenis', 'golf', 'atletismo', 'deporte', 'equipo', 'partido', 'liga'],
      entretenimiento: ['entretenimiento', 'pel√≠cula', 'pelicula', 'cine', 'm√∫sica', 'musica', 'canci√≥n', 'cancion', 'serie', 'televisi√≥n', 'tv'],
      comida: ['comida', 'receta', 'cocina', 'plato', 'platos', 'cocinar', 'comer', 'restaurante', 'recetas', 'recetario'],
      educaci√≥n: ['educaci√≥n', 'educacion', 'escuela', 'colegio', 'universidad', 'clase', 'clases', 'estudio', 'estudiar', 'profesor'],
      finanzas: ['finanzas', 'dinero', 'banco', 'cuenta', 'tarjeta', 'cr√©dito', 'credito', 'ahorro', 'inversi√≥n', 'inversion']
    }
  };

  // Mapeo de intenciones mejorado
  const intentMap = {
    current_data: {
      keywords: ['actual', 'ahora', 'en este momento', 'en directo', 'presente', 'en tiempo real', 'hoy'],
      parameters: ['temperatura', 'humedad', 'presi√≥n', 'lluvia', 'viento', 'gas', 'direcci√≥n'],
      required: []
    },
    historical_trend: {
      keywords: ['tendencia', 'evoluci√≥n', 'comportamiento', 'an√°lisis', 'analisis', 'patr√≥n', 'patron', 'gr√°fico', 'grafico', 'historial', 'historico', 'hist√≥rico', 'evolucion', 'variacion'],
      parameters: ['temperatura', 'humedad', 'presi√≥n', 'lluvia', 'viento', 'gas'],
      required: ['period']
    },
    prediction: {
      keywords: ['predicci√≥n', 'prediccion', 'pron√≥stico', 'pronostico', 'previsi√≥n', 'prevision', 'futuro', 'ma√±ana', 'siguiente', 'proyecci√≥n', 'proyeccion', 'probabilidad', 'probable'],
      parameters: ['temperatura', 'humedad', 'presi√≥n', 'lluvia', 'viento'],
      required: []
    },
    comparison: {
      keywords: ['comparar', 'comparaci√≥n', 'compara', 'diferencia', 'vs', 'versus', 'comparativo', 'entre', 'y', 'diferencia', 'distinto', 'igual'],
      parameters: ['temperatura', 'humedad', 'presi√≥n', 'lluvia', 'viento', 'gas'],
      required: ['periods']
    },
    max_min: {
      keywords: ['m√°ximo', 'maximo', 'm√≠nimo', 'minimo', 'pico', 'peak', 'mayor', 'menor', 'm√°s alto', 'm√°s bajo', 'm√°x', 'max', 'm√≠n', 'min'],
      parameters: ['temperatura', 'humedad', 'presi√≥n', 'lluvia', 'viento', 'gas'],
      required: ['period']
    },
    correlation: {
      keywords: ['relaci√≥n', 'correlaci√≥n', 'correlacion', 'conexi√≥n', 'conexion', 'asociaci√≥n', 'asociacion', 'afecta', 'influye', 'impacto', 'causa', 'provoca'],
      parameters: ['temperatura', 'humedad', 'presi√≥n', 'lluvia', 'viento', 'gas'],
      required: ['parameters']
    },
    greeting: {
      keywords: ['hola', 'buenos d√≠as', 'buenos dias', 'buenas tardes', 'hey', 'saludos', 'buen d√≠a', 'buen dia', 'buenas noches', 'que tal', 'como estas', 'c√≥mo est√°s'],
      parameters: [],
      required: []
    },
    goodbye: {
      keywords: ['adi√≥s', 'adios', 'gracias', 'chao', 'hasta luego', 'hasta pronto', 'nos vemos', 'bye', 'grac√≠as', 'gracias', 'fue √∫til', 'fue util'],
      parameters: [],
      required: []
    },
    help: {
      keywords: ['ayuda', 'funciona', 'c√≥mo', 'como', 'puedo', 'capaz', 'hacer', 'qu√©', 'que', 'preguntar', 'instrucciones', 'ejemplo', 'ejemplos', 'gu√≠a', 'manual', 'tutorial'],
      parameters: [],
      required: []
    },
    about_horus: {
      keywords: ['horus', 'sistema horus', 'estaci√≥n horus', 'estacion horus', 'estaci√≥n meteorol√≥gica', 'estacion meteorologica', 'sistema meteorol√≥gico', 'sistema meteorologico', 'para qu√© sirve', 'para que sirve', 'qu√© hace', 'que hace'],
      parameters: [],
      required: []
    },
    support: {
      keywords: ['problema', 'error', 'no funciona', 'fallo', 'bug', 'no carga', 'lento', 'lentitud', 'lenta', 'lento', 'no responde', 'no me deja', 'no puedo'],
      parameters: [],
      required: []
    },
    personal: {
      keywords: ['qui√©n eres', 'quien eres', 'qui√©n eres t√∫', 'quien eres tu', 'qui√©n te hizo', 'quien te hizo', 'qui√©n te cre√≥', 'quien te creo', 'tu creador', 'tu creador es'],
      parameters: [],
      required: []
    },
    general: {
      keywords: ['cu√°l es tu nombre', 'cual es tu nombre', 'c√≥mo te llamas', 'como te llamas', 'qu√© edad tienes', 'que edad tienes', 'd√≥nde vives', 'donde vives', 'qu√© hora es', 'que hora es'],
      parameters: [],
      required: []
    },
    out_of_scope: {
      keywords: [],
      parameters: [],
      required: []
    }
  };

  // Mapeo de periodos
  const periodMap = {
    'hoy': { type: 'day', value: 1, unit: 'day' },
    'ayer': { type: 'day', value: 1, unit: 'day', offset: 1 },
    '√∫ltimas 24 horas': { type: 'hour', value: 24, unit: 'hour' },
    '√∫ltimas 12 horas': { type: 'hour', value: 12, unit: 'hour' },
    'esta ma√±ana': { type: 'morning', value: 1, unit: 'day' },
    'esta tarde': { type: 'afternoon', value: 1, unit: 'day' },
    'esta noche': { type: 'night', value: 1, unit: 'day' },
    'esta semana': { type: 'week', value: 1, unit: 'week' },
    'esta semana pasada': { type: 'week', value: 1, unit: 'week', offset: 1 },
    '√∫ltimos 7 d√≠as': { type: 'day', value: 7, unit: 'day' },
    '√∫ltimos 14 d√≠as': { type: 'day', value: 14, unit: 'day' },
    '√∫ltimos 30 d√≠as': { type: 'day', value: 30, unit: 'day' },
    'este mes': { type: 'month', value: 1, unit: 'month' },
    'este a√±o': { type: 'year', value: 1, unit: 'year' },
    '√∫ltimo mes': { type: 'month', value: 1, unit: 'month', offset: 1 },
    '√∫ltimo a√±o': { type: 'year', value: 1, unit: 'year', offset: 1 },
    '√∫ltima hora': { type: 'hour', value: 1, unit: 'hour' },
    '√∫ltimas 2 horas': { type: 'hour', value: 2, unit: 'hour' },
    '√∫ltimas 6 horas': { type: 'hour', value: 6, unit: 'hour' },
    'esta semana': { type: 'week', value: 1, unit: 'week' },
    'esta semana anterior': { type: 'week', value: 1, unit: 'week', offset: 1 },
    'este mes': { type: 'month', value: 1, unit: 'month' },
    'este mes pasado': { type: 'month', value: 1, unit: 'month', offset: 1 },
    'este a√±o': { type: 'year', value: 1, unit: 'year' },
    'este a√±o pasado': { type: 'year', value: 1, unit: 'year', offset: 1 }
  };

  // Diccionario para correcci√≥n ortogr√°fica
  const spellingDictionary = {
    'tempertura': 'temperatura',
    'temperaruta': 'temperatura',
    'humedad': 'humedad',
    'humead': 'humedad',
    'umedad': 'humedad',
    'presion': 'presi√≥n',
    'presion': 'presi√≥n',
    'presion atmosferica': 'presi√≥n atmosf√©rica',
    'presion atmosferica': 'presi√≥n atmosf√©rica',
    'presion barometrica': 'presi√≥n barom√©trica',
    'presion barometrica': 'presi√≥n barom√©trica',
    'lluvia': 'lluvia',
    'llubia': 'lluvia',
    'lubia': 'lluvia',
    'viento': 'viento',
    'biento': 'viento',
    'bientto': 'viento',
    'gas': 'gas',
    'calidad del aire': 'calidad del aire',
    'calidad aire': 'calidad del aire',
    'direccion': 'direcci√≥n',
    'direccion del viento': 'direcci√≥n del viento',
    'direccion viento': 'direcci√≥n del viento',
    'termometro': 'term√≥metro',
    'termometro': 'term√≥metro',
    'pluviometria': 'pluviometr√≠a',
    'pluviometria': 'pluviometr√≠a',
    'co2': 'CO2',
    'di√≥xido de carbono': 'di√≥xido de carbono'
  };

  // Sistema de an√°lisis sem√°ntico mejorado
  const semanticAnalysis = {
    // Analiza el dominio de la pregunta
    analyzeDomain: (text) => {
      const weatherKeywords = [
        'temperatura', 'calor', 'fr√≠o', 'frio', 'grados', 
        'humedad', 'agua', 'presi√≥n', 'atmosf√©rica', 'barom√©trica',
        'lluvia', 'precipitaci√≥n', 'viento', 'r√°fagas', 'gas',
        'calidad del aire', 'direcci√≥n', 'clima', 'meteorol√≥gico',
        'meteorologico', 'tiempo', 'nublado', 'soleado', 'nubes',
        'nuboso', 'llovizna', 'tormenta', 'nublados', 'soleados',
        'nubosos', 'tormentas', 'lluvias', 'vientos', 'r√°fagas',
        'caluroso', 'frio', 'fr√≠o', 'caliente', 'templado',
        'h√∫medo', 'seco', 'h√∫medos', 'secos', 'presi√≥n',
        'bar√≥metro', 'pluvi√≥metro', 'anem√≥metro', 'term√≥metro',
        'meteorolog√≠a', 'clim√°tico', 'clim√°ticos', 'clim√°ticas',
        'climatolog√≠a', 'pron√≥stico', 'pronostico', 'predicci√≥n',
        'prediccion', 'previsi√≥n', 'prevision', 'estacional',
        'estaciones', 'primavera', 'verano', 'oto√±o', 'invierno',
        'norte', 'sur', 'este', 'oeste', 'cardinales', 'brisa',
        'cicl√≥n', 'hurac√°n', 'tornado', 'tornados', 'ciclones',
        'huracanes', 'tormenta', 'tormentas', 'lluvia', 'lluvias',
        'nublado', 'nublados', 'nuboso', 'nubosos', 'soleado',
        'soleados', 'despejado', 'despejados', 'nublaci√≥n',
        'nublaciones', 'precipitaci√≥n', 'precipitaciones', 'humedad',
        'relativa', 'relativas', 'humedad relativa', 'presi√≥n',
        'atmosf√©rica', 'atmosf√©ricas', 'presi√≥n atmosf√©rica',
        'barom√©trica', 'barom√©tricas', 'presi√≥n barom√©trica',
        'viento', 'vientos', 'r√°faga', 'r√°fagas', 'direcci√≥n',
        'direcciones', 'direcci√≥n del viento', 'velocidad',
        'velocidades', 'velocidad del viento', 'anem√≥metro',
        'term√≥metro', 'pluvi√≥metro', 'bar√≥metro', 'higr√≥metro',
        'gas', 'gases', 'calidad del aire', 'contaminaci√≥n',
        'contaminacion', 'pm2.5', 'pm10', 'part√≠culas', 'particulas',
        'co2', 'di√≥xido de carbono', 'ozono', 'no2', 'so2'
      ];
      
      let matchCount = 0;
      let totalKeywords = 0;
      const normalizedText = text.toLowerCase();
      
      weatherKeywords.forEach(keyword => {
        if (normalizedText.includes(keyword)) {
          matchCount++;
        }
        totalKeywords++;
      });
      
      // Calcular confianza basada en la proporci√≥n de coincidencias
      const confidence = Math.min(1.0, matchCount / Math.max(1, totalKeywords * 0.15));
      
      // Si encontramos al menos 1 palabra clave meteorol√≥gica, es una pregunta sobre clima
      return {
        isWeatherQuestion: matchCount > 0,
        confidence: confidence,
        matchCount: matchCount,
        totalKeywords: totalKeywords
      };
    },
    
    // Identifica entidades en el texto
    identifyEntities: (text) => {
      const entities = {
        parameters: [],
        periods: [],
        locations: [],
        numbers: [],
        comparisons: [],
        operations: [],
        general: []
      };
      
      const normalizedText = text.toLowerCase();
      
      // Identificar par√°metros meteorol√≥gicos
      Object.keys(weatherSynonyms).forEach(param => {
        // Verificar el par√°metro principal
        if (normalizedText.includes(param)) {
          entities.parameters.push(param);
        }
        
        // Verificar sin√≥nimos
        weatherSynonyms[param].forEach(synonym => {
          if (normalizedText.includes(synonym)) {
            entities.parameters.push(param);
          }
        });
      });
      
      // Identificar periodos
      Object.keys(periodMap).forEach(period => {
        if (normalizedText.includes(period)) {
          entities.periods.push(period);
        }
      });
      
      // Identificar n√∫meros
      const numberMatches = text.match(/\d+/g);
      if (numberMatches) {
        entities.numbers = numberMatches.map(num => parseInt(num));
      }
      
      // Identificar comparaciones
      if (normalizedText.includes('vs') || normalizedText.includes('versus')) {
        entities.comparisons.push('vs');
      }
      if (normalizedText.includes('tendencia') || normalizedText.includes('evoluci√≥n')) {
        entities.comparisons.push('trend');
      }
      if (normalizedText.includes('correlaci√≥n') || normalizedText.includes('relaci√≥n')) {
        entities.comparisons.push('correlation');
      }
      
      // Identificar operaciones
      if (normalizedText.includes('m√°ximo') || normalizedText.includes('maximo')) {
        entities.operations.push('max');
      }
      if (normalizedText.includes('m√≠nimo') || normalizedText.includes('minimo')) {
        entities.operations.push('min');
      }
      if (normalizedText.includes('promedio') || normalizedText.includes('media')) {
        entities.operations.push('average');
      }
      if (normalizedText.includes('diferencia')) {
        entities.operations.push('difference');
      }
      
      // Identificar t√©rminos generales
      Object.keys(generalTerms).forEach(term => {
        if (term === 'outOfScope') return;
        
        // Verificar el t√©rmino principal
        if (normalizedText.includes(term)) {
          entities.general.push(term);
        }
        
        // Verificar sin√≥nimos
        if (Array.isArray(generalTerms[term])) {
          generalTerms[term].forEach(synonym => {
            if (normalizedText.includes(synonym)) {
              entities.general.push(term);
            }
          });
        }
      });
      
      // Identificar preguntas fuera del √°mbito
      Object.keys(generalTerms.outOfScope).forEach(domain => {
        generalTerms.outOfScope[domain].forEach(keyword => {
          if (normalizedText.includes(keyword)) {
            entities.general.push(`outOfScope_${domain}`);
          }
        });
      });
      
      // Eliminar duplicados
      entities.parameters = [...new Set(entities.parameters)];
      entities.periods = [...new Set(entities.periods)];
      entities.comparisons = [...new Set(entities.comparisons)];
      entities.operations = [...new Set(entities.operations)];
      entities.general = [...new Set(entities.general)];
      
      return entities;
    },
    
    // Analiza la intenci√≥n del usuario
    analyzeIntent: (text, entities, domainAnalysis) => {
      let bestIntent = null;
      let highestConfidence = 0;
      
      // Analizar cada posible intenci√≥n
      Object.keys(intentMap).forEach(intentType => {
        const intent = intentMap[intentType];
        let confidence = 0;
        
        // Calcular coincidencia con palabras clave
        intent.keywords.forEach(keyword => {
          if (text.toLowerCase().includes(keyword)) {
            confidence += 0.2;
          }
        });
        
        // Aumentar confianza si se encontraron par√°metros relevantes
        if (entities.parameters.length > 0 && intent.parameters.length > 0) {
          const commonParams = entities.parameters.filter(p => intent.parameters.includes(p));
          confidence += commonParams.length * 0.15;
        }
        
        // Aumentar confianza si se encontraron periodos y la intenci√≥n los requiere
        if (intent.required.includes('period') && entities.periods.length > 0) {
          confidence += 0.2;
        }
        
        // Aumentar confianza si se encontraron m√∫ltiples periodos y la intenci√≥n los requiere
        if (intent.required.includes('periods') && entities.periods.length > 1) {
          confidence += 0.25;
        }
        
        // Ajustar confianza seg√∫n el dominio
        if (intentType !== 'greeting' && intentType !== 'goodbye' && intentType !== 'help') {
          confidence *= domainAnalysis.confidence;
        }
        
        // Verificar si es la mejor intenci√≥n hasta ahora
        if (confidence > highestConfidence) {
          highestConfidence = confidence;
          bestIntent = {
            type: intentType,
            confidence: confidence,
            parameters: entities.parameters,
            periods: entities.periods
          };
        }
      });
      
      // Si no se encontr√≥ una intenci√≥n clara, verificar saludos, despedidas o ayuda
      if (!bestIntent || highestConfidence < 0.4) {
        if (this.isGreeting(text)) {
          return { type: 'greeting', confidence: 0.9, parameters: [], periods: [] };
        }
        if (this.isGoodbye(text)) {
          return { type: 'goodbye', confidence: 0.9, parameters: [], periods: [] };
        }
        if (this.isHelpRequest(text)) {
          return { type: 'help', confidence: 0.8, parameters: [], periods: [] };
        }
      }
      
      // Si no se encontr√≥ una intenci√≥n clara pero hay t√©rminos generales
      if (!bestIntent && entities.general.length > 0) {
        for (const generalTerm of entities.general) {
          if (generalTerm.startsWith('outOfScope_')) {
            const domain = generalTerm.replace('outOfScope_', '');
            return {
              type: 'out_of_scope',
              confidence: 0.5,
              domain: domain,
              parameters: [],
              periods: []
            };
          }
          
          // Mapear t√©rminos generales a intenciones
          const intentMap = {
            'about_horus': 'about_horus',
            'support': 'support',
            'personal': 'personal',
            'general': 'general'
          };
          
          if (intentMap[generalTerm]) {
            return {
              type: intentMap[generalTerm],
              confidence: 0.6,
              parameters: [],
              periods: []
            };
          }
        }
      }
      
      // Si no se encontr√≥ una intenci√≥n clara, pero es meteorol√≥gico
      if (domainAnalysis.isWeatherQuestion && !bestIntent) {
        if (entities.parameters.length > 0) {
          return {
            type: 'current_data',
            confidence: 0.5,
            parameters: entities.parameters,
            periods: ['hoy']
          };
        }
        
        return {
          type: 'current_data',
          confidence: 0.4,
          parameters: ['temperatura'],
          periods: ['hoy']
        };
      }
      
      // Si no se encontr√≥ una intenci√≥n clara y no es meteorol√≥gico
      if (!domainAnalysis.isWeatherQuestion && !bestIntent) {
        return {
          type: 'out_of_scope',
          confidence: 0.3,
          domain: 'general',
          parameters: [],
          periods: []
        };
      }
      
      return bestIntent || { type: 'unrelated', confidence: 0, parameters: [], periods: [] };
    },
    
    // Verifica si es un saludo
    isGreeting: (text) => {
      const greetings = intentMap.greeting.keywords;
      const normalizedText = text.toLowerCase();
      
      return greetings.some(greeting => normalizedText.includes(greeting));
    },
    
    // Verifica si es una despedida
    isGoodbye: (text) => {
      const goodbyes = intentMap.goodbye.keywords;
      const normalizedText = text.toLowerCase();
      
      return goodbyes.some(goodbye => normalizedText.includes(goodbye));
    },
    
    // Verifica si es una solicitud de ayuda
    isHelpRequest: (text) => {
      const helpKeywords = intentMap.help.keywords;
      const normalizedText = text.toLowerCase();
      
      return helpKeywords.some(keyword => normalizedText.includes(keyword));
    },
    
    // Analiza preguntas compuestas
    analyzeCompoundQuestions: (text) => {
      const compoundIndicators = ['y', 'adem√°s', 'tambi√©n', 'tambien', 'ademas', 'adem√°s de', 'ademas de', 'adem√°s que', 'ademas que'];
      return compoundIndicators.some(indicator => text.toLowerCase().includes(indicator));
    },
    
    // Analiza referencias en el contexto
    analyzeReferences: (text, context) => {
      const references = {
        parameters: [],
        temporal: [],
        spatial: []
      };
      
      // Analizar an√°foras (referencias a elementos previos)
      if (context.lastParameter && (text.includes('eso') || text.includes('eso es') || text.includes('eso est√°'))) {
        references.parameters.push(context.lastParameter);
      }
      
      if (context.lastPeriod && (text.includes('entonces') || text.includes('en ese periodo') || text.includes('durante ese tiempo'))) {
        references.temporal.push(context.lastPeriod);
      }
      
      return references;
    },
    
    // Resuelve an√°foras usando el contexto
    resolveAnaphora: (text, context) => {
      let resolvedText = text;
      const paramName = context.lastParameter || 'temperatura';
      
      // Reemplazar "eso" si hay contexto de par√°metro
      if (context.lastParameter) {
        resolvedText = resolvedText.replace(/eso/g, paramName);
        resolvedText = resolvedText.replace(/eso es/g, `${paramName} es`);
        resolvedText = resolvedText.replace(/eso est√°/g, `${paramName} est√°`);
      }
      
      // Reemplazar "hoy" si hay contexto temporal
      if (context.temporalContext && (text.includes('ayer') || text.includes('ma√±ana'))) {
        // Si el contexto es "hoy", y pregunta sobre "ayer", ajustamos
        if (context.temporalContext === 'today' && text.includes('ayer')) {
          resolvedText = resolvedText.replace(/ayer/g, 'hace un d√≠a');
        }
      }
      
      // Mejora: Reemplazar "la" + sustantivo por el par√°metro espec√≠fico
      if (context.lastParameter) {
        const paramReplacements = {
          'temp': ['la temperatura', 'el term√≥metro', 'los grados', 'el calor', 'el fr√≠o'],
          'humedad': ['la humedad', 'el vapor', 'el agua'],
          'presi√≥n': ['la presi√≥n', 'la atmosf√©rica', 'la barom√©trica'],
          'lluvia': ['la lluvia', 'la precipitaci√≥n', 'el agua'],
          'viento': ['el viento', 'las r√°fagas', 'la brisa'],
          'gas': ['el gas', 'la calidad del aire', 'las part√≠culas']
        };
        
        if (paramReplacements[paramName]) {
          paramReplacements[paramName].forEach(replacement => {
            resolvedText = resolvedText.replace(new RegExp(replacement, 'gi'), paramName);
          });
        }
      }
      
      return resolvedText;
    },
    
    // Analiza preguntas hipot√©ticas
    analyzeHypotheticals: (text) => {
      const hypotheticalIndicators = ['si', 'supongamos que', 'imagina que', 'qu√© pasar√≠a si', 'que pasaria si', 'que pasar√≠a si'];
      return hypotheticalIndicators.some(indicator => text.toLowerCase().includes(indicator));
    }
  };

  // Sistema de correcci√≥n ortogr√°fica CORREGIDO
  const spellingCorrection = {
    // Calcula la distancia de Levenshtein entre dos strings
    levenshteinDistance: function(a, b) {
      if (a.length === 0) return b.length;
      if (b.length === 0) return a.length;
      
      const matrix = [];
      
      for (let i = 0; i <= b.length; i++) {
        matrix[i] = [i];
      }
      
      for (let j = 0; j <= a.length; j++) {
        matrix[0][j] = j;
      }
      
      for (let i = 1; i <= b.length; i++) {
        for (let j = 1; j <= a.length; j++) {
          if (b.charAt(i - 1) === a.charAt(j - 1)) {
            matrix[i][j] = matrix[i - 1][j - 1];
          } else {
            matrix[i][j] = Math.min(
              matrix[i - 1][j - 1] + 1, // Sustituci√≥n
              matrix[i][j - 1] + 1, // Inserci√≥n
              matrix[i - 1][j] + 1 // Eliminaci√≥n
            );
          }
        }
      }
      
      return matrix[b.length][a.length];
    },
    
    // Corrige la ortograf√≠a de una palabra
    correctWord: function(word) {
      // Si la palabra est√° en el diccionario, devolver la correcci√≥n
      if (spellingDictionary[word.toLowerCase()]) {
        return spellingDictionary[word.toLowerCase()];
      }
      
      // Buscar en el diccionario de sin√≥nimos
      for (const [correct, synonyms] of Object.entries(weatherSynonyms)) {
        for (const synonym of synonyms) {
          if (word.toLowerCase() === synonym) {
            return correct;
          }
          
          // Calcular distancia de Levenshtein para correcci√≥n aproximada
          const distance = this.levenshteinDistance(word.toLowerCase(), synonym);
          if (distance <= Math.max(1, Math.floor(synonym.length * 0.2))) {
            return correct;
          }
        }
      }
      
      return word;
    },
    
    // Corrige todo el mensaje
    correctMessage: function(message) {
      const words = message.split(/\s+/);
      let correctedWords = [];
      let foundCorrection = false;
      
      words.forEach(word => {
        // Mantener signos de puntuaci√≥n
        const cleanWord = word.replace(/[.,!?;:]/g, '');
        const punctuation = word.match(/[.,!?;:]+$/);
        
        if (cleanWord.length > 2) {
          // CORRECCI√ìN: Usar spellingCorrection.correctWord en lugar de this.correctWord
          const corrected = spellingCorrection.correctWord(cleanWord);
          if (corrected !== cleanWord) {
            correctedWords.push(corrected + (punctuation ? punctuation[0] : ''));
            foundCorrection = true;
          } else {
            correctedWords.push(word);
          }
        } else {
          correctedWords.push(word);
        }
      });
      
      return {
        correctedMessage: correctedWords.join(' '),
        hasCorrection: foundCorrection
      };
    }
  };

  // Cargar datos hist√≥ricos (simulaci√≥n)
  const loadHistoricalData = async () => {
    return new Promise((resolve) => {
      // Simulaci√≥n de carga de datos
      setTimeout(() => {
        // Generar datos simulados para los √∫ltimos 30 d√≠as
        const now = new Date();
        historicalData = [];
        
        for (let i = 29; i >= 0; i--) {
          const date = new Date(now);
          date.setDate(now.getDate() - i);
          
          historicalData.push({
            timestamp: date.toISOString(),
            temp: 20 + Math.random() * 10 - 5 * (i/30),
            hum: 60 + Math.random() * 20 - 10 * (i/30),
            pres: 1013 + Math.random() * 5 - 2 * (i/30),
            lluvia: i < 5 ? 1 : 0,
            wind: 5 + Math.random() * 10,
            wind_dir: Math.floor(Math.random() * 360),
            gas: 1.0 + Math.random() * 0.5
          });
        }
        
        resolve();
      }, 800);
    });
  };

  // Manejadores de intenciones
  const intentHandlers = {
    current_data: (entities, context) => {
      // Si no hay par√°metros espec√≠ficos, usar el √∫ltimo par√°metro mencionado o uno por defecto
      let parameters = entities.parameters.length > 0 ? entities.parameters : 
                      (context.lastParameter ? [context.lastParameter] : ['temperatura']);
      
      // Actualizar contexto
      conversationContext.lastParameter = parameters[0];
      conversationContext.lastQuestionType = 'current_data';
      
      // Obtener el dato actual
      const latestData = historicalData[historicalData.length - 1];
      let response = '';
      
      parameters.forEach(param => {
        switch(param) {
          case 'temperatura':
            response += `La temperatura actual es de ${latestData.temp.toFixed(1)}¬∞C.\n`;
            break;
          case 'humedad':
            response += `La humedad actual es del ${latestData.hum.toFixed(0)}%.\n`;
            break;
          case 'presi√≥n':
            response += `La presi√≥n atmosf√©rica actual es de ${latestData.pres.toFixed(0)} hPa.\n`;
            break;
          case 'lluvia':
            response += `Actualmente ${latestData.lluvia ? 'est√° lloviendo' : 'no est√° lloviendo'}.\n`;
            break;
          case 'viento':
            response += `La velocidad del viento actual es de ${latestData.wind.toFixed(1)} m/s (${(latestData.wind * 3.6).toFixed(1)} km/h).\n`;
            break;
          case 'gas':
            response += `El nivel de gas actual es de ${latestData.gas.toFixed(2)} kŒ©.\n`;
            break;
          case 'direcci√≥n':
            const directions = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'];
            const index = Math.round((latestData.wind_dir % 360) / 22.5) % 16;
            response += `La direcci√≥n del viento actual es ${directions[index]} (${latestData.wind_dir}¬∞).\n`;
            break;
        }
      });
      
      // A√±adir an√°lisis contextual si es relevante
      if (parameters.length === 1) {
        const paramName = parameters[0];
        let contextAnalysis = '';
        
        switch(paramName) {
          case 'temperatura':
            if (latestData.temp > 25) {
              contextAnalysis = `Con esta temperatura, podr√≠as considerar usar ropa ligera y mantenerse hidratado.`;
            } else if (latestData.temp < 10) {
              contextAnalysis = `Con esta temperatura, te recomendamos abrigarte adecuadamente para evitar el fr√≠o.`;
            }
            break;
          case 'humedad':
            if (latestData.hum > 70) {
              contextAnalysis = `La alta humedad puede hacer que la temperatura se sienta m√°s alta de lo que realmente es.`;
            } else if (latestData.hum < 30) {
              contextAnalysis = `La baja humedad puede causar sequedad en la piel y las v√≠as respiratorias.`;
            }
            break;
          case 'presi√≥n':
            if (latestData.pres < 1000) {
              contextAnalysis = `La presi√≥n atmosf√©rica baja suele indicar condiciones clim√°ticas inestables.`;
            } else if (latestData.pres > 1020) {
              contextAnalysis = `La presi√≥n atmosf√©rica alta suele indicar condiciones clim√°ticas estables y buen tiempo.`;
            }
            break;
        }
        
        if (contextAnalysis) {
          response += `\n${contextAnalysis}`;
        }
        
        response += `\n\n¬øTe gustar√≠a ver un an√°lisis hist√≥rico de ${paramName} o una predicci√≥n para los pr√≥ximos d√≠as?`;
      }
      
      return response.trim();
    },
    
    historical_trend: (entities, context) => {
      // Determinar el periodo
      let period = entities.periods.length > 0 ? entities.periods[0] : 
                  (context.lastPeriod ? context.lastPeriod : '√∫ltimos 7 d√≠as');
      
      // Actualizar contexto
      conversationContext.lastPeriod = period;
      conversationContext.lastQuestionType = 'historical_trend';
      
      // Obtener datos para el periodo
      const periodInfo = periodMap[period] || periodMap['√∫ltimos 7 d√≠as'];
      const now = new Date();
      let startDate;
      
      if (periodInfo.type === 'day') {
        startDate = new Date(now);
        startDate.setDate(now.getDate() - periodInfo.value);
      } else if (periodInfo.type === 'week') {
        startDate = new Date(now);
        startDate.setDate(now.getDate() - (periodInfo.value * 7));
      } else if (periodInfo.type === 'month') {
        startDate = new Date(now);
        startDate.setMonth(now.getMonth() - periodInfo.value);
      }
      
      // Si no hay par√°metros espec√≠ficos, usar el √∫ltimo par√°metro mencionado o uno por defecto
      let parameters = entities.parameters.length > 0 ? entities.parameters : 
                      (context.lastParameter ? [context.lastParameter] : ['temperatura']);
      
      // Preparar datos para el gr√°fico
      const chartData = historicalData
        .filter(data => new Date(data.timestamp) >= startDate)
        .map(data => ({
          x: new Date(data.timestamp),
          y: data[parameters[0] === 'presi√≥n' ? 'pres' : 
                 parameters[0] === 'lluvia' ? 'lluvia' : 
                 parameters[0]]
        }));
      
      // Generar la respuesta basada en el an√°lisis de los datos
      const response = analyzeData(parameters[0], chartData, periodInfo);
      
      // A√±ade un gr√°fico de an√°lisis
      const chartId = `prediction-chart-${Date.now()}`;
      const chartResponse = `
        <div class="prediction-chart-container">
          <div class="chart-title">Tendencia de ${parameters[0]} en ${period}</div>
          <canvas class="prediction-chart" id="${chartId}" 
                  data-parameter="${parameters[0]}" 
                  data-chart-data='${JSON.stringify(chartData)}'></canvas>
        </div>
      `;
      
      return response + chartResponse;
    },
    
    prediction: (entities, context) => {
      // Si no hay par√°metros espec√≠ficos, usar el √∫ltimo par√°metro mencionado o uno por defecto
      let parameters = entities.parameters.length > 0 ? entities.parameters : 
                      (context.lastParameter ? [context.lastParameter] : ['temperatura']);
      
      // Actualizar contexto
      conversationContext.lastParameter = parameters[0];
      conversationContext.lastQuestionType = 'prediction';
      
      // Generar datos de predicci√≥n simulados
      const predictionData = [];
      const now = new Date();
      const latestData = historicalData[historicalData.length - 1];
      
      for (let i = 0; i < 5; i++) {
        const date = new Date(now);
        date.setDate(now.getDate() + i);
        
        let value;
        switch(parameters[0]) {
          case 'temperatura':
            value = latestData.temp + (Math.random() - 0.5) * 3;
            break;
          case 'humedad':
            value = latestData.hum + (Math.random() - 0.5) * 10;
            break;
          case 'presi√≥n':
            value = latestData.pres + (Math.random() - 0.5) * 3;
            break;
          case 'viento':
            value = latestData.wind + (Math.random() - 0.5) * 2;
            break;
          default:
            value = latestData.temp + (Math.random() - 0.5) * 3;
        }
        
        predictionData.push({
          x: date,
          y: value
        });
      }
      
      // Generar respuesta
      let response = '';
      const nextDay = new Date(now);
      nextDay.setDate(now.getDate() + 1);
      
      switch(parameters[0]) {
        case 'temperatura':
          response = `Para ma√±ana ${nextDay.toLocaleDateString('es-ES', { weekday: 'long' })}, la temperatura se espera que est√© entre ${(latestData.temp - 1).toFixed(1)}¬∞C y ${(latestData.temp + 2).toFixed(1)}¬∞C.\n\n`;
          response += `La tendencia a corto plazo sugiere ${latestData.temp < predictionData[1].y ? 'un aumento' : 'una disminuci√≥n'} en la temperatura.\n\n`;
          break;
        case 'humedad':
          response = `Para ma√±ana ${nextDay.toLocaleDateString('es-ES', { weekday: 'long' })}, la humedad se espera que est√© alrededor del ${(latestData.hum + (Math.random() * 5 - 2.5)).toFixed(0)}%.\n\n`;
          response += `La tendencia a corto plazo sugiere ${latestData.hum < predictionData[1].y ? 'un aumento' : 'una disminuci√≥n'} en la humedad.\n\n`;
          break;
        case 'presi√≥n':
          response = `Para ma√±ana ${nextDay.toLocaleDateString('es-ES', { weekday: 'long' })}, la presi√≥n atmosf√©rica se espera que est√© alrededor de ${(latestData.pres + (Math.random() * 3 - 1.5)).toFixed(0)} hPa.\n\n`;
          response += `La tendencia a corto plazo sugiere ${latestData.pres < predictionData[1].y ? 'un aumento' : 'una disminuci√≥n'} en la presi√≥n.\n\n`;
          break;
        case 'viento':
          response = `Para ma√±ana ${nextDay.toLocaleDateString('es-ES', { weekday: 'long' })}, la velocidad del viento se espera que est√© alrededor de ${(latestData.wind + (Math.random() * 2 - 1)).toFixed(1)} m/s.\n\n`;
          response += `La tendencia a corto plazo sugiere ${latestData.wind < predictionData[1].y ? 'un aumento' : 'una disminuci√≥n'} en la velocidad del viento.\n\n`;
          break;
        default:
          response = `Para ma√±ana ${nextDay.toLocaleDateString('es-ES', { weekday: 'long' })}, se espera que ${parameters[0]} muestre una tendencia ${latestData.temp < predictionData[1].y ? 'ascendente' : 'descendente'}.\n\n`;
      }
      
      response += `Esta predicci√≥n se basa en el an√°lisis de los datos hist√≥ricos de los √∫ltimos 30 d√≠as y tiene una confiabilidad estimada del 75%.`;
      
      // A√±ade un gr√°fico de predicci√≥n
      const chartId = `prediction-chart-${Date.now()}`;
      const reliability = 75;
      
      const chartResponse = `
        <div class="prediction-container">
          <div class="prediction-reliability">
            Confiabilidad de la predicci√≥n: ${reliability}% 
            <div class="reliability-bar">
              <div class="reliability-fill" style="width: ${reliability}%"></div>
            </div>
          </div>
          <div class="prediction-chart-container">
            <div class="chart-title">Predicci√≥n de ${parameters[0]} para los pr√≥ximos 5 d√≠as</div>
            <canvas class="prediction-chart" id="${chartId}" 
                    data-parameter="${parameters[0]}" 
                    data-chart-data='${JSON.stringify(predictionData)}'></canvas>
          </div>
        </div>
      `;
      
      return response + chartResponse;
    },
    
    comparison: (entities, context) => {
      // Necesitamos al menos dos periodos para comparar
      if (entities.periods.length < 2) {
        return "Para hacer una comparaci√≥n necesito dos periodos. Por ejemplo: 'Compara la temperatura de esta semana con la semana pasada'.";
      }
      
      const period1 = entities.periods[0];
      const period2 = entities.periods[1];
      
      // Actualizar contexto
      conversationContext.lastPeriod = period1;
      conversationContext.lastQuestionType = 'comparison';
      
      // Si no hay par√°metros espec√≠ficos, usar el √∫ltimo par√°metro mencionado o uno por defecto
      let parameters = entities.parameters.length > 0 ? entities.parameters : 
                      (context.lastParameter ? [context.lastParameter] : ['temperatura']);
      
      // Obtener datos para ambos periodos
      const periodInfo1 = periodMap[period1] || periodMap['esta semana'];
      const periodInfo2 = periodMap[period2] || periodMap['√∫ltimos 7 d√≠as'];
      
      const now = new Date();
      let startDate1, startDate2;
      
      // Calcular fechas de inicio para ambos periodos
      if (periodInfo1.type === 'day') {
        startDate1 = new Date(now);
        startDate1.setDate(now.getDate() - periodInfo1.value);
      } else if (periodInfo1.type === 'week') {
        startDate1 = new Date(now);
        startDate1.setDate(now.getDate() - (periodInfo1.value * 7));
      } else if (periodInfo1.type === 'month') {
        startDate1 = new Date(now);
        startDate1.setMonth(now.getMonth() - periodInfo1.value);
      }
      
      if (periodInfo2.type === 'day') {
        startDate2 = new Date(now);
        startDate2.setDate(now.getDate() - periodInfo2.value);
      } else if (periodInfo2.type === 'week') {
        startDate2 = new Date(now);
        startDate2.setDate(now.getDate() - (periodInfo2.value * 7));
      } else if (periodInfo2.type === 'month') {
        startDate2 = new Date(now);
        startDate2.setMonth(now.getMonth() - periodInfo2.value);
      }
      
      // Obtener datos para ambos periodos
      const data1 = historicalData.filter(data => new Date(data.timestamp) >= startDate1);
      const data2 = historicalData.filter(data => new Date(data.timestamp) >= startDate2);
      
      // Calcular promedios
      const avg1 = data1.reduce((sum, item) => sum + item[parameters[0] === 'presi√≥n' ? 'pres' : 
                                     parameters[0] === 'lluvia' ? 'lluvia' : 
                                     parameters[0]], 0) / data1.length;
      const avg2 = data2.reduce((sum, item) => sum + item[parameters[0] === 'presi√≥n' ? 'pres' : 
                                     parameters[0] === 'lluvia' ? 'lluvia' : 
                                     parameters[0]], 0) / data2.length;
      
      // Generar respuesta
      let response = `Comparaci√≥n de ${parameters[0]} entre ${period1} y ${period2}:\n\n`;
      
      response += `* ${period1.charAt(0).toUpperCase() + period1.slice(1)}: ${avg1.toFixed(2)}`;
      if (parameters[0] !== 'lluvia' && parameters[0] !== 'direcci√≥n') {
        response += ` ${parameters[0] === 'presi√≥n' ? 'hPa' : 
                    parameters[0] === 'humedad' ? '%' : 
                    '¬∞C'}`;
      }
      response += `\n`;
      
      response += `* ${period2.charAt(0).toUpperCase() + period2.slice(1)}: ${avg2.toFixed(2)}`;
      if (parameters[0] !== 'lluvia' && parameters[0] !== 'direcci√≥n') {
        response += ` ${parameters[0] === 'presi√≥n' ? 'hPa' : 
                    parameters[0] === 'humedad' ? '%' : 
                    '¬∞C'}`;
      }
      response += `\n\n`;
      
      const difference = avg1 - avg2;
      if (Math.abs(difference) > 0.01) {
        const percentChange = (Math.abs(difference) / avg2) * 100;
        if (difference > 0) {
          response += `La ${parameters[0]} fue ${percentChange.toFixed(1)}% mayor en ${period1} que en ${period2}.`;
        } else {
          response += `La ${parameters[0]} fue ${percentChange.toFixed(1)}% menor en ${period1} que en ${period2}.`;
        }
      } else {
        response += `La ${parameters[0]} fue muy similar en ambos periodos.`;
      }
      
      // Preparar datos para el gr√°fico comparativo
      const chartData1 = data1.map(data => ({
        x: new Date(data.timestamp),
        y: data[parameters[0] === 'presi√≥n' ? 'pres' : 
               parameters[0] === 'lluvia' ? 'lluvia' : 
               parameters[0]]
      }));
      
      const chartData2 = data2.map(data => ({
        x: new Date(data.timestamp),
        y: data[parameters[0] === 'presi√≥n' ? 'pres' : 
               parameters[0] === 'lluvia' ? 'lluvia' : 
               parameters[0]]
      }));
      
      // A√±ade un gr√°fico comparativo
      const chartId = `comparison-chart-${Date.now()}`;
      const chartResponse = `
        <div class="comparison-chart-container">
          <div class="chart-title">Comparaci√≥n de ${parameters[0]}: ${period1} vs ${period2}</div>
          <canvas class="comparison-chart" id="${chartId}" 
                  data-parameter="${parameters[0]}" 
                  data-chart-data1='${JSON.stringify(chartData1)}'
                  data-chart-data2='${JSON.stringify(chartData2)}'
                  data-period1="${period1}"
                  data-period2="${period2}"></canvas>
        </div>
      `;
      
      return response + chartResponse;
    },
    
    max_min: (entities, context) => {
      // Determinar el periodo
      let period = entities.periods.length > 0 ? entities.periods[0] : 
                  (context.lastPeriod ? context.lastPeriod : '√∫ltimos 7 d√≠as');
      
      // Actualizar contexto
      conversationContext.lastPeriod = period;
      conversationContext.lastQuestionType = 'max_min';
      
      // Obtener datos para el periodo
      const periodInfo = periodMap[period] || periodMap['√∫ltimos 7 d√≠as'];
      const now = new Date();
      let startDate;
      
      if (periodInfo.type === 'day') {
        startDate = new Date(now);
        startDate.setDate(now.getDate() - periodInfo.value);
      } else if (periodInfo.type === 'week') {
        startDate = new Date(now);
        startDate.setDate(now.getDate() - (periodInfo.value * 7));
      } else if (periodInfo.type === 'month') {
        startDate = new Date(now);
        startDate.setMonth(now.getMonth() - periodInfo.value);
      }
      
      // Si no hay par√°metros espec√≠ficos, usar el √∫ltimo par√°metro mencionado o uno por defecto
      let parameters = entities.parameters.length > 0 ? entities.parameters : 
                      (context.lastParameter ? [context.lastParameter] : ['temperatura']);
      
      // Obtener datos para el periodo
      const periodData = historicalData.filter(data => new Date(data.timestamp) >= startDate);
      
      // Encontrar m√°ximos y m√≠nimos
      let max = -Infinity;
      let min = Infinity;
      let maxDate, minDate;
      
      periodData.forEach(data => {
        const value = data[parameters[0] === 'presi√≥n' ? 'pres' : 
                         parameters[0] === 'lluvia' ? 'lluvia' : 
                         parameters[0]];
                         
        if (value > max) {
          max = value;
          maxDate = data.timestamp;
        }
        
        if (value < min) {
          min = value;
          minDate = data.timestamp;
        }
      });
      
      // Generar respuesta
      let response = `En ${period}, el valor m√°ximo de ${parameters[0]} fue de ${max.toFixed(2)}`;
      
      if (parameters[0] !== 'lluvia' && parameters[0] !== 'direcci√≥n') {
        response += ` ${parameters[0] === 'presi√≥n' ? 'hPa' : 
                    parameters[0] === 'humedad' ? '%' : 
                    '¬∞C'}`;
      }
      
      response += ` registrado el ${new Date(maxDate).toLocaleDateString('es-ES', { 
        weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' 
      })}.\n\n`;
      
      response += `El valor m√≠nimo fue de ${min.toFixed(2)}`;
      
      if (parameters[0] !== 'lluvia' && parameters[0] !== 'direcci√≥n') {
        response += ` ${parameters[0] === 'presi√≥n' ? 'hPa' : 
                    parameters[0] === 'humedad' ? '%' : 
                    '¬∞C'}`;
      }
      
      response += ` registrado el ${new Date(minDate).toLocaleDateString('es-ES', { 
        weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' 
      })}.`;
      
      // Preparar datos para el gr√°fico
      const chartData = historicalData
        .filter(data => new Date(data.timestamp) >= startDate)
        .map(data => ({
          x: new Date(data.timestamp),
          y: data[parameters[0] === 'presi√≥n' ? 'pres' : 
                 parameters[0] === 'lluvia' ? 'lluvia' : 
                 parameters[0]]
        }));
      
      // A√±ade un gr√°fico con marcadores de m√°ximos y m√≠nimos
      const chartId = `extremes-chart-${Date.now()}`;
      const chartResponse = `
        <div class="extremes-chart-container">
          <div class="chart-title">Valores extremos de ${parameters[0]} en ${period}</div>
          <canvas class="extremes-chart" id="${chartId}" 
                  data-parameter="${parameters[0]}" 
                  data-chart-data='${JSON.stringify(chartData)}'
                  data-max-date="${maxDate}"
                  data-min-date="${minDate}"></canvas>
        </div>
      `;
      
      return response + chartResponse;
    },
    
    correlation: (entities, context) => {
      try {
        // Necesitamos al menos dos par√°metros para analizar correlaci√≥n
        if (entities.parameters.length < 2) {
          return "Para analizar correlaci√≥n necesito dos par√°metros meteorol√≥gicos. Por ejemplo: '¬øC√≥mo se relaciona la temperatura con la humedad?'";
        }
        
        const parameter1 = entities.parameters[0];
        const parameter2 = entities.parameters[1];
        
        // Actualizar contexto
        conversationContext.lastParameter = parameter1;
        conversationContext.lastQuestionType = 'correlation';
        
        // Obtener datos para el periodo (usar √∫ltimos 30 d√≠as por defecto)
        const now = new Date();
        const startDate = new Date(now);
        startDate.setDate(now.getDate() - 30);
        
        const periodData = historicalData.filter(data => new Date(data.timestamp) >= startDate);
        
        // Calcular correlaci√≥n
        const values1 = periodData.map(data => 
          data[parameter1 === 'presi√≥n' ? 'pres' : 
              parameter1 === 'lluvia' ? 'lluvia' : 
              parameter1]
        );
        
        const values2 = periodData.map(data => 
          data[parameter2 === 'presi√≥n' ? 'pres' : 
              parameter2 === 'lluvia' ? 'lluvia' : 
              parameter2]
        );
        
        // Calcular media
        const mean1 = values1.reduce((a, b) => a + b, 0) / values1.length;
        const mean2 = values2.reduce((a, b) => a + b, 0) / values2.length;
        
        // Calcular covarianza y desviaci√≥n est√°ndar
        let covariance = 0;
        let stdDev1 = 0;
        let stdDev2 = 0;
        
        for (let i = 0; i < values1.length; i++) {
          const diff1 = values1[i] - mean1;
          const diff2 = values2[i] - mean2;
          
          covariance += diff1 * diff2;
          stdDev1 += diff1 * diff1;
          stdDev2 += diff2 * diff2;
        }
        
        covariance /= values1.length;
        stdDev1 = Math.sqrt(stdDev1 / values1.length);
        stdDev2 = Math.sqrt(stdDev2 / values1.length);
        
        // Calcular coeficiente de correlaci√≥n de Pearson
        const correlationCoefficient = covariance / (stdDev1 * stdDev2);
        
        // Generar respuesta basada en el coeficiente
        let response = `<div class="detailed-analysis">`;
        response += `<h3>An√°lisis de Correlaci√≥n</h3>`;
        
        // Mapear nombres de par√°metros a t√©rminos m√°s descriptivos
        const paramNameMap = {
          'temperatura': 'la temperatura',
          'humedad': 'la humedad',
          'presi√≥n': 'la presi√≥n atmosf√©rica',
          'lluvia': 'la lluvia',
          'viento': 'la velocidad del viento',
          'gas': 'el nivel de gas'
        };
        
        const param1Name = paramNameMap[parameter1] || parameter1;
        const param2Name = paramNameMap[parameter2] || parameter2;
        
        response += `<p>He analizado la relaci√≥n entre ${param1Name} y ${param2Name} durante los √∫ltimos 30 d√≠as.</p>`;
        
        // Interpretar el coeficiente de correlaci√≥n
        if (Math.abs(correlationCoefficient) > 0.7) {
          response += `<p>Existe una <strong>fuerte correlaci√≥n</strong> entre estos dos par√°metros, con un coeficiente de ${correlationCoefficient.toFixed(2)}.</p>`;
        } else if (Math.abs(correlationCoefficient) > 0.4) {
          response += `<p>Existe una <strong>correlaci√≥n moderada</strong> entre estos dos par√°metros, con un coeficiente de ${correlationCoefficient.toFixed(2)}.</p>`;
        } else if (Math.abs(correlationCoefficient) > 0.2) {
          response += `<p>Existe una <strong>ligera correlaci√≥n</strong> entre estos dos par√°metros, con un coeficiente de ${correlationCoefficient.toFixed(2)}.</p>`;
        } else {
          response += `<p>No hay una correlaci√≥n significativa entre estos dos par√°metros, con un coeficiente de ${correlationCoefficient.toFixed(2)}.</p>`;
        }
        
        // Interpretaci√≥n contextual
        if (correlationCoefficient > 0.5) {
          response += `<p>Esto significa que cuando ${param1Name} aumenta, ${param2Name} tiende a aumentar tambi√©n.</p>`;
        } else if (correlationCoefficient < -0.5) {
          response += `<p>Esto significa que cuando ${param1Name} aumenta, ${param2Name} tiende a disminuir.</p>`;
        } else {
          response += `<p>Los cambios en ${param1Name} no parecen tener una relaci√≥n clara con los cambios en ${param2Name}.</p>`;
        }
        
        // Informaci√≥n adicional basada en pares espec√≠ficos
        if ((parameter1 === 'temperatura' && parameter2 === 'humedad') || 
            (parameter1 === 'humedad' && parameter2 === 'temperatura')) {
          if (correlationCoefficient < 0) {
            response += `<p>Es com√∫n observar una correlaci√≥n negativa entre temperatura y humedad, ya que el aire caliente puede contener m√°s vapor de agua, pero la humedad relativa disminuye a medida que la temperatura aumenta.</p>`;
          }
        }
        
        if ((parameter1 === 'presi√≥n' && parameter2 === 'lluvia') || 
            (parameter1 === 'lluvia' && parameter2 === 'presi√≥n')) {
          if (correlationCoefficient < 0) {
            response += `<p>Es t√≠pico observar que la presi√≥n atmosf√©rica baja antes de una lluvia, lo que explica la correlaci√≥n negativa.</p>`;
          }
        }
        
        if ((parameter1 === 'temperatura' && parameter2 === 'presi√≥n') || 
            (parameter1 === 'presi√≥n' && parameter2 === 'temperatura')) {
          if (Math.abs(correlationCoefficient) < 0.3) {
            response += `<p>La temperatura y la presi√≥n atmosf√©rica suelen tener una relaci√≥n compleja que depende de muchos factores, por lo que no siempre se observa una correlaci√≥n clara.</p>`;
          }
        }
        
        // A√±adir informaci√≥n de confianza
        const confidence = Math.min(1, Math.abs(correlationCoefficient) * 0.8 + 0.2);
        response += `<div class="confidence-indicator">Confianza del an√°lisis: ${(confidence * 100).toFixed(0)}%</div>`;
        
        // Preparar datos para el gr√°fico
        const chartData = periodData.map((data, index) => ({
          x: new Date(data.timestamp),
          y1: data[parameter1 === 'presi√≥n' ? 'pres' : 
                 parameter1 === 'lluvia' ? 'lluvia' : 
                 parameter1],
          y2: data[parameter2 === 'presi√≥n' ? 'pres' : 
                 parameter2 === 'lluvia' ? 'lluvia' : 
                 parameter2]
        }));
        
        // A√±ade un gr√°fico de correlaci√≥n
        const chartId = `correlation-chart-${Date.now()}`;
        response += `
          <div class="prediction-chart-container">
            <div class="chart-title">Relaci√≥n entre ${parameter1} y ${parameter2}</div>
            <canvas class="prediction-chart" id="${chartId}" 
                    data-parameter1="${parameter1}"
                    data-parameter2="${parameter2}"
                    data-chart-data='${JSON.stringify(chartData)}'></canvas>
          </div>
        `;
        
        response += `</div>`;
        
        return response;
      } catch (error) {
        console.error('Error en an√°lisis de correlaci√≥n:', error);
        return "‚ö†Ô∏è Ocurri√≥ un error al analizar la correlaci√≥n. Por favor, intenta nuevamente.";
      }
    },
    
    greeting: () => {
      const hours = new Date().getHours();
      let greeting;
      
      if (hours < 12) {
        greeting = "¬°Buenos d√≠as! ";
      } else if (hours < 18) {
        greeting = "¬°Buenas tardes! ";
      } else {
        greeting = "¬°Buenas noches! ";
      }
      
      return `${greeting}Soy Horus AI, tu asistente inteligente especializado en meteorolog√≠a y sistemas Horus. ¬øEn qu√© puedo ayudarte hoy?`;
    },
    
    goodbye: () => {
      const hours = new Date().getHours();
      let farewell;
      
      if (hours < 12) {
        farewell = "¬°Que tengas un buen d√≠a!";
      } else if (hours < 18) {
        farewell = "¬°Que tengas una buena tarde!";
      } else {
        farewell = "¬°Que tengas una buena noche!";
      }
      
      return `${farewell} Si necesitas m√°s ayuda en el futuro, no dudes en regresar. ¬°Cu√≠date!`;
    },
    
    help: () => {
      return `<div class="general-answer">
        <h3>Ayuda con Horus AI</h3>
        <p>Puedo ayudarte con consultas meteorol√≥gicas y sobre el sistema Horus:</p>
        
        <h4>Preguntas meteorol√≥gicas</h4>
        <ul>
          <li>"¬øCu√°l es la temperatura actual?"</li>
          <li>"¬øC√≥mo ha sido la tendencia de humedad esta semana?"</li>
          <li>"Muestra la tendencia de presi√≥n de los √∫ltimos 7 d√≠as"</li>
          <li>"¬øC√≥mo se relaciona la humedad con la lluvia?"</li>
          <li>"¬øQu√© tiempo har√° ma√±ana?"</li>
        </ul>
        
        <h4>Preguntas sobre Horus</h4>
        <ul>
          <li>"¬øQu√© es Horus?"</li>
          <li>"¬øC√≥mo funciona el sistema Horus?"</li>
          <li>"¬øQu√© sensores tiene Horus?"</li>
          <li>"¬øD√≥nde est√° ubicado Horus?"</li>
        </ul>
        
        <h4>Preguntas generales</h4>
        <ul>
          <li>"¬øC√≥mo te llamas?"</li>
          <li>"¬øQui√©n te cre√≥?"</li>
          <li>"¬øQu√© puedes hacer?"</li>
        </ul>
        
        <p>¬°Hazme cualquier pregunta y har√© lo posible por ayudarte!</p>
      </div>`;
    },
    
    about_horus: () => {
      return `<div class="system-info">
        <h3>Sistema Horus</h3>
        <p>Horus es una estaci√≥n meteorol√≥gica avanzada dise√±ada para monitorear condiciones clim√°ticas en tiempo real.</p>
        
        <h4>Caracter√≠sticas principales:</h4>
        <ul>
          <li>Medici√≥n de temperatura, humedad, presi√≥n atmosf√©rica y direcci√≥n del viento</li>
          <li>Sensores de calidad del aire (PM2.5, PM10, CO2)</li>
          <li>Registro de precipitaciones y velocidad del viento</li>
          <li>Transmisi√≥n de datos en tiempo real v√≠a MQTT</li>
          <li>Interfaz web para visualizaci√≥n y an√°lisis de datos</li>
        </ul>
        
        <h4>Tecnolog√≠a utilizada:</h4>
        <ul>
          <li>ESP32 para procesamiento y comunicaci√≥n</li>
          <li>Sensores BME280, BMP180, anem√≥metro, pluvi√≥metro</li>
          <li>Protocolo MQTT para transmisi√≥n de datos</li>
          <li>Visualizaci√≥n con A-Frame para realidad virtual</li>
          <li>Plataforma web con an√°lisis de datos en tiempo real</li>
        </ul>
        
        <p>Horus proporciona datos meteorol√≥gicos precisos para an√°lisis clim√°ticos, predicciones y estudios ambientales.</p>
      </div>`;
    },
    
    support: () => {
      return `<div class="system-info">
        <h3>Soporte T√©cnico</h3>
        <p>Si est√°s teniendo problemas con Horus AI, aqu√≠ hay algunas soluciones:</p>
        
        <h4>Problemas comunes:</h4>
        <ul>
          <li><strong>Datos no actualizados:</strong> Verifica la conexi√≥n de la estaci√≥n Horus y espera unos minutos para que se actualicen los datos.</li>
          <li><strong>Interfaz lenta:</strong> Intenta actualizar la p√°gina o limpiar la cach√© del navegador.</li>
          <li><strong>Gr√°ficos no visibles:</strong> Aseg√∫rate de que JavaScript est√° habilitado en tu navegador.</li>
          <li><strong>Error de conexi√≥n:</strong> Verifica tu conexi√≥n a internet y recarga la p√°gina.</li>
        </ul>
        
        <h4>Soluci√≥n de problemas:</h4>
        <ol>
          <li>Recarga la p√°gina (F5 o Ctrl + R)</li>
          <li>Limpia la cach√© del navegador</li>
          <li>Intenta con otro navegador (Chrome, Firefox, Edge)</li>
          <li>Verifica tu conexi√≥n a internet</li>
        </ol>
        
        <p>Si el problema persiste, contacta al administrador del sistema para obtener ayuda adicional.</p>
      </div>`;
    },
    
    personal: () => {
      return `<div class="system-info">
        <h3>Sobre Horus AI</h3>
        <p>Soy Horus AI, un asistente inteligente especializado en meteorolog√≠a y sistemas Horus.</p>
        
        <h4>Mis capacidades:</h4>
        <ul>
          <li>Analizar y explicar datos meteorol√≥gicos en tiempo real</li>
          <li>Identificar tendencias y patrones clim√°ticos</li>
          <li>Realizar predicciones basadas en datos hist√≥ricos</li>
          <li>Explicar el funcionamiento del sistema Horus</li>
          <li>Proporcionar recomendaciones basadas en condiciones clim√°ticas</li>
        </ul>
        
        <h4>Mi prop√≥sito:</h4>
        <p>Fui creado para facilitar el acceso y comprensi√≥n de los datos meteorol√≥gicos recopilados por la estaci√≥n Horus, ayudando a usuarios a tomar decisiones informadas basadas en el clima.</p>
        
        <p>No soy un humano, sino un sistema de inteligencia artificial dise√±ado espec√≠ficamente para an√°lisis meteorol√≥gico y soporte del sistema Horus.</p>
      </div>`;
    },
    
    general: () => {
      const now = new Date();
      return `<div class="system-info">
        <h3>Informaci√≥n General</h3>
        
        <h4>Nombre:</h4>
        <p>Horus AI - Asistente Meteorol√≥gico Inteligente</p>
        
        <h4>Hora actual:</h4>
        <p>${now.toLocaleTimeString('es-ES', { 
          hour: '2-digit', 
          minute: '2-digit', 
          second: '2-digit'
        })}</p>
        
        <h4>Fecha actual:</h4>
        <p>${now.toLocaleDateString('es-ES', {
          weekday: 'long',
          year: 'numeric',
          month: 'long',
          day: 'numeric'
        })}</p>
        
        <h4>Ubicaci√≥n:</h4>
        <p>Estoy alojado en un servidor web y no tengo una ubicaci√≥n f√≠sica espec√≠fica. Los datos meteorol√≥gicos provienen de la estaci√≥n Horus.</p>
        
        <h4>Edad:</h4>
        <p>Fui desarrollado recientemente como parte del sistema Horus. No tengo una edad en el sentido humano.</p>
      </div>`;
    },
    
    out_of_scope: (intent) => {
      const domain = intent.domain || 'general';
      
      // Mensajes personalizados seg√∫n el √°mbito
      const domainMessages = {
        salud: `<div class="out-of-scope">
          <h3>Preguntas sobre Salud</h3>
          <p>Soy un asistente meteorol√≥gico especializado, no tengo informaci√≥n m√©dica. Para consultas sobre salud:</p>
          <ul>
            <li>Contacta a un profesional m√©dico calificado</li>
            <li>Visita un centro de salud o hospital</li>
            <li>Consulta fuentes oficiales de salud p√∫blica</li>
          </ul>
          <p>La informaci√≥n meteorol√≥gica puede influir en ciertas condiciones de salud, pero no sustituye el consejo m√©dico profesional.</p>
        </div>`,
        
        tecnolog√≠a: `<div class="out-of-scope">
          <h3>Preguntas sobre Tecnolog√≠a</h3>
          <p>Soy un asistente meteorol√≥gico especializado. Para consultas sobre tecnolog√≠a:</p>
          <ul>
            <li>Consulta foros especializados como Stack Overflow</li>
            <li>Revisa documentaci√≥n oficial de los productos</li>
            <li>Busca tutoriales en YouTube o plataformas educativas</li>
          </ul>
          <p>Puedo ayudarte con aspectos tecnol√≥gicos relacionados con el sistema Horus, pero no con otros temas tecnol√≥gicos generales.</p>
        </div>`,
        
        deportes: `<div class="out-of-scope">
          <h3>Preguntas sobre Deportes</h3>
          <p>Soy un asistente meteorol√≥gico especializado. Para informaci√≥n sobre deportes:</p>
          <ul>
            <li>Visita sitios web especializados en deportes</li>
            <li>Sigue canales deportivos de televisi√≥n</li>
            <li>Consulta aplicaciones deportivas oficiales</li>
          </ul>
          <p>Puedo informarte c√≥mo las condiciones meteorol√≥gicas pueden afectar actividades deportivas al aire libre.</p>
        </div>`,
        
        entretenimiento: `<div class="out-of-scope">
          <h3>Preguntas sobre Entretenimiento</h3>
          <p>Soy un asistente meteorol√≥gico especializado. Para informaci√≥n sobre entretenimiento:</p>
          <ul>
            <li>Visita plataformas de streaming como Netflix, Spotify</li>
            <li>Sigue medios especializados en cine, m√∫sica y televisi√≥n</li>
            <li>Consulta sitios web oficiales de artistas y producciones</li>
          </ul>
          <p>El clima puede influir en tus planes de entretenimiento al aire libre, pero no puedo recomendarte pel√≠culas o m√∫sica.</p>
        </div>`,
        
        comida: `<div class="out-of-scope">
          <h3>Preguntas sobre Comida</h3>
          <p>Soy un asistente meteorol√≥gico especializado. Para recetas o informaci√≥n sobre comida:</p>
          <ul>
            <li>Consulta sitios web especializados en gastronom√≠a</li>
            <li>Sigue chefs y canales culinarios</li>
            <li>Usa aplicaciones de recetas como Tasty o AllRecipes</li>
          </ul>
          <p>El clima puede afectar la disponibilidad de ciertos alimentos de temporada, pero no puedo proporcionar recetas espec√≠ficas.</p>
        </div>`,
        
        educaci√≥n: `<div class="out-of-scope">
          <h3>Preguntas sobre Educaci√≥n</h3>
          <p>Soy un asistente meteorol√≥gico especializado. Para informaci√≥n educativa:</p>
          <ul>
            <li>Consulta plataformas educativas como Khan Academy</li>
            <li>Visita bibliotecas digitales y recursos acad√©micos</li>
            <li>Contacta a profesores o instituciones educativas</li>
          </ul>
          <p>Puedo proporcionar informaci√≥n sobre meteorolog√≠a y ciencias atmosf√©ricas, pero no sobre otros temas educativos.</p>
        </div>`,
        
        finanzas: `<div class="out-of-scope">
          <h3>Preguntas sobre Finanzas</h3>
          <p>Soy un asistente meteorol√≥gico especializado. Para consultas financieras:</p>
          <ul>
            <li>Consulta a un asesor financiero certificado</li>
            <li>Visita sitios web especializados en finanzas</li>
            <li>Revisa informaci√≥n oficial de instituciones financieras</li>
          </ul>
          <p>El clima puede afectar ciertos sectores econ√≥micos, pero no puedo proporcionar asesoramiento financiero.</p>
        </div>`,
        
        general: `<div class="out-of-scope">
          <h3>Preguntas Fuera de Mi √Åmbito</h3>
          <p>Soy un asistente meteorol√≥gico especializado en el sistema Horus. Mi conocimiento est√° limitado a:</p>
          <ul>
            <li>Monitoreo y an√°lisis de datos meteorol√≥gicos</li>
            <li>Funcionamiento del sistema Horus</li>
            <li>An√°lisis de tendencias clim√°ticas</li>
            <li>Predicciones basadas en datos hist√≥ricos</li>
          </ul>
          
          <p>Para otras preguntas, te recomiendo:</p>
          <ul>
            <li>Buscar en fuentes especializadas en el tema</li>
            <li>Consultar a expertos en el campo espec√≠fico</li>
            <li>Utilizar asistentes dise√±ados para esos temas</li>
          </ul>
          
          <p>Si tu pregunta est√° relacionada con el clima o Horus, ¬°har√© lo posible por ayudarte!</p>
        </div>`
      };
      
      return domainMessages[domain] || domainMessages.general;
    },
    
    unrelated: (entities, context) => {
      return `<div class="out-of-scope">
        <h3>No Entiendo Tu Pregunta</h3>
        <p>No estoy seguro de entender tu pregunta. Soy un asistente meteorol√≥gico especializado en el sistema Horus.</p>
        
        <h4>¬øC√≥mo puedo ayudarte?</h4>
        <ul>
          <li>Consultar datos meteorol√≥gicos actuales</li>
          <li>Analizar tendencias clim√°ticas hist√≥ricas</li>
          <li>Realizar predicciones basadas en datos</li>
          <li>Explicar el funcionamiento de Horus</li>
        </ul>
        
        <p>Ejemplos de preguntas que puedo responder:</p>
        <ul>
          <li>"¬øCu√°l es la temperatura actual?"</li>
          <li>"¬øC√≥mo funciona el sistema Horus?"</li>
          <li>"Muestra la tendencia de presi√≥n de los √∫ltimos 7 d√≠as"</li>
        </ul>
        
        <p>Por favor, reformula tu pregunta para que est√© relacionada con el clima o el sistema Horus.</p>
      </div>`;
    }
  };

  // Analiza los datos para generar una respuesta descriptiva
  const analyzeData = (parameter, chartData, periodInfo) => {
    if (chartData.length === 0) {
      return "No hay datos disponibles para el periodo seleccionado.";
    }
    
    // Calcular estad√≠sticas
    const values = chartData.map(item => item.y);
    const sum = values.reduce((a, b) => a + b, 0);
    const average = sum / values.length;
    const max = Math.max(...values);
    const min = Math.min(...values);
    
    // Determinar tendencia
    const startValue = values[0];
    const endValue = values[values.length - 1];
    const trend = endValue > startValue ? "ascendente" : "descendente";
    const trendStrength = Math.abs(endValue - startValue) / startValue;
    
    // Generar respuesta
    let response = `<div class="detailed-analysis">`;
    response += `<h3>An√°lisis de ${parameter.charAt(0).toUpperCase() + parameter.slice(1)}</h3>`;
    
    // Descripci√≥n general
    response += `<p>En el periodo seleccionado (${periodInfo.type === 'day' ? periodInfo.value + ' d√≠as' : periodInfo.type}):</p>`;
    response += `<div class="statistics-grid">`;
    response += `<div class="stat-item"><strong>Promedio</strong><br><span class="stat-value">${average.toFixed(1)}`;
    if (parameter !== 'lluvia' && parameter !== 'direcci√≥n') {
      response += ` ${parameter === 'presi√≥n' ? 'hPa' : 
                  parameter === 'humedad' ? '%' : 
                  '¬∞C'}`;
    }
    response += `</span></div>`;
    
    response += `<div class="stat-item"><strong>M√°ximo</strong><br><span class="stat-value">${max.toFixed(1)}`;
    if (parameter !== 'lluvia' && parameter !== 'direcci√≥n') {
      response += ` ${parameter === 'presi√≥n' ? 'hPa' : 
                  parameter === 'humedad' ? '%' : 
                  '¬∞C'}`;
    }
    response += `</span></div>`;
    
    response += `<div class="stat-item"><strong>M√≠nimo</strong><br><span class="stat-value">${min.toFixed(1)}`;
    if (parameter !== 'lluvia' && parameter !== 'direcci√≥n') {
      response += ` ${parameter === 'presi√≥n' ? 'hPa' : 
                  parameter === 'humedad' ? '%' : 
                  '¬∞C'}`;
    }
    response += `</span></div>`;
    response += `</div>`;
    
    // An√°lisis de tendencia
    if (trendStrength > 0.05) { // Si hay una tendencia significativa
      response += `<div class="trend-analysis">`;
      response += `<h3>Tendencia</h3>`;
      response += `<p>La tendencia es claramente ${trend} (${(trendStrength * 100).toFixed(1)}% de cambio).</p>`;
      
      if (parameter === 'temperatura') {
        response += trend === 'ascendente' ? 
          '<p>Esto sugiere un calentamiento progresivo en el periodo analizado. Podr√≠as considerar ajustar tu ropa o planificar actividades al aire libre en los momentos m√°s frescos del d√≠a.</p>' :
          '<p>Esto sugiere un enfriamiento progresivo en el periodo analizado. Podr√≠as considerar abrigarte adecuadamente para las actividades al aire libre.</p>';
      } else if (parameter === 'humedad') {
        response += trend === 'ascendente' ? 
          '<p>El aumento de humedad podr√≠a indicar mayor probabilidad de precipitaci√≥n. Considera llevar paraguas si planeas estar al aire libre.</p>' :
          '<p>La disminuci√≥n de humedad sugiere condiciones m√°s secas. Podr√≠as necesitar hidratarte m√°s frecuentemente.</p>';
      } else if (parameter === 'presi√≥n') {
        response += trend === 'ascendente' ? 
          '<p>El aumento de presi√≥n suele indicar condiciones clim√°ticas estables y buen tiempo. Es un buen momento para actividades al aire libre.</p>' :
          '<p>La disminuci√≥n de presi√≥n suele preceder a condiciones clim√°ticas inestables. Podr√≠as considerar prepararte para posibles cambios en el clima.</p>';
      }
      
      response += `</div>`;
    } else {
      response += `<div class="trend-analysis">`;
      response += `<h3>Tendencia</h3>`;
      response += `<p>La tendencia es relativamente estable sin cambios significativos.</p>`;
      response += `<p>Las condiciones meteorol√≥gicas permanecen consistentes durante el periodo analizado.</p>`;
      response += `</div>`;
    }
    
    // A√±adir informaci√≥n contextual adicional
    response += `<div class="trend-analysis">`;
    response += `<h3>Recomendaciones</h3>`;
    
    switch(parameter) {
      case 'temperatura':
        if (average > 25) {
          response += `<p>Con temperaturas promedio por encima de 25¬∞C, te recomendamos usar ropa ligera y mantener una buena hidrataci√≥n.</p>`;
        } else if (average < 10) {
          response += `<p>Con temperaturas promedio por debajo de 10¬∞C, te recomendamos abrigarte adecuadamente para protegerte del fr√≠o.</p>`;
        } else {
          response += `<p>Las temperaturas est√°n dentro de un rango moderado. Considera vestir capas de ropa para adaptarte a los cambios durante el d√≠a.</p>`;
        }
        break;
      case 'humedad':
        if (average > 70) {
          response += `<p>La alta humedad puede hacer que la temperatura se sienta m√°s alta de lo que realmente es. Considera usar ropa transpirable.</p>`;
        } else if (average < 30) {
          response += `<p>La baja humedad puede causar sequedad en la piel y las v√≠as respiratorias. Considera usar humectante y mantenerte hidratado.</p>`;
        } else {
          response += `<p>La humedad est√° en un nivel moderado, lo que suele ser c√≥modo para la mayor√≠a de las personas.</p>`;
        }
        break;
      case 'presi√≥n':
        if (average < 1000) {
          response += `<p>La presi√≥n atmosf√©rica baja suele indicar condiciones clim√°ticas inestables. Mantente atento a posibles cambios en el clima.</p>`;
        } else if (average > 1020) {
          response += `<p>La presi√≥n atmosf√©rica alta suele indicar condiciones clim√°ticas estables y buen tiempo. Es un buen momento para actividades al aire libre.</p>`;
        } else {
          response += `<p>La presi√≥n atmosf√©rica est√° en un nivel normal, indicando condiciones clim√°ticas estables.</p>`;
        }
        break;
    }
    
    response += `</div>`;
    response += `</div>`;
    
    return response;
  };

  // Renderizar gr√°ficos
  const renderChart = (parameter, chartData, chartId) => {
    const chartCtx = document.getElementById(chartId)?.getContext('2d');
    if (!chartCtx) return;
    
    // Determina el nombre del par√°metro y colores
    let paramName = '';
    let color = '#4a90e2';
    let unit = '';
    
    switch (parameter) {
      case 'temperatura':
        paramName = 'Temperatura';
        color = '#FF6384';
        unit = '¬∞C';
        break;
      case 'humedad':
        paramName = 'Humedad';
        color = '#36A2EB';
        unit = '%';
        break;
      case 'presi√≥n':
        paramName = 'Presi√≥n Atmosf√©rica';
        color = '#FFCE56';
        unit = 'hPa';
        break;
      case 'lluvia':
        paramName = 'Precipitaci√≥n';
        color = '#46BFBD';
        unit = 'Presencia';
        break;
      case 'viento':
        paramName = 'Viento';
        color = '#C9CBCF';
        unit = 'm/s';
        break;
      case 'gas':
        paramName = 'Nivel de Gas';
        color = '#FDB45C';
        unit = 'kŒ©';
        break;
      case 'direcci√≥n':
        paramName = 'Direcci√≥n del Viento';
        color = '#9966FF';
        unit = '¬∞';
        break;
      default:
        paramName = 'Medici√≥n';
        unit = '';
    }
    
    // Crea el nuevo gr√°fico
    const chart = new Chart(chartCtx, {
      type: 'line',
      data: {
        datasets: [{
          label: paramName,
           chartData,
          borderColor: color,
          backgroundColor: `${color}40`,
          borderWidth: 3,
          tension: 0.3,
          pointRadius: 3
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            display: false
          },
          tooltip: {
            mode: 'index',
            intersect: false
          }
        },
        scales: {
          x: {
            type: 'time',
            time: {
              unit: 'day'
            },
            title: {
              display: true,
              text: 'Fecha'
            }
          },
          y: {
            beginAtZero: false,
            title: {
              display: true,
              text: unit
            }
          }
        }
      }
    });
    
    // Almacenar instancia del gr√°fico para actualizarla al cambiar de tema
    charts.push(chart);
  };
  
  // Renderizar gr√°ficos de comparaci√≥n
  const renderComparisonChart = (parameter, chartData1, chartData2, period1, period2, chartId) => {
    const chartCtx = document.getElementById(chartId)?.getContext('2d');
    if (!chartCtx) return;
    
    // Determina el nombre del par√°metro y colores
    let paramName = '';
    let color1 = '#FF6384';
    let color2 = '#36A2EB';
    let unit = '';
    
    switch (parameter) {
      case 'temperatura':
        paramName = 'Temperatura';
        unit = '¬∞C';
        break;
      case 'humedad':
        paramName = 'Humedad';
        unit = '%';
        break;
      case 'presi√≥n':
        paramName = 'Presi√≥n Atmosf√©rica';
        unit = 'hPa';
        break;
      case 'lluvia':
        paramName = 'Precipitaci√≥n';
        unit = 'Presencia';
        break;
      case 'viento':
        paramName = 'Viento';
        unit = 'm/s';
        break;
      case 'gas':
        paramName = 'Nivel de Gas';
        unit = 'kŒ©';
        break;
      case 'direcci√≥n':
        paramName = 'Direcci√≥n del Viento';
        unit = '¬∞';
        break;
      default:
        paramName = 'Medici√≥n';
        unit = '';
    }
    
    // Crea el nuevo gr√°fico
    const chart = new Chart(chartCtx, {
      type: 'line',
       data: {
        datasets: [
          {
            label: period1,
             chartData1,
            borderColor: color1,
            backgroundColor: `${color1}40`,
            borderWidth: 3,
            tension: 0.3,
            pointRadius: 3
          },
          {
            label: period2,
             chartData2,
            borderColor: color2,
            backgroundColor: `${color2}40`,
            borderWidth: 3,
            tension: 0.3,
            pointRadius: 3
          }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            position: 'top'
          },
          tooltip: {
            mode: 'index',
            intersect: false
          }
        },
        scales: {
          x: {
            type: 'time',
            time: {
              unit: 'day'
            },
            title: {
              display: true,
              text: 'Fecha'
            }
          },
          y: {
            beginAtZero: false,
            title: {
              display: true,
              text: unit
            }
          }
        }
      }
    });
    
    // Almacenar instancia del gr√°fico para actualizarla al cambiar de tema
    charts.push(chart);
  };

  // Renderizar gr√°ficos de extremos
  const renderExtremesChart = (parameter, chartData, maxDate, minDate, chartId) => {
    const chartCtx = document.getElementById(chartId)?.getContext('2d');
    if (!chartCtx) return;
    
    // Determina el nombre del par√°metro y colores
    let paramName = '';
    let color = '#4a90e2';
    let unit = '';
    
    switch (parameter) {
      case 'temperatura':
        paramName = 'Temperatura';
        color = '#FF6384';
        unit = '¬∞C';
        break;
      case 'humedad':
        paramName = 'Humedad';
        color = '#36A2EB';
        unit = '%';
        break;
      case 'presi√≥n':
        paramName = 'Presi√≥n Atmosf√©rica';
        color = '#FFCE56';
        unit = 'hPa';
        break;
      case 'lluvia':
        paramName = 'Precipitaci√≥n';
        color = '#46BFBD';
        unit = 'Presencia';
        break;
      case 'viento':
        paramName = 'Viento';
        color = '#C9CBCF';
        unit = 'm/s';
        break;
      case 'gas':
        paramName = 'Nivel de Gas';
        color = '#FDB45C';
        unit = 'kŒ©';
        break;
      case 'direcci√≥n':
        paramName = 'Direcci√≥n del Viento';
        color = '#9966FF';
        unit = '¬∞';
        break;
      default:
        paramName = 'Medici√≥n';
        unit = '';
    }
    
    // Preparar datos con marcadores para m√°ximos y m√≠nimos
    const dataWithMarkers = chartData.map(item => ({
      x: item.x,
      y: item.y,
      pointBackgroundColor: item.x.toISOString() === maxDate || item.x.toISOString() === minDate ? 
                            (item.x.toISOString() === maxDate ? '#FF0000' : '#0000FF') : 
                            color
    }));
    
    // Crea el nuevo gr√°fico
    const chart = new Chart(chartCtx, {
      type: 'line',
       data: {
        datasets: [{
          label: paramName,
           dataWithMarkers,
          borderColor: color,
          backgroundColor: `${color}40`,
          borderWidth: 3,
          tension: 0.3,
          pointRadius: function(context) {
            const index = context.dataIndex;
            const value = context.dataset.data[index];
            return value.pointBackgroundColor !== color ? 6 : 3;
          },
          pointBackgroundColor: function(context) {
            const index = context.dataIndex;
            const value = context.dataset.data[index];
            return value.pointBackgroundColor;
          }
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            display: false
          },
          tooltip: {
            mode: 'index',
            intersect: false
          }
        },
        scales: {
          x: {
            type: 'time',
            time: {
              unit: 'day'
            },
            title: {
              display: true,
              text: 'Fecha'
            }
          },
          y: {
            beginAtZero: false,
            title: {
              display: true,
              text: unit
            }
          }
        }
      }
    });
    
    // Almacenar instancia del gr√°fico para actualizarla al cambiar de tema
    charts.push(chart);
  };

  // Renderizar gr√°ficos de correlaci√≥n
  const renderCorrelationChart = (parameter1, parameter2, chartData, chartId) => {
    const chartCtx = document.getElementById(chartId)?.getContext('2d');
    if (!chartCtx) return;
    
    // Determina los nombres de los par√°metros y colores
    let paramName1 = '';
    let paramName2 = '';
    let color1 = '#FF6384';
    let color2 = '#36A2EB';
    let unit1 = '';
    let unit2 = '';
    
    const getParameterInfo = (parameter) => {
      switch (parameter) {
        case 'temperatura':
          return { name: 'Temperatura', color: '#FF6384', unit: '¬∞C' };
        case 'humedad':
          return { name: 'Humedad', color: '#36A2EB', unit: '%' };
        case 'presi√≥n':
          return { name: 'Presi√≥n Atmosf√©rica', color: '#FFCE56', unit: 'hPa' };
        case 'lluvia':
          return { name: 'Precipitaci√≥n', color: '#46BFBD', unit: 'Presencia' };
        case 'viento':
          return { name: 'Viento', color: '#C9CBCF', unit: 'm/s' };
        case 'gas':
          return { name: 'Nivel de Gas', color: '#FDB45C', unit: 'kŒ©' };
        case 'direcci√≥n':
          return { name: 'Direcci√≥n del Viento', color: '#9966FF', unit: '¬∞' };
        default:
          return { name: 'Medici√≥n', color: '#4a90e2', unit: '' };
      }
    };
    
    const info1 = getParameterInfo(parameter1);
    const info2 = getParameterInfo(parameter2);
    
    paramName1 = info1.name;
    color1 = info1.color;
    unit1 = info1.unit;
    
    paramName2 = info2.name;
    color2 = info2.color;
    unit2 = info2.unit;
    
    // Crea el nuevo gr√°fico
    const chart = new Chart(chartCtx, {
      type: 'line',
       data: {
        datasets: [
          {
            label: paramName1,
             chartData.map(item => ({ x: item.x, y: item.y1 })),
            borderColor: color1,
            backgroundColor: `${color1}40`,
            borderWidth: 3,
            tension: 0.3,
            pointRadius: 3
          },
          {
            label: paramName2,
             chartData.map(item => ({ x: item.x, y: item.y2 })),
            borderColor: color2,
            backgroundColor: `${color2}40`,
            borderWidth: 3,
            tension: 0.3,
            pointRadius: 3
          }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            position: 'top'
          },
          tooltip: {
            mode: 'index',
            intersect: false
          }
        },
        scales: {
          x: {
            type: 'time',
            time: {
              unit: 'day'
            },
            title: {
              display: true,
              text: 'Fecha'
            }
          },
          y: {
            beginAtZero: false,
            title: {
              display: true,
              text: `${unit1} / ${unit2}`
            }
          }
        }
      }
    });
    
    // Almacenar instancia del gr√°fico para actualizarla al cambiar de tema
    charts.push(chart);
  };

  // Procesar mensaje del usuario
  const processUserMessage = async (message) => {
    // Guardar en historial de conversaci√≥n
    conversationContext.conversationHistory.push({
      role: 'user',
      content: message,
      timestamp: new Date().toISOString()
    });
    
    // Corregir ortograf√≠a
    const { correctedMessage, hasCorrection } = spellingCorrection.correctMessage(message);
    
    // Mostrar mensaje de correcci√≥n SOLO si hubo correcciones significativas
    if (hasCorrection) {
      addMessage(`üîç Entiendo que quiz√°s quisiste decir: "${correctedMessage}"`, false);
    }
    
    // Normalizar mensaje
    const normalizedMessage = correctedMessage.toLowerCase().replace(/[.,!?]/g, '');
    
    // An√°lisis de √°mbito
    const domainAnalysis = semanticAnalysis.analyzeDomain(normalizedMessage);
    
    // Verificar referencias
    const references = semanticAnalysis.analyzeReferences(normalizedMessage, conversationContext);
    
    // Resolver an√°foras
    const resolvedMessage = semanticAnalysis.resolveAnaphora(normalizedMessage, conversationContext);
    
    // Verificar si es hipot√©tica
    const isHypothetical = semanticAnalysis.analyzeHypotheticals(normalizedMessage);
    
    // Identificar entidades
    const entities = semanticAnalysis.identifyEntities(resolvedMessage);
    
    // Analizar intenci√≥n
    const intent = semanticAnalysis.analyzeIntent(resolvedMessage, entities, domainAnalysis);
    
    // Verificar preguntas compuestas
    const isCompoundQuestion = semanticAnalysis.analyzeCompoundQuestions(normalizedMessage);
    
    // Entidades para la respuesta
    const detectedEntities = {
      parameters: entities.parameters,
      temporal: entities.periods,
      comparisons: entities.comparisons,
      operations: entities.operations
    };
    
    // Actualizar contexto temporal si se identifica uno
    if (entities.periods.length > 0) {
      conversationContext.temporalContext = entities.periods[0];
    }
    
    // Actualizar contexto de par√°metros si se identifican
    if (entities.parameters.length > 0) {
      conversationContext.lastParameter = entities.parameters[0];
    }
    
    // Si hay referencias, actualizar contexto
    if (references.parameters.length > 0) {
      conversationContext.lastParameter = references.parameters[0];
    }
    
    // Si hay contexto de par√°metro pero no se identific√≥ en la pregunta, usar el contexto
    if (conversationContext.lastParameter && entities.parameters.length === 0) {
      entities.parameters = [conversationContext.lastParameter];
    }
    
    // Si hay contexto temporal pero no se identific√≥ en la pregunta, usar el contexto
    if (conversationContext.lastPeriod && entities.periods.length === 0) {
      entities.periods = [conversationContext.lastPeriod];
    }
    
    try {
      // Procesar seg√∫n la intenci√≥n detectada
      if (intent && intent.confidence >= conversationContext.confidenceThreshold) {
        // Manejar intenci√≥n reconocida
        if (intentHandlers[intent.type]) {
          return intentHandlers[intent.type](entities, conversationContext);
        }
      }
      
      // Si no se reconoci√≥ la intenci√≥n pero es una pregunta meteorol√≥gica
      if (domainAnalysis.isWeatherQuestion) {
        // Intentar identificar par√°metros incluso sin intenci√≥n clara
        if (entities.parameters.length > 0) {
          // Si hay par√°metros pero no intenci√≥n clara, asumir consulta actual
          return intentHandlers.current_data({
            parameters: entities.parameters,
            periods: ['hoy']
          }, conversationContext);
        }
        
        // Si hay periodos pero no par√°metros, pedir aclaraci√≥n
        if (entities.periods.length > 0) {
          return "Para poder ayudarte, necesito saber qu√© par√°metro meteorol√≥gico te interesa. Por ejemplo: 'temperatura', 'humedad' o 'presi√≥n'.";
        }
      }
      
      // Si es un saludo aunque no se haya detectado claramente
      if (semanticAnalysis.isGreeting(normalizedMessage)) {
        return intentHandlers.greeting();
      }
      
      // Si es una despedida aunque no se haya detectado claramente
      if (semanticAnalysis.isGoodbye(normalizedMessage)) {
        return intentHandlers.goodbye();
      }
      
      // Si es una solicitud de ayuda aunque no se haya detectado claramente
      if (semanticAnalysis.isHelpRequest(normalizedMessage)) {
        return intentHandlers.help();
      }
      
      // Si no se identifica un √°mbito espec√≠fico
      if (!domainAnalysis.isWeatherQuestion) {
        // Verificar si es una pregunta sobre Horus
        if (normalizedMessage.includes('horus') || normalizedMessage.includes('sistema')) {
          return intentHandlers.about_horus();
        }
        
        // Verificar si es una pregunta de soporte t√©cnico
        if (normalizedMessage.includes('problema') || normalizedMessage.includes('error') || 
            normalizedMessage.includes('no funciona') || normalizedMessage.includes('lento')) {
          return intentHandlers.support();
        }
        
        // Verificar si es una pregunta personal
        if (normalizedMessage.includes('qui√©n eres') || normalizedMessage.includes('quien eres') ||
            normalizedMessage.includes('c√≥mo te llamas') || normalizedMessage.includes('como te llamas')) {
          return intentHandlers.personal();
        }
        
        // Verificar si es una pregunta general
        if (normalizedMessage.includes('nombre') || normalizedMessage.includes('hora') ||
            normalizedMessage.includes('edad') || normalizedMessage.includes('vives')) {
          return intentHandlers.general();
        }
        
        // Verificar el dominio de preguntas fuera del √°mbito
        let domain = 'general';
        if (normalizedMessage.includes('salud') || normalizedMessage.includes('m√©dico')) {
          domain = 'salud';
        } else if (normalizedMessage.includes('tecnolog√≠a') || normalizedMessage.includes('tecnologia') ||
                   normalizedMessage.includes('computadora') || normalizedMessage.includes('internet')) {
          domain = 'tecnolog√≠a';
        } else if (normalizedMessage.includes('deportes') || normalizedMessage.includes('f√∫tbol')) {
          domain = 'deportes';
        } else if (normalizedMessage.includes('entretenimiento') || normalizedMessage.includes('pel√≠cula') ||
                   normalizedMessage.includes('m√∫sica')) {
          domain = 'entretenimiento';
        } else if (normalizedMessage.includes('comida') || normalizedMessage.includes('receta')) {
          domain = 'comida';
        } else if (normalizedMessage.includes('educaci√≥n') || normalizedMessage.includes('escuela')) {
          domain = 'educaci√≥n';
        } else if (normalizedMessage.includes('finanzas') || normalizedMessage.includes('dinero')) {
          domain = 'finanzas';
        }
        
        return intentHandlers.out_of_scope({ domain });
      }
      
      // Si es una pregunta hipot√©tica
      if (isHypothetical) {
        return "Como asistente meteorol√≥gico, solo puedo proporcionar informaci√≥n basada en datos reales y an√°lisis hist√≥ricos. No puedo especular sobre escenarios hipot√©ticos que no est√©n respaldados por datos clim√°ticos.";
      }
      
      // Si es una pregunta compuesta
      if (isCompoundQuestion) {
        return "Para poder ayudarte mejor, por favor divide tu pregunta en partes m√°s espec√≠ficas. Por ejemplo, en lugar de preguntar sobre varios par√°metros a la vez, enf√≥cate en uno primero.";
      }
      
      // Si hay entidades detectadas pero no intenci√≥n clara
      if (detectedEntities.parameters.length > 0 || 
          detectedEntities.temporal.length > 0 || 
          detectedEntities.comparisons.length > 0) {
        let response = "He detectado algunos elementos relevantes en tu pregunta, pero no estoy seguro de entender exactamente qu√© necesitas.\n\n";
        
        if (detectedEntities.parameters.length > 0) {
          response += `* Par√°metros meteorol√≥gicos: ${detectedEntities.parameters.join(', ')}\n`;
        }
        if (detectedEntities.temporal.length > 0) {
          response += `* Periodos de tiempo: ${detectedEntities.temporal.join(', ')}\n`;
        }
        if (detectedEntities.comparisons.length > 0) {
          response += `* Tipos de comparaci√≥n: ${detectedEntities.comparisons.map(c => 
            c === 'vs' ? 'comparaci√≥n directa' : 
            c === 'trend' ? 'tendencia' : 
            c === 'correlation' ? 'correlaci√≥n' : c).join(', ')}\n`;
        }
        if (detectedEntities.operations.length > 0) {
          response += `* Operaciones solicitadas: ${detectedEntities.operations.join(', ')}\n`;
        }
        
        response += `\n¬øPodr√≠as reformular tu pregunta para que sea m√°s espec√≠fica?`;
        
        return response;
      }
      
      // Si no hay contexto previo y no es claramente fuera de √°mbito, asumimos que es general
      return `<div class="out-of-scope">
        <h3>No Entiendo Tu Pregunta</h3>
        <p>No estoy seguro de entender tu pregunta. Soy un asistente meteorol√≥gico especializado en el sistema Horus.</p>
        
        <h4>¬øC√≥mo puedo ayudarte?</h4>
        <ul>
          <li>Consultar datos meteorol√≥gicos actuales</li>
          <li>Analizar tendencias clim√°ticas hist√≥ricas</li>
          <li>Realizar predicciones basadas en datos</li>
          <li>Explicar el funcionamiento de Horus</li>
        </ul>
        
        <p>Ejemplos de preguntas que puedo responder:</p>
        <ul>
          <li>"¬øCu√°l es la temperatura actual?"</li>
          <li>"¬øC√≥mo funciona el sistema Horus?"</li>
          <li>"Muestra la tendencia de presi√≥n de los √∫ltimos 7 d√≠as"</li>
        </ul>
        
        <p>Por favor, reformula tu pregunta para que est√© relacionada con el clima o el sistema Horus.</p>
      </div>`;
      
    } catch (error) {
      console.error('Error procesando mensaje:', error);
      return "‚ö†Ô∏è Ocurri√≥ un error al procesar tu solicitud. Por favor, intenta nuevamente.";
    }
  };

  // Enviar mensaje
  const sendMessage = async () => {
    const message = userInput.value.trim();
    if (message === '' || !chatbotReady) return;
    
    // A√±ade mensaje del usuario
    addMessage(message, true);
    userInput.value = '';
    
    // Muestra "escribiendo..."
    const loadingId = showLoading();
    
    try {
      // Procesa el mensaje
      const response = await processUserMessage(message);
      
      // Remueve el mensaje de "escribiendo..."
      document.getElementById(loadingId).remove();
      
      // Muestra la respuesta
      addMessage(response, false, 'local');
      
      // Renderizar gr√°ficos si existen
      setTimeout(() => {
        document.querySelectorAll('.prediction-chart').forEach(canvas => {
          const parameter = canvas.dataset.parameter;
          const chartData = JSON.parse(canvas.dataset.chartData);
          renderChart(parameter, chartData, canvas.id);
        });
        
        document.querySelectorAll('.comparison-chart').forEach(canvas => {
          const parameter = canvas.dataset.parameter;
          const chartData1 = JSON.parse(canvas.dataset.chartData1);
          const chartData2 = JSON.parse(canvas.dataset.chartData2);
          const period1 = canvas.dataset.period1;
          const period2 = canvas.dataset.period2;
          renderComparisonChart(parameter, chartData1, chartData2, period1, period2, canvas.id);
        });
        
        document.querySelectorAll('.extremes-chart').forEach(canvas => {
          const parameter = canvas.dataset.parameter;
          const chartData = JSON.parse(canvas.dataset.chartData);
          const maxDate = canvas.dataset.maxDate;
          const minDate = canvas.dataset.minDate;
          renderExtremesChart(parameter, chartData, maxDate, minDate, canvas.id);
        });
        
        document.querySelectorAll('.correlation-chart').forEach(canvas => {
          const parameter1 = canvas.dataset.parameter1;
          const parameter2 = canvas.dataset.parameter2;
          const chartData = JSON.parse(canvas.dataset.chartData);
          renderCorrelationChart(parameter1, parameter2, chartData, canvas.id);
        });
      }, 100);
      
    } catch (error) {
      console.error('Error procesando mensaje:', error);
      document.getElementById(loadingId).remove();
      addMessage("‚ö†Ô∏è Ocurri√≥ un error al procesar tu solicitud. Por favor, intenta nuevamente.", false);
    }
  };

  // Inicializar chatbot
  const initChatbot = async () => {
    try {
      // Carga datos hist√≥ricos
      await loadHistoricalData();
      
      chatbotReady = true;
      
      // Configurar sugerencias
      document.querySelectorAll('.suggestion').forEach(suggestion => {
        suggestion.addEventListener('click', () => {
          userInput.value = suggestion.textContent;
          sendMessage();
        });
      });
      
      // Hacer disponible para main.js
      window.updateChatbotCharts = () => {
        // Destruir y recrear los gr√°ficos para actualizar colores
        charts.forEach(chart => {
          if (chart && chart.destroy) {
            chart.destroy();
          }
        });
        charts = [];
        
        // Volver a renderizar todos los gr√°ficos
        setTimeout(() => {
          document.querySelectorAll('.prediction-chart').forEach(canvas => {
            const parameter = canvas.dataset.parameter;
            const chartData = JSON.parse(canvas.dataset.chartData);
            renderChart(parameter, chartData, canvas.id);
          });
          
          document.querySelectorAll('.comparison-chart').forEach(canvas => {
            const parameter = canvas.dataset.parameter;
            const chartData1 = JSON.parse(canvas.dataset.chartData1);
            const chartData2 = JSON.parse(canvas.dataset.chartData2);
            const period1 = canvas.dataset.period1;
            const period2 = canvas.dataset.period2;
            renderComparisonChart(parameter, chartData1, chartData2, period1, period2, canvas.id);
          });
          
          document.querySelectorAll('.extremes-chart').forEach(canvas => {
            const parameter = canvas.dataset.parameter;
            const chartData = JSON.parse(canvas.dataset.chartData);
            const maxDate = canvas.dataset.maxDate;
            const minDate = canvas.dataset.minDate;
            renderExtremesChart(parameter, chartData, maxDate, minDate, canvas.id);
          });
          
          document.querySelectorAll('.correlation-chart').forEach(canvas => {
            const parameter1 = canvas.dataset.parameter1;
            const parameter2 = canvas.dataset.parameter2;
            const chartData = JSON.parse(canvas.dataset.chartData);
            renderCorrelationChart(parameter1, parameter2, chartData, canvas.id);
          });
        }, 100);
      };
      
    } catch (error) {
      console.error('Error inicializando chatbot:', error);
      chatbotReady = true;
      addMessage("‚ö†Ô∏è Hubo un problema al cargar los datos. Algunas funciones avanzadas podr√≠an no estar disponibles.", false);
    }
  };

  // Event listeners
  sendButton.addEventListener('click', sendMessage);
  userInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') sendMessage();
  });
  
  // Inicializar el chatbot
  initChatbot();
</script>
</body>
</html>
