<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Chatbot Meteorol칩gico - Horus</title>
  <link rel="stylesheet" href="../css/style.css" />
  <link rel="stylesheet" href="../css/chatbot.css" />
  <script src="../js/PapaParse.js"></script>
  <script src="../js/chart.js"></script>
</head>
<body class="light-mode chatbot-page">
<nav class="nav">
  <div class="nav-container">
    <div class="nav-buttons">
      <a href="../index.html" class="nav-btn"><span class="nav-icon">游</span> Inicio</a>
      <a href="mqtt.html" class="nav-btn">
        <span class="nav-icon">游니</span> Datos en Vivo
      </a>
      <a href="analisis.html" class="nav-btn">
        <span class="nav-icon">游늵</span> An치lisis
      </a>
      <a href="chatbot.html" class="nav-btn active">
        <span class="nav-icon">游뱄</span> Chatbot
      </a>
    </div>
    <!-- Switch de Galahad -->
    <div class="nav-right">
      <label class="theme-switch">
        <input type="checkbox" class="theme-switch__checkbox">
        <div class="theme-switch__container">
          <div class="theme-switch__clouds"></div>
          <div class="theme-switch__stars-container">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 144 55" fill="none">
            </svg>
          </div>
          <div class="theme-switch__sun-moon-container">
            <div class="theme-switch__moon">
              <div class="theme-switch__spot"></div>
              <div class="theme-switch__spot"></div>
              <div class="theme-switch__spot"></div>
            </div>
          </div>
        </div>
      </label>
    </div>
  </div>
</nav>

<div class="container">
  <header>
    <h1>游뱄 Horus AI - An치lisis Avanzado</h1>
    <p>Un asistente inteligente con an치lisis sem치ntico avanzado y procesamiento profundo de preguntas</p>
  </header>
  
  <main id="chat-container" class="chat-main-container">
    <div id="chat-messages" class="chat-messages">
      <div class="message bot welcome-message">
        <div class="bot-avatar">
          <span>游뱄</span>
        </div>
        <div class="message-content">
          춰Hola! Soy Horus AI, tu asistente meteorol칩gico especializado.<br><br>
          <strong>Puedo ayudarte con:</strong>
          <ul>
            <li>Consultar la temperatura, humedad, presi칩n y otros datos actuales</li>
            <li>Analizar tendencias hist칩ricas de los 칰ltimos d칤as, semanas o meses</li>
            <li>Comparar condiciones meteorol칩gicas entre diferentes periodos</li>
            <li>Predecir condiciones clim치ticas basado en datos hist칩ricos</li>
          </ul>
          <br>
          <strong>Ejemplos de preguntas:</strong>
          <div class="suggestion">쮺u치l es la temperatura actual?</div>
          <div class="suggestion">쮺칩mo ha sido la humedad esta semana?</div>
          <div class="suggestion">Muestra la tendencia de presi칩n de los 칰ltimos 7 d칤as</div>
        </div>
        <div class="message-time">Ahora</div>
      </div>
    </div>
    
    <div class="chat-input-container">
      <input type="text" id="user-input" placeholder="Escribe tu pregunta sobre el clima...">
      <button id="send-button">Enviar</button>
    </div>
    
    <div class="status-bar">
      <div id="status-indicator" class="status-indicator"></div>
      <span id="status-text">Horus AI esperando tu pregunta...</span>
    </div>
  </main>
</div>

<style>
  /* Estilos para el contenedor del chat */
  .chat-main-container {
    max-width: 900px;
    margin: 0 auto;
    background: var(--card-bg);
    border-radius: var(--border-radius);
    overflow: hidden;
    box-shadow: var(--shadow);
  }

  /* Mensajes del chat */
  .chat-messages {
    height: 60vh;
    overflow-y: auto;
    padding: 15px;
    background: var(--dark-bg);
  }

  .message {
    display: flex;
    margin-bottom: 15px;
    animation: fadeIn 0.3s ease;
  }

  .message.user {
    justify-content: flex-end;
  }

  .message.bot {
    justify-content: flex-start;
  }

  .bot-avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: var(--primary);
    display: flex;
    align-items: center;
    justify-content: center;
    margin-right: 10px;
    flex-shrink: 0;
  }

  .bot-avatar span {
    font-size: 20px;
  }

  .message-content {
    background: var(--card-bg);
    color: var(--text);
    padding: 12px 15px;
    border-radius: 18px;
    max-width: 75%;
    line-height: 1.5;
  }

  .message.user .message-content {
    background: var(--primary);
    color: #000;
    border-bottom-right-radius: 5px;
  }

  .message-time {
    font-size: 11px;
    color: var(--text-secondary);
    margin-top: 5px;
    text-align: right;
    opacity: 0.7;
  }

  /* Barra de entrada */
  .chat-input-container {
    display: flex;
    padding: 10px 15px;
    background: var(--card-bg);
    border-top: 1px solid rgba(255, 255, 255, 0.05);
  }

  .chat-input-container input {
    flex: 1;
    padding: 12px 15px;
    border: none;
    background: var(--dark-bg);
    color: var(--text);
    border-radius: 20px 0 0 20px;
    font-size: 16px;
    outline: none;
    transition: var(--transition);
  }

  .chat-input-container input:focus {
    box-shadow: 0 0 0 2px var(--primary-glow);
  }

  .chat-input-container button {
    background: var(--primary);
    color: #000;
    border: none;
    padding: 12px 20px;
    border-radius: 0 20px 20px 0;
    cursor: pointer;
    font-weight: bold;
    transition: var(--transition);
  }

  .chat-input-container button:hover {
    background: #00d0e0;
    transform: translateY(-2px);
  }

  /* Barra de estado */
  .status-bar {
    padding: 8px 15px;
    background: rgba(0, 0, 0, 0.1);
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .status-indicator {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: #4CAF50;
    box-shadow: 0 0 6px rgba(76, 175, 80, 0.7);
  }

  .status-indicator.error {
    background: #f44336;
    box-shadow: 0 0 6px rgba(244, 67, 54, 0.7);
  }

  /* Sugerencias de preguntas */
  .suggestion {
    background: rgba(255, 255, 255, 0.1);
    padding: 8px 12px;
    border-radius: 12px;
    margin: 5px 0;
    cursor: pointer;
    transition: var(--transition);
  }

  .suggestion:hover {
    background: rgba(0, 234, 255, 0.2);
    transform: translateX(5px);
  }

  /* Efecto de escritura */
  .typing-indicator {
    display: inline-flex;
    gap: 4px;
    margin-right: 8px;
  }

  .typing-indicator span {
    width: 6px;
    height: 6px;
    background: var(--primary);
    border-radius: 50%;
    animation: typing 1s infinite;
  }

  .typing-indicator span:nth-child(2) {
    animation-delay: 0.2s;
  }

  .typing-indicator span:nth-child(3) {
    animation-delay: 0.4s;
  }

  @keyframes typing {
    0%, 100% { transform: translateY(0); opacity: 0.5; }
    50% { transform: translateY(-5px); opacity: 1; }
  }

  /* An치lisis de datos */
  .analysis-header {
    margin-bottom: 15px;
  }

  .analysis-header h2 {
    font-size: 1.2rem;
    margin-bottom: 8px;
    color: var(--primary);
  }

  .analysis-header p {
    color: var(--text-secondary);
    font-size: 0.9rem;
  }

  .statistics-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
    margin-bottom: 20px;
  }

  .stat-item {
    background: rgba(0, 234, 255, 0.1);
    padding: 10px;
    border-radius: 8px;
    text-align: center;
  }

  .stat-value {
    font-size: 1.3rem;
    font-weight: bold;
    color: var(--primary);
    display: block;
    margin-top: 5px;
  }

  .trend-analysis {
    background: rgba(0, 0, 0, 0.2);
    padding: 15px;
    border-radius: 10px;
    margin-top: 15px;
  }

  .trend-analysis h3 {
    margin-top: 0;
    color: var(--primary);
  }

  .trend-description {
    color: var(--text-secondary);
  }

  .prediction-container {
    margin-top: 15px;
  }

  .prediction-reliability {
    margin-bottom: 10px;
    font-size: 0.9rem;
  }

  .reliability-bar {
    height: 6px;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 3px;
    margin-top: 4px;
  }

  .reliability-fill {
    height: 100%;
    background: var(--primary);
    border-radius: 3px;
    transition: width 0.5s ease;
  }

  .prediction-chart-container {
    height: 250px;
    margin-top: 10px;
  }

  .chart-title {
    font-weight: bold;
    margin-bottom: 8px;
    color: var(--primary);
    font-size: 1rem;
  }

  .source-badge {
    display: inline-block;
    margin-left: 5px;
    font-size: 0.8rem;
    opacity: 0.7;
  }

  .welcome-message {
    background: rgba(0, 234, 255, 0.05);
    border-radius: 15px;
    padding: 15px;
    border: 1px solid rgba(0, 234, 255, 0.2);
  }
  
  /* An치lisis detallado */
  .detailed-analysis {
    margin-top: 15px;
    background: rgba(0, 0, 0, 0.1);
    padding: 15px;
    border-radius: 10px;
  }
  
  .detailed-analysis h3 {
    color: var(--primary);
    margin-top: 0;
  }
  
  .detailed-analysis p {
    line-height: 1.6;
    margin-bottom: 10px;
  }
  
  .confidence-indicator {
    display: inline-block;
    background: rgba(76, 175, 80, 0.2);
    color: #4CAF50;
    padding: 2px 8px;
    border-radius: 10px;
    font-size: 0.8rem;
    margin-top: 5px;
  }
</style>

<script>
  // Variables globales
  let historicalData = [];
  let chatbotReady = false;
  let charts = []; // Para almacenar instancias de gr치ficos
  
  // Contexto de conversaci칩n mejorado
  let conversationContext = {
    lastParameter: null,
    lastPeriod: null,
    lastQuestionType: null,
    conversationHistory: [],
    entityContext: {},
    temporalContext: null,
    spatialContext: null,
    confidenceThreshold: 0.65 // Umbral de confianza para aceptar una intenci칩n
  };

  // Elementos del DOM
  const chatMessages = document.getElementById('chat-messages');
  const userInput = document.getElementById('user-input');
  const sendButton = document.getElementById('send-button');
  const statusIndicator = document.getElementById('status-indicator');
  const statusText = document.getElementById('status-text');

  // Actualizar estado
  const updateStatus = (message, isError = false) => {
    statusText.textContent = message;
    if (isError) {
      statusIndicator.classList.add('error');
    } else {
      statusIndicator.classList.remove('error');
    }
  };

  // A침adir mensaje al chat
  const addMessage = (content, isUser = false, source = 'local') => {
    const messageDiv = document.createElement('div');
    messageDiv.classList.add('message');
    messageDiv.classList.add(isUser ? 'user' : 'bot');
    
    // Marca de fuente para mensajes del bot
    const sourceBadge = source !== 'local' 
      ? `<span class="source-badge" title="Informaci칩n obtenida de: ${source}">${source === 'web' ? '游깷' : source}</span>` 
      : '';
      
    if (isUser) {
      messageDiv.innerHTML = `
        <div class="message-content">${content}</div>
        <div class="message-time">${new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</div>
      `;
    } else {
      messageDiv.innerHTML = `
        <div class="bot-avatar"><span>游뱄</span></div>
        <div class="message-content">${content}${sourceBadge}</div>
        <div class="message-time">Ahora</div>
      `;
    }
    
    chatMessages.appendChild(messageDiv);
    chatMessages.scrollTop = chatMessages.scrollHeight;
    
    // Actualizar el tiempo "Ahora" a minutos reales despu칠s de 5 segundos
    setTimeout(() => {
      const timeElement = messageDiv.querySelector('.message-time');
      if (timeElement && timeElement.textContent === 'Ahora') {
        timeElement.textContent = new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
      }
    }, 5000);
    
    // Guardar en historial de conversaci칩n
    if (!isUser) {
      conversationContext.conversationHistory.push({
        role: 'assistant',
        content,
        timestamp: new Date().toISOString()
      });
    }
  };

  // Mostrar estado de carga
  const showLoading = (message = "Analizando tu pregunta") => {
    const loadingId = `loading-${Date.now()}`;
    const loadingDiv = document.createElement('div');
    loadingDiv.id = loadingId;
    loadingDiv.className = 'message bot';
    loadingDiv.innerHTML = `
      <div class="bot-avatar"><span>游뱄</span></div>
      <div class="message-content">
        <div class="typing-indicator"><span></span><span></span><span></span></div>
        <div class="loading-text">${message}</div>
      </div>
      <div class="message-time">Escribiendo...</div>
    `;
    chatMessages.appendChild(loadingDiv);
    chatMessages.scrollTop = chatMessages.scrollHeight;
    return loadingId;
  };

  // Diccionario de sin칩nimos meteorol칩gicos mejorado
  const weatherSynonyms = {
    temperatura: ['temp', 'calor', 'fr칤o', 'frio', 'grados', '춿', 'celsius', 'cent칤grados', 'centigrados', 'term칩metro', 'termometro'],
    humedad: ['hum', 'vapor', 'agua', 'porcentaje de agua', '% agua', 'humedad relativa'],
    presi칩n: ['pres', 'atmosf칠rica', 'barom칠trica', 'barometrica', 'hpa', 'mb', 'presi칩n atmosf칠rica'],
    lluvia: ['precipitaci칩n', 'precipitacion', 'agua', 'llovizna', 'tormenta', 'lluvioso', 'precipitaciones', 'pluviometr칤a', 'pluviometria'],
    viento: ['velocidad del viento', 'r치fagas', 'r치faga', 'r치fagas de viento', 'velocidad viento', 'km/h', 'nudos', 'direcci칩n del viento', 'direccion viento', 'brisa'],
    gas: ['calidad del aire', 'calidad aire', 'contaminaci칩n', 'contaminacion', 'pm2.5', 'pm10', 'part칤culas', 'particulas', 'co2', 'di칩xido de carbono'],
    direcci칩n: ['direccion', 'rumbo', 'orientaci칩n', 'orientacion', 'grados', 'norte', 'sur', 'este', 'oeste', 'cardinal'],
    an치lisis: ['analisis', 'tendencia', 'tendencias', 'evoluci칩n', 'comportamiento', 'patr칩n', 'patron', 'estad칤stica', 'estadisticas'],
    predicci칩n: ['prediccion', 'pron칩stico', 'pronostico', 'previsi칩n', 'prevision', 'futuro', 'ma침ana', 'siguiente', 'proyecci칩n', 'proyeccion'],
    actual: ['ahora', 'en este momento', 'en este instante', 'actualidad', 'presente', 'en directo', 'en tiempo real', 'hoy'],
    hist칩rico: ['historico', 'pasado', 'antes', 'anterior', 'anteriores', 'd칤as anteriores', 'semanas anteriores', '칰ltimos d칤as'],
    comparar: ['comparaci칩n', 'comparar', 'compara', 'diferencia', 'vs', 'versus', 'comparativo', 'entre', 'y'],
    m치ximo: ['maximo', 'm치ximo', 'pico', 'peak', 'm치s alto', 'mayor', 'm치x', 'max'],
    m칤nimo: ['minimo', 'm칤nimo', 'm치s bajo', 'menor', 'm칤n', 'min'],
    tendencia: ['tendencia', 'tendencias', 'evoluci칩n', 'comportamiento', 'patr칩n', 'patron', 'cambios', 'variaci칩n', 'variacion'],
    probabilidad: ['probabilidad', 'probable', 'posibilidad', 'posible', 'chance', 'oportunidad', 'riesgo']
  };

  // Mapeo de intenciones mejorado
  const intentMap = {
    current_data: {
      keywords: ['actual', 'ahora', 'en este momento', 'en directo', 'presente', 'en tiempo real', 'hoy'],
      parameters: ['temperatura', 'humedad', 'presi칩n', 'lluvia', 'viento', 'gas', 'direcci칩n'],
      required: []
    },
    historical_trend: {
      keywords: ['tendencia', 'evoluci칩n', 'comportamiento', 'an치lisis', 'analisis', 'patr칩n', 'patron', 'gr치fico', 'grafico', 'historial', 'historico', 'hist칩rico', 'evolucion', 'variacion'],
      parameters: ['temperatura', 'humedad', 'presi칩n', 'lluvia', 'viento', 'gas'],
      required: ['period']
    },
    prediction: {
      keywords: ['predicci칩n', 'prediccion', 'pron칩stico', 'pronostico', 'previsi칩n', 'prevision', 'futuro', 'ma침ana', 'siguiente', 'proyecci칩n', 'proyeccion', 'probabilidad', 'probable'],
      parameters: ['temperatura', 'humedad', 'presi칩n', 'lluvia', 'viento'],
      required: []
    },
    comparison: {
      keywords: ['comparar', 'comparaci칩n', 'compara', 'diferencia', 'vs', 'versus', 'comparativo', 'entre', 'y', 'diferencia', 'distinto', 'igual'],
      parameters: ['temperatura', 'humedad', 'presi칩n', 'lluvia', 'viento', 'gas'],
      required: ['periods']
    },
    max_min: {
      keywords: ['m치ximo', 'maximo', 'm칤nimo', 'minimo', 'pico', 'peak', 'mayor', 'menor', 'm치s alto', 'm치s bajo', 'm치x', 'max', 'm칤n', 'min'],
      parameters: ['temperatura', 'humedad', 'presi칩n', 'lluvia', 'viento', 'gas'],
      required: ['period']
    },
    correlation: {
      keywords: ['relaci칩n', 'correlaci칩n', 'correlacion', 'conexi칩n', 'conexion', 'asociaci칩n', 'asociacion', 'afecta', 'influye', 'impacto', 'causa', 'provoca'],
      parameters: ['temperatura', 'humedad', 'presi칩n', 'lluvia', 'viento', 'gas'],
      required: ['parameters']
    },
    greeting: {
      keywords: ['hola', 'buenos d칤as', 'buenos dias', 'buenas tardes', 'hey', 'saludos', 'buen d칤a', 'buen dia', 'buenas noches', 'que tal', 'como estas', 'c칩mo est치s'],
      parameters: [],
      required: []
    },
    goodbye: {
      keywords: ['adi칩s', 'adios', 'gracias', 'chao', 'hasta luego', 'hasta pronto', 'nos vemos', 'bye', 'grac칤as', 'gracias', 'fue 칰til', 'fue util'],
      parameters: [],
      required: []
    },
    help: {
      keywords: ['ayuda', 'funciona', 'c칩mo', 'como', 'puedo', 'capaz', 'hacer', 'qu칠', 'que', 'preguntar', 'instrucciones', 'ejemplo', 'ejemplos', 'gu칤a', 'manual', 'tutorial'],
      parameters: [],
      required: []
    },
    unrelated: {
      keywords: [],
      parameters: [],
      required: []
    }
  };

  // Mapeo de periodos
  const periodMap = {
    'hoy': { type: 'day', value: 1, unit: 'day' },
    'ayer': { type: 'day', value: 1, unit: 'day', offset: 1 },
    '칰ltimas 24 horas': { type: 'hour', value: 24, unit: 'hour' },
    '칰ltimas 12 horas': { type: 'hour', value: 12, unit: 'hour' },
    'esta ma침ana': { type: 'morning', value: 1, unit: 'day' },
    'esta tarde': { type: 'afternoon', value: 1, unit: 'day' },
    'esta noche': { type: 'night', value: 1, unit: 'day' },
    'esta semana': { type: 'week', value: 1, unit: 'week' },
    'esta semana pasada': { type: 'week', value: 1, unit: 'week', offset: 1 },
    '칰ltimos 7 d칤as': { type: 'day', value: 7, unit: 'day' },
    '칰ltimos 14 d칤as': { type: 'day', value: 14, unit: 'day' },
    '칰ltimos 30 d칤as': { type: 'day', value: 30, unit: 'day' },
    'este mes': { type: 'month', value: 1, unit: 'month' },
    'este a침o': { type: 'year', value: 1, unit: 'year' },
    '칰ltimo mes': { type: 'month', value: 1, unit: 'month', offset: 1 },
    '칰ltimo a침o': { type: 'year', value: 1, unit: 'year', offset: 1 },
    '칰ltima hora': { type: 'hour', value: 1, unit: 'hour' },
    '칰ltimas 2 horas': { type: 'hour', value: 2, unit: 'hour' },
    '칰ltimas 6 horas': { type: 'hour', value: 6, unit: 'hour' },
    'esta semana': { type: 'week', value: 1, unit: 'week' },
    'esta semana anterior': { type: 'week', value: 1, unit: 'week', offset: 1 },
    'este mes': { type: 'month', value: 1, unit: 'month' },
    'este mes pasado': { type: 'month', value: 1, unit: 'month', offset: 1 },
    'este a침o': { type: 'year', value: 1, unit: 'year' },
    'este a침o pasado': { type: 'year', value: 1, unit: 'year', offset: 1 }
  };

  // Diccionario para correcci칩n ortogr치fica
  const spellingDictionary = {
    'tempertura': 'temperatura',
    'temperaruta': 'temperatura',
    'humedad': 'humedad',
    'humead': 'humedad',
    'umedad': 'humedad',
    'presion': 'presi칩n',
    'presion': 'presi칩n',
    'presion atmosferica': 'presi칩n atmosf칠rica',
    'presion atmosferica': 'presi칩n atmosf칠rica',
    'presion barometrica': 'presi칩n barom칠trica',
    'presion barometrica': 'presi칩n barom칠trica',
    'lluvia': 'lluvia',
    'llubia': 'lluvia',
    'lubia': 'lluvia',
    'viento': 'viento',
    'biento': 'viento',
    'bientto': 'viento',
    'gas': 'gas',
    'calidad del aire': 'calidad del aire',
    'calidad aire': 'calidad del aire',
    'direccion': 'direcci칩n',
    'direccion del viento': 'direcci칩n del viento',
    'direccion viento': 'direcci칩n del viento',
    'termometro': 'term칩metro',
    'termometro': 'term칩metro',
    'pluviometria': 'pluviometr칤a',
    'pluviometria': 'pluviometr칤a',
    'co2': 'CO2',
    'di칩xido de carbono': 'di칩xido de carbono'
  };

  // Sistema de an치lisis sem치ntico mejorado
  const semanticAnalysis = {
    // Analiza el dominio de la pregunta
    analyzeDomain: (text) => {
      const weatherKeywords = [
        'temperatura', 'calor', 'fr칤o', 'frio', 'grados', 
        'humedad', 'agua', 'presi칩n', 'atmosf칠rica', 'barom칠trica',
        'lluvia', 'precipitaci칩n', 'viento', 'r치fagas', 'gas',
        'calidad del aire', 'direcci칩n', 'clima', 'meteorol칩gico',
        'meteorologico', 'tiempo', 'nublado', 'soleado', 'nubes',
        'nuboso', 'llovizna', 'tormenta', 'nublados', 'soleados',
        'nubosos', 'tormentas', 'lluvias', 'vientos', 'r치fagas',
        'caluroso', 'frio', 'fr칤o', 'caliente', 'templado',
        'h칰medo', 'seco', 'h칰medos', 'secos', 'presi칩n',
        'bar칩metro', 'pluvi칩metro', 'anem칩metro', 'term칩metro',
        'meteorolog칤a', 'clim치tico', 'clim치ticos', 'clim치ticas',
        'climatolog칤a', 'pron칩stico', 'pronostico', 'predicci칩n',
        'prediccion', 'previsi칩n', 'prevision', 'estacional',
        'estaciones', 'primavera', 'verano', 'oto침o', 'invierno',
        'norte', 'sur', 'este', 'oeste', 'cardinales', 'brisa',
        'cicl칩n', 'hurac치n', 'tornado', 'tornados', 'ciclones',
        'huracanes', 'tormenta', 'tormentas', 'lluvia', 'lluvias',
        'nublado', 'nublados', 'nuboso', 'nubosos', 'soleado',
        'soleados', 'despejado', 'despejados', 'nublaci칩n',
        'nublaciones', 'precipitaci칩n', 'precipitaciones', 'humedad',
        'relativa', 'relativas', 'humedad relativa', 'presi칩n',
        'atmosf칠rica', 'atmosf칠ricas', 'presi칩n atmosf칠rica',
        'barom칠trica', 'barom칠tricas', 'presi칩n barom칠trica',
        'viento', 'vientos', 'r치faga', 'r치fagas', 'direcci칩n',
        'direcciones', 'direcci칩n del viento', 'velocidad',
        'velocidades', 'velocidad del viento', 'anem칩metro',
        'term칩metro', 'pluvi칩metro', 'bar칩metro', 'higr칩metro',
        'gas', 'gases', 'calidad del aire', 'contaminaci칩n',
        'contaminacion', 'pm2.5', 'pm10', 'part칤culas', 'particulas',
        'co2', 'di칩xido de carbono', 'ozono', 'no2', 'so2'
      ];
      
      let matchCount = 0;
      let totalKeywords = 0;
      const normalizedText = text.toLowerCase();
      
      weatherKeywords.forEach(keyword => {
        if (normalizedText.includes(keyword)) {
          matchCount++;
        }
        totalKeywords++;
      });
      
      // Calcular confianza basada en la proporci칩n de coincidencias
      const confidence = Math.min(1.0, matchCount / Math.max(1, totalKeywords * 0.15));
      
      // Si encontramos al menos 1 palabra clave meteorol칩gica, es una pregunta sobre clima
      return {
        isWeatherQuestion: matchCount > 0,
        confidence: confidence,
        matchCount: matchCount,
        totalKeywords: totalKeywords
      };
    },
    
    // Identifica entidades en el texto
    identifyEntities: (text) => {
      const entities = {
        parameters: [],
        periods: [],
        locations: [],
        numbers: [],
        comparisons: [],
        operations: []
      };
      
      const normalizedText = text.toLowerCase();
      
      // Identificar par치metros meteorol칩gicos
      Object.keys(weatherSynonyms).forEach(param => {
        // Verificar el par치metro principal
        if (normalizedText.includes(param)) {
          entities.parameters.push(param);
        }
        
        // Verificar sin칩nimos
        weatherSynonyms[param].forEach(synonym => {
          if (normalizedText.includes(synonym)) {
            entities.parameters.push(param);
          }
        });
      });
      
      // Identificar periodos
      Object.keys(periodMap).forEach(period => {
        if (normalizedText.includes(period)) {
          entities.periods.push(period);
        }
      });
      
      // Identificar n칰meros
      const numberMatches = text.match(/\d+/g);
      if (numberMatches) {
        entities.numbers = numberMatches.map(num => parseInt(num));
      }
      
      // Identificar comparaciones
      if (normalizedText.includes('vs') || normalizedText.includes('versus')) {
        entities.comparisons.push('vs');
      }
      if (normalizedText.includes('tendencia') || normalizedText.includes('evoluci칩n')) {
        entities.comparisons.push('trend');
      }
      if (normalizedText.includes('correlaci칩n') || normalizedText.includes('relaci칩n')) {
        entities.comparisons.push('correlation');
      }
      
      // Identificar operaciones
      if (normalizedText.includes('m치ximo') || normalizedText.includes('maximo')) {
        entities.operations.push('max');
      }
      if (normalizedText.includes('m칤nimo') || normalizedText.includes('minimo')) {
        entities.operations.push('min');
      }
      if (normalizedText.includes('promedio') || normalizedText.includes('media')) {
        entities.operations.push('average');
      }
      if (normalizedText.includes('diferencia')) {
        entities.operations.push('difference');
      }
      
      // Eliminar duplicados
      entities.parameters = [...new Set(entities.parameters)];
      entities.periods = [...new Set(entities.periods)];
      entities.comparisons = [...new Set(entities.comparisons)];
      entities.operations = [...new Set(entities.operations)];
      
      return entities;
    },
    
    // Analiza la intenci칩n del usuario
    analyzeIntent: (text, entities, domainAnalysis) => {
      let bestIntent = null;
      let highestConfidence = 0;
      
      // Si es una pregunta meteorol칩gica, analizar intenciones meteorol칩gicas
      if (domainAnalysis.isWeatherQuestion) {
        // Analizar cada posible intenci칩n
        Object.keys(intentMap).forEach(intentType => {
          if (intentType === 'unrelated') return; // Saltar la intenci칩n unrelated en este paso
          
          const intent = intentMap[intentType];
          let confidence = 0;
          
          // Calcular coincidencia con palabras clave
          intent.keywords.forEach(keyword => {
            if (text.toLowerCase().includes(keyword)) {
              confidence += 0.2;
            }
          });
          
          // Aumentar confianza si se encontraron par치metros relevantes
          if (entities.parameters.length > 0 && intent.parameters.length > 0) {
            const commonParams = entities.parameters.filter(p => intent.parameters.includes(p));
            confidence += commonParams.length * 0.15;
          }
          
          // Aumentar confianza si se encontraron periodos y la intenci칩n los requiere
          if (intent.required.includes('period') && entities.periods.length > 0) {
            confidence += 0.2;
          }
          
          // Aumentar confianza si se encontraron m칰ltiples periodos y la intenci칩n los requiere
          if (intent.required.includes('periods') && entities.periods.length > 1) {
            confidence += 0.25;
          }
          
          // Aumentar confianza si se encontraron operaciones espec칤ficas
          if (intentType === 'max_min' && entities.operations.includes('max')) {
            confidence += 0.15;
          }
          if (intentType === 'max_min' && entities.operations.includes('min')) {
            confidence += 0.15;
          }
          
          // Ajustar confianza seg칰n el dominio
          confidence *= domainAnalysis.confidence;
          
          // Verificar si es la mejor intenci칩n hasta ahora
          if (confidence > highestConfidence) {
            highestConfidence = confidence;
            bestIntent = {
              type: intentType,
              confidence: confidence,
              parameters: entities.parameters,
              periods: entities.periods
            };
          }
        });
      }
      
      // Si no se encontr칩 una intenci칩n clara, verificar saludos, despedidas o ayuda
      if (!bestIntent || highestConfidence < 0.4) {
        if (this.isGreeting(text)) {
          return { type: 'greeting', confidence: 0.9, parameters: [], periods: [] };
        }
        if (this.isGoodbye(text)) {
          return { type: 'goodbye', confidence: 0.9, parameters: [], periods: [] };
        }
        if (this.isHelpRequest(text)) {
          return { type: 'help', confidence: 0.8, parameters: [], periods: [] };
        }
      }
      
      // Si no se encontr칩 una intenci칩n clara pero hay par치metros, asumir que es una consulta actual
      if (!bestIntent && entities.parameters.length > 0) {
        return {
          type: 'current_data',
          confidence: 0.7,
          parameters: entities.parameters,
          periods: ['hoy']
        };
      }
      
      // Si no se encontr칩 una intenci칩n clara pero hay periodos, asumir an치lisis hist칩rico
      if (!bestIntent && entities.periods.length > 0) {
        return {
          type: 'historical_trend',
          confidence: 0.65,
          parameters: entities.parameters.length > 0 ? entities.parameters : ['temperatura'],
          periods: entities.periods
        };
      }
      
      // Si no se encontr칩 una intenci칩n clara pero hay comparaciones, asumir comparaci칩n
      if (!bestIntent && entities.comparisons.length > 0) {
        return {
          type: 'comparison',
          confidence: 0.6,
          parameters: entities.parameters.length > 0 ? entities.parameters : ['temperatura'],
          periods: entities.periods.length >= 2 ? entities.periods.slice(0, 2) : 
                  (entities.periods.length === 1 ? [entities.periods[0], 'hoy'] : ['esta semana', 'hoy'])
        };
      }
      
      // Si hay par치metros pero no intenci칩n clara, intentar determinar la intenci칩n
      if (entities.parameters.length > 0 && !bestIntent) {
        // Si hay palabras como "m치ximo" o "m칤nimo", asumir max_min
        if (text.toLowerCase().includes('m치ximo') || text.toLowerCase().includes('maximo') ||
            text.toLowerCase().includes('m칤nimo') || text.toLowerCase().includes('minimo')) {
          return {
            type: 'max_min',
            confidence: 0.55,
            parameters: entities.parameters,
            periods: entities.periods.length > 0 ? entities.periods : ['칰ltimos 7 d칤as']
          };
        }
        
        // Si hay palabras como "tendencia" o "evoluci칩n", asumir historical_trend
        if (text.toLowerCase().includes('tendencia') || text.toLowerCase().includes('evoluci칩n') ||
            text.toLowerCase().includes('analizar') || text.toLowerCase().includes('analisis')) {
          return {
            type: 'historical_trend',
            confidence: 0.5,
            parameters: entities.parameters,
            periods: entities.periods.length > 0 ? entities.periods : ['칰ltimos 7 d칤as']
          };
        }
        
        // Si hay palabras como "ma침ana" o "futuro", asumir prediction
        if (text.toLowerCase().includes('ma침ana') || text.toLowerCase().includes('futuro') ||
            text.toLowerCase().includes('pr칩ximo') || text.toLowerCase().includes('siguiente')) {
          return {
            type: 'prediction',
            confidence: 0.5,
            parameters: entities.parameters,
            periods: []
          };
        }
        
        // Por defecto, asumir consulta actual
        return {
          type: 'current_data',
          confidence: 0.45,
          parameters: entities.parameters,
          periods: ['hoy']
        };
      }
      
      return bestIntent || { type: 'unrelated', confidence: 0, parameters: [], periods: [] };
    },
    
    // Verifica si es un saludo
    isGreeting: (text) => {
      const greetings = intentMap.greeting.keywords;
      const normalizedText = text.toLowerCase();
      
      return greetings.some(greeting => normalizedText.includes(greeting));
    },
    
    // Verifica si es una despedida
    isGoodbye: (text) => {
      const goodbyes = intentMap.goodbye.keywords;
      const normalizedText = text.toLowerCase();
      
      return goodbyes.some(goodbye => normalizedText.includes(goodbye));
    },
    
    // Verifica si es una solicitud de ayuda
    isHelpRequest: (text) => {
      const helpKeywords = intentMap.help.keywords;
      const normalizedText = text.toLowerCase();
      
      return helpKeywords.some(keyword => normalizedText.includes(keyword));
    },
    
    // Analiza preguntas compuestas
    analyzeCompoundQuestions: (text) => {
      const compoundIndicators = ['y', 'adem치s', 'tambi칠n', 'tambien', 'ademas', 'adem치s de', 'ademas de', 'adem치s que', 'ademas que'];
      return compoundIndicators.some(indicator => text.toLowerCase().includes(indicator));
    },
    
    // Analiza referencias en el contexto
    analyzeReferences: (text, context) => {
      const references = {
        parameters: [],
        temporal: [],
        spatial: []
      };
      
      // Analizar an치foras (referencias a elementos previos)
      if (context.lastParameter && (text.includes('eso') || text.includes('eso es') || text.includes('eso est치'))) {
        references.parameters.push(context.lastParameter);
      }
      
      if (context.lastPeriod && (text.includes('entonces') || text.includes('en ese periodo') || text.includes('durante ese tiempo'))) {
        references.temporal.push(context.lastPeriod);
      }
      
      return references;
    },
    
    // Resuelve an치foras usando el contexto
    resolveAnaphora: (text, context) => {
      let resolvedText = text;
      const paramName = context.lastParameter || 'temperatura';
      
      // Reemplazar "eso" si hay contexto de par치metro
      if (context.lastParameter) {
        resolvedText = resolvedText.replace(/eso/g, paramName);
        resolvedText = resolvedText.replace(/eso es/g, `${paramName} es`);
        resolvedText = resolvedText.replace(/eso est치/g, `${paramName} est치`);
      }
      
      // Reemplazar "hoy" si hay contexto temporal
      if (context.temporalContext && (text.includes('ayer') || text.includes('ma침ana'))) {
        // Si el contexto es "hoy", y pregunta sobre "ayer", ajustamos
        if (context.temporalContext === 'today' && text.includes('ayer')) {
          resolvedText = resolvedText.replace(/ayer/g, 'hace un d칤a');
        }
      }
      
      // Mejora: Reemplazar "la" + sustantivo por el par치metro espec칤fico
      if (context.lastParameter) {
        const paramReplacements = {
          'temp': ['la temperatura', 'el term칩metro', 'los grados', 'el calor', 'el fr칤o'],
          'humedad': ['la humedad', 'el vapor', 'el agua'],
          'presi칩n': ['la presi칩n', 'la atmosf칠rica', 'la barom칠trica'],
          'lluvia': ['la lluvia', 'la precipitaci칩n', 'el agua'],
          'viento': ['el viento', 'las r치fagas', 'la brisa'],
          'gas': ['el gas', 'la calidad del aire', 'las part칤culas']
        };
        
        if (paramReplacements[paramName]) {
          paramReplacements[paramName].forEach(replacement => {
            resolvedText = resolvedText.replace(new RegExp(replacement, 'gi'), paramName);
          });
        }
      }
      
      return resolvedText;
    },
    
    // Analiza preguntas hipot칠ticas
    analyzeHypotheticals: (text) => {
      const hypotheticalIndicators = ['si', 'supongamos que', 'imagina que', 'qu칠 pasar칤a si', 'que pasaria si', 'que pasar칤a si'];
      return hypotheticalIndicators.some(indicator => text.toLowerCase().includes(indicator));
    }
  };

  // Sistema de correcci칩n ortogr치fica CORREGIDO
  const spellingCorrection = {
    // Calcula la distancia de Levenshtein entre dos strings
    levenshteinDistance: function(a, b) {
      if (a.length === 0) return b.length;
      if (b.length === 0) return a.length;
      
      const matrix = [];
      
      for (let i = 0; i <= b.length; i++) {
        matrix[i] = [i];
      }
      
      for (let j = 0; j <= a.length; j++) {
        matrix[0][j] = j;
      }
      
      for (let i = 1; i <= b.length; i++) {
        for (let j = 1; j <= a.length; j++) {
          if (b.charAt(i - 1) === a.charAt(j - 1)) {
            matrix[i][j] = matrix[i - 1][j - 1];
          } else {
            matrix[i][j] = Math.min(
              matrix[i - 1][j - 1] + 1, // Sustituci칩n
              matrix[i][j - 1] + 1, // Inserci칩n
              matrix[i - 1][j] + 1 // Eliminaci칩n
            );
          }
        }
      }
      
      return matrix[b.length][a.length];
    },
    
    // Corrige la ortograf칤a de una palabra
    correctWord: function(word) {
      // Si la palabra est치 en el diccionario, devolver la correcci칩n
      if (spellingDictionary[word.toLowerCase()]) {
        return spellingDictionary[word.toLowerCase()];
      }
      
      // Buscar en el diccionario de sin칩nimos
      for (const [correct, synonyms] of Object.entries(weatherSynonyms)) {
        for (const synonym of synonyms) {
          if (word.toLowerCase() === synonym) {
            return correct;
          }
          
          // Calcular distancia de Levenshtein para correcci칩n aproximada
          const distance = this.levenshteinDistance(word.toLowerCase(), synonym);
          if (distance <= Math.max(1, Math.floor(synonym.length * 0.2))) {
            return correct;
          }
        }
      }
      
      return word;
    },
    
    // Corrige todo el mensaje
    correctMessage: function(message) {
      const words = message.split(/\s+/);
      let correctedWords = [];
      let foundCorrection = false;
      
      words.forEach(word => {
        // Mantener signos de puntuaci칩n
        const cleanWord = word.replace(/[.,!?;:]/g, '');
        const punctuation = word.match(/[.,!?;:]+$/);
        
        if (cleanWord.length > 2) {
          // CORRECCI칍N: Usar spellingCorrection.correctWord en lugar de this.correctWord
          const corrected = spellingCorrection.correctWord(cleanWord);
          if (corrected !== cleanWord) {
            correctedWords.push(corrected + (punctuation ? punctuation[0] : ''));
            foundCorrection = true;
          } else {
            correctedWords.push(word);
          }
        } else {
          correctedWords.push(word);
        }
      });
      
      return {
        correctedMessage: correctedWords.join(' '),
        hasCorrection: foundCorrection
      };
    }
  };

  // Cargar datos hist칩ricos (simulaci칩n)
  const loadHistoricalData = async () => {
    updateStatus("Cargando datos hist칩ricos...");
    
    return new Promise((resolve) => {
      // Simulaci칩n de carga de datos
      setTimeout(() => {
        // Generar datos simulados para los 칰ltimos 30 d칤as
        const now = new Date();
        historicalData = [];
        
        for (let i = 29; i >= 0; i--) {
          const date = new Date(now);
          date.setDate(now.getDate() - i);
          
          historicalData.push({
            timestamp: date.toISOString(),
            temp: 20 + Math.random() * 10 - 5 * (i/30),
            hum: 60 + Math.random() * 20 - 10 * (i/30),
            pres: 1013 + Math.random() * 5 - 2 * (i/30),
            lluvia: i < 5 ? 1 : 0,
            wind: 5 + Math.random() * 10,
            wind_dir: Math.floor(Math.random() * 360),
            gas: 1.0 + Math.random() * 0.5
          });
        }
        
        resolve();
      }, 800);
    });
  };

  // Manejadores de intenciones
  const intentHandlers = {
    current_data: (entities, context) => {
      // Si no hay par치metros espec칤ficos, usar el 칰ltimo par치metro mencionado o uno por defecto
      let parameters = entities.parameters.length > 0 ? entities.parameters : 
                      (context.lastParameter ? [context.lastParameter] : ['temperatura']);
      
      // Actualizar contexto
      conversationContext.lastParameter = parameters[0];
      conversationContext.lastQuestionType = 'current_data';
      
      // Obtener el dato actual
      const latestData = historicalData[historicalData.length - 1];
      let response = '';
      
      parameters.forEach(param => {
        switch(param) {
          case 'temperatura':
            response += `La temperatura actual es de ${latestData.temp.toFixed(1)}춿C.\n`;
            break;
          case 'humedad':
            response += `La humedad actual es del ${latestData.hum.toFixed(0)}%.\n`;
            break;
          case 'presi칩n':
            response += `La presi칩n atmosf칠rica actual es de ${latestData.pres.toFixed(0)} hPa.\n`;
            break;
          case 'lluvia':
            response += `Actualmente ${latestData.lluvia ? 'est치 lloviendo' : 'no est치 lloviendo'}.\n`;
            break;
          case 'viento':
            response += `La velocidad del viento actual es de ${latestData.wind.toFixed(1)} m/s (${(latestData.wind * 3.6).toFixed(1)} km/h).\n`;
            break;
          case 'gas':
            response += `El nivel de gas actual es de ${latestData.gas.toFixed(2)} k풜.\n`;
            break;
          case 'direcci칩n':
            const directions = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'];
            const index = Math.round((latestData.wind_dir % 360) / 22.5) % 16;
            response += `La direcci칩n del viento actual es ${directions[index]} (${latestData.wind_dir}춿).\n`;
            break;
        }
      });
      
      // A침adir an치lisis contextual si es relevante
      if (parameters.length === 1) {
        const paramName = parameters[0];
        let contextAnalysis = '';
        
        switch(paramName) {
          case 'temperatura':
            if (latestData.temp > 25) {
              contextAnalysis = `Con esta temperatura, podr칤as considerar usar ropa ligera y mantenerse hidratado.`;
            } else if (latestData.temp < 10) {
              contextAnalysis = `Con esta temperatura, te recomendamos abrigarte adecuadamente para evitar el fr칤o.`;
            }
            break;
          case 'humedad':
            if (latestData.hum > 70) {
              contextAnalysis = `La alta humedad puede hacer que la temperatura se sienta m치s alta de lo que realmente es.`;
            } else if (latestData.hum < 30) {
              contextAnalysis = `La baja humedad puede causar sequedad en la piel y las v칤as respiratorias.`;
            }
            break;
          case 'presi칩n':
            if (latestData.pres < 1000) {
              contextAnalysis = `La presi칩n atmosf칠rica baja suele indicar condiciones clim치ticas inestables.`;
            } else if (latestData.pres > 1020) {
              contextAnalysis = `La presi칩n atmosf칠rica alta suele indicar condiciones clim치ticas estables y buen tiempo.`;
            }
            break;
        }
        
        if (contextAnalysis) {
          response += `\n${contextAnalysis}`;
        }
        
        response += `\n\n쯊e gustar칤a ver un an치lisis hist칩rico de ${paramName} o una predicci칩n para los pr칩ximos d칤as?`;
      }
      
      return response.trim();
    },
    
    historical_trend: (entities, context) => {
      // Determinar el periodo
      let period = entities.periods.length > 0 ? entities.periods[0] : 
                  (context.lastPeriod ? context.lastPeriod : '칰ltimos 7 d칤as');
      
      // Actualizar contexto
      conversationContext.lastPeriod = period;
      conversationContext.lastQuestionType = 'historical_trend';
      
      // Obtener datos para el periodo
      const periodInfo = periodMap[period] || periodMap['칰ltimos 7 d칤as'];
      const now = new Date();
      let startDate;
      
      if (periodInfo.type === 'day') {
        startDate = new Date(now);
        startDate.setDate(now.getDate() - periodInfo.value);
      } else if (periodInfo.type === 'week') {
        startDate = new Date(now);
        startDate.setDate(now.getDate() - (periodInfo.value * 7));
      } else if (periodInfo.type === 'month') {
        startDate = new Date(now);
        startDate.setMonth(now.getMonth() - periodInfo.value);
      }
      
      // Si no hay par치metros espec칤ficos, usar el 칰ltimo par치metro mencionado o uno por defecto
      let parameters = entities.parameters.length > 0 ? entities.parameters : 
                      (context.lastParameter ? [context.lastParameter] : ['temperatura']);
      
      // Preparar datos para el gr치fico
      const chartData = historicalData
        .filter(data => new Date(data.timestamp) >= startDate)
        .map(data => ({
          x: new Date(data.timestamp),
          y: data[parameters[0] === 'presi칩n' ? 'pres' : 
                 parameters[0] === 'lluvia' ? 'lluvia' : 
                 parameters[0]]
        }));
      
      // Generar la respuesta basada en el an치lisis de los datos
      const response = analyzeData(parameters[0], chartData, periodInfo);
      
      // A침ade un gr치fico de an치lisis
      const chartId = `prediction-chart-${Date.now()}`;
      const chartResponse = `
        <div class="prediction-chart-container">
          <div class="chart-title">Tendencia de ${parameters[0]} en ${period}</div>
          <canvas class="prediction-chart" id="${chartId}" 
                  data-parameter="${parameters[0]}" 
                  data-chart-data='${JSON.stringify(chartData)}'></canvas>
        </div>
      `;
      
      return response + chartResponse;
    },
    
    prediction: (entities, context) => {
      // Si no hay par치metros espec칤ficos, usar el 칰ltimo par치metro mencionado o uno por defecto
      let parameters = entities.parameters.length > 0 ? entities.parameters : 
                      (context.lastParameter ? [context.lastParameter] : ['temperatura']);
      
      // Actualizar contexto
      conversationContext.lastParameter = parameters[0];
      conversationContext.lastQuestionType = 'prediction';
      
      // Generar datos de predicci칩n simulados
      const predictionData = [];
      const now = new Date();
      const latestData = historicalData[historicalData.length - 1];
      
      for (let i = 0; i < 5; i++) {
        const date = new Date(now);
        date.setDate(now.getDate() + i);
        
        let value;
        switch(parameters[0]) {
          case 'temperatura':
            value = latestData.temp + (Math.random() - 0.5) * 3;
            break;
          case 'humedad':
            value = latestData.hum + (Math.random() - 0.5) * 10;
            break;
          case 'presi칩n':
            value = latestData.pres + (Math.random() - 0.5) * 3;
            break;
          case 'viento':
            value = latestData.wind + (Math.random() - 0.5) * 2;
            break;
          default:
            value = latestData.temp + (Math.random() - 0.5) * 3;
        }
        
        predictionData.push({
          x: date,
          y: value
        });
      }
      
      // Generar respuesta
      let response = '';
      const nextDay = new Date(now);
      nextDay.setDate(now.getDate() + 1);
      
      switch(parameters[0]) {
        case 'temperatura':
          response = `Para ma침ana ${nextDay.toLocaleDateString('es-ES', { weekday: 'long' })}, la temperatura se espera que est칠 entre ${(latestData.temp - 1).toFixed(1)}춿C y ${(latestData.temp + 2).toFixed(1)}춿C.\n\n`;
          response += `La tendencia a corto plazo sugiere ${latestData.temp < predictionData[1].y ? 'un aumento' : 'una disminuci칩n'} en la temperatura.\n\n`;
          break;
        case 'humedad':
          response = `Para ma침ana ${nextDay.toLocaleDateString('es-ES', { weekday: 'long' })}, la humedad se espera que est칠 alrededor del ${(latestData.hum + (Math.random() * 5 - 2.5)).toFixed(0)}%.\n\n`;
          response += `La tendencia a corto plazo sugiere ${latestData.hum < predictionData[1].y ? 'un aumento' : 'una disminuci칩n'} en la humedad.\n\n`;
          break;
        case 'presi칩n':
          response = `Para ma침ana ${nextDay.toLocaleDateString('es-ES', { weekday: 'long' })}, la presi칩n atmosf칠rica se espera que est칠 alrededor de ${(latestData.pres + (Math.random() * 3 - 1.5)).toFixed(0)} hPa.\n\n`;
          response += `La tendencia a corto plazo sugiere ${latestData.pres < predictionData[1].y ? 'un aumento' : 'una disminuci칩n'} en la presi칩n.\n\n`;
          break;
        case 'viento':
          response = `Para ma침ana ${nextDay.toLocaleDateString('es-ES', { weekday: 'long' })}, la velocidad del viento se espera que est칠 alrededor de ${(latestData.wind + (Math.random() * 2 - 1)).toFixed(1)} m/s.\n\n`;
          response += `La tendencia a corto plazo sugiere ${latestData.wind < predictionData[1].y ? 'un aumento' : 'una disminuci칩n'} en la velocidad del viento.\n\n`;
          break;
        default:
          response = `Para ma침ana ${nextDay.toLocaleDateString('es-ES', { weekday: 'long' })}, se espera que ${parameters[0]} muestre una tendencia ${latestData.temp < predictionData[1].y ? 'ascendente' : 'descendente'}.\n\n`;
      }
      
      response += `Esta predicci칩n se basa en el an치lisis de los datos hist칩ricos de los 칰ltimos 30 d칤as y tiene una confiabilidad estimada del 75%.`;
      
      // A침ade un gr치fico de predicci칩n
      const chartId = `prediction-chart-${Date.now()}`;
      const reliability = 75;
      
      const chartResponse = `
        <div class="prediction-container">
          <div class="prediction-reliability">
            Confiabilidad de la predicci칩n: ${reliability}% 
            <div class="reliability-bar">
              <div class="reliability-fill" style="width: ${reliability}%"></div>
            </div>
          </div>
          <div class="prediction-chart-container">
            <div class="chart-title">Predicci칩n de ${parameters[0]} para los pr칩ximos 5 d칤as</div>
            <canvas class="prediction-chart" id="${chartId}" 
                    data-parameter="${parameters[0]}" 
                    data-chart-data='${JSON.stringify(predictionData)}'></canvas>
          </div>
        </div>
      `;
      
      return response + chartResponse;
    },
    
    comparison: (entities, context) => {
      // Necesitamos al menos dos periodos para comparar
      if (entities.periods.length < 2) {
        return "Para hacer una comparaci칩n necesito dos periodos. Por ejemplo: 'Compara la temperatura de esta semana con la semana pasada'.";
      }
      
      const period1 = entities.periods[0];
      const period2 = entities.periods[1];
      
      // Actualizar contexto
      conversationContext.lastPeriod = period1;
      conversationContext.lastQuestionType = 'comparison';
      
      // Si no hay par치metros espec칤ficos, usar el 칰ltimo par치metro mencionado o uno por defecto
      let parameters = entities.parameters.length > 0 ? entities.parameters : 
                      (context.lastParameter ? [context.lastParameter] : ['temperatura']);
      
      // Obtener datos para ambos periodos
      const periodInfo1 = periodMap[period1] || periodMap['esta semana'];
      const periodInfo2 = periodMap[period2] || periodMap['칰ltimos 7 d칤as'];
      
      const now = new Date();
      let startDate1, startDate2;
      
      // Calcular fechas de inicio para ambos periodos
      if (periodInfo1.type === 'day') {
        startDate1 = new Date(now);
        startDate1.setDate(now.getDate() - periodInfo1.value);
      } else if (periodInfo1.type === 'week') {
        startDate1 = new Date(now);
        startDate1.setDate(now.getDate() - (periodInfo1.value * 7));
      } else if (periodInfo1.type === 'month') {
        startDate1 = new Date(now);
        startDate1.setMonth(now.getMonth() - periodInfo1.value);
      }
      
      if (periodInfo2.type === 'day') {
        startDate2 = new Date(now);
        startDate2.setDate(now.getDate() - periodInfo2.value);
      } else if (periodInfo2.type === 'week') {
        startDate2 = new Date(now);
        startDate2.setDate(now.getDate() - (periodInfo2.value * 7));
      } else if (periodInfo2.type === 'month') {
        startDate2 = new Date(now);
        startDate2.setMonth(now.getMonth() - periodInfo2.value);
      }
      
      // Obtener datos para ambos periodos
      const data1 = historicalData.filter(data => new Date(data.timestamp) >= startDate1);
      const data2 = historicalData.filter(data => new Date(data.timestamp) >= startDate2);
      
      // Calcular promedios
      const avg1 = data1.reduce((sum, item) => sum + item[parameters[0] === 'presi칩n' ? 'pres' : 
                                     parameters[0] === 'lluvia' ? 'lluvia' : 
                                     parameters[0]], 0) / data1.length;
      const avg2 = data2.reduce((sum, item) => sum + item[parameters[0] === 'presi칩n' ? 'pres' : 
                                     parameters[0] === 'lluvia' ? 'lluvia' : 
                                     parameters[0]], 0) / data2.length;
      
      // Generar respuesta
      let response = `Comparaci칩n de ${parameters[0]} entre ${period1} y ${period2}:\n\n`;
      
      response += `* ${period1.charAt(0).toUpperCase() + period1.slice(1)}: ${avg1.toFixed(2)}`;
      if (parameters[0] !== 'lluvia' && parameters[0] !== 'direcci칩n') {
        response += ` ${parameters[0] === 'presi칩n' ? 'hPa' : 
                    parameters[0] === 'humedad' ? '%' : 
                    '춿C'}`;
      }
      response += `\n`;
      
      response += `* ${period2.charAt(0).toUpperCase() + period2.slice(1)}: ${avg2.toFixed(2)}`;
      if (parameters[0] !== 'lluvia' && parameters[0] !== 'direcci칩n') {
        response += ` ${parameters[0] === 'presi칩n' ? 'hPa' : 
                    parameters[0] === 'humedad' ? '%' : 
                    '춿C'}`;
      }
      response += `\n\n`;
      
      const difference = avg1 - avg2;
      if (Math.abs(difference) > 0.01) {
        const percentChange = (Math.abs(difference) / avg2) * 100;
        if (difference > 0) {
          response += `La ${parameters[0]} fue ${percentChange.toFixed(1)}% mayor en ${period1} que en ${period2}.`;
        } else {
          response += `La ${parameters[0]} fue ${percentChange.toFixed(1)}% menor en ${period1} que en ${period2}.`;
        }
      } else {
        response += `La ${parameters[0]} fue muy similar en ambos periodos.`;
      }
      
      // Preparar datos para el gr치fico comparativo
      const chartData1 = data1.map(data => ({
        x: new Date(data.timestamp),
        y: data[parameters[0] === 'presi칩n' ? 'pres' : 
               parameters[0] === 'lluvia' ? 'lluvia' : 
               parameters[0]]
      }));
      
      const chartData2 = data2.map(data => ({
        x: new Date(data.timestamp),
        y: data[parameters[0] === 'presi칩n' ? 'pres' : 
               parameters[0] === 'lluvia' ? 'lluvia' : 
               parameters[0]]
      }));
      
      // A침ade un gr치fico comparativo
      const chartId = `comparison-chart-${Date.now()}`;
      const chartResponse = `
        <div class="comparison-chart-container">
          <div class="chart-title">Comparaci칩n de ${parameters[0]}: ${period1} vs ${period2}</div>
          <canvas class="comparison-chart" id="${chartId}" 
                  data-parameter="${parameters[0]}" 
                  data-chart-data1='${JSON.stringify(chartData1)}'
                  data-chart-data2='${JSON.stringify(chartData2)}'
                  data-period1="${period1}"
                  data-period2="${period2}"></canvas>
        </div>
      `;
      
      return response + chartResponse;
    },
    
    max_min: (entities, context) => {
      // Determinar el periodo
      let period = entities.periods.length > 0 ? entities.periods[0] : 
                  (context.lastPeriod ? context.lastPeriod : '칰ltimos 7 d칤as');
      
      // Actualizar contexto
      conversationContext.lastPeriod = period;
      conversationContext.lastQuestionType = 'max_min';
      
      // Obtener datos para el periodo
      const periodInfo = periodMap[period] || periodMap['칰ltimos 7 d칤as'];
      const now = new Date();
      let startDate;
      
      if (periodInfo.type === 'day') {
        startDate = new Date(now);
        startDate.setDate(now.getDate() - periodInfo.value);
      } else if (periodInfo.type === 'week') {
        startDate = new Date(now);
        startDate.setDate(now.getDate() - (periodInfo.value * 7));
      } else if (periodInfo.type === 'month') {
        startDate = new Date(now);
        startDate.setMonth(now.getMonth() - periodInfo.value);
      }
      
      // Si no hay par치metros espec칤ficos, usar el 칰ltimo par치metro mencionado o uno por defecto
      let parameters = entities.parameters.length > 0 ? entities.parameters : 
                      (context.lastParameter ? [context.lastParameter] : ['temperatura']);
      
      // Obtener datos para el periodo
      const periodData = historicalData.filter(data => new Date(data.timestamp) >= startDate);
      
      // Encontrar m치ximos y m칤nimos
      let max = -Infinity;
      let min = Infinity;
      let maxDate, minDate;
      
      periodData.forEach(data => {
        const value = data[parameters[0] === 'presi칩n' ? 'pres' : 
                         parameters[0] === 'lluvia' ? 'lluvia' : 
                         parameters[0]];
                         
        if (value > max) {
          max = value;
          maxDate = data.timestamp;
        }
        
        if (value < min) {
          min = value;
          minDate = data.timestamp;
        }
      });
      
      // Generar respuesta
      let response = `En ${period}, el valor m치ximo de ${parameters[0]} fue de ${max.toFixed(2)}`;
      
      if (parameters[0] !== 'lluvia' && parameters[0] !== 'direcci칩n') {
        response += ` ${parameters[0] === 'presi칩n' ? 'hPa' : 
                    parameters[0] === 'humedad' ? '%' : 
                    '춿C'}`;
      }
      
      response += ` registrado el ${new Date(maxDate).toLocaleDateString('es-ES', { 
        weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' 
      })}.\n\n`;
      
      response += `El valor m칤nimo fue de ${min.toFixed(2)}`;
      
      if (parameters[0] !== 'lluvia' && parameters[0] !== 'direcci칩n') {
        response += ` ${parameters[0] === 'presi칩n' ? 'hPa' : 
                    parameters[0] === 'humedad' ? '%' : 
                    '춿C'}`;
      }
      
      response += ` registrado el ${new Date(minDate).toLocaleDateString('es-ES', { 
        weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' 
      })}.`;
      
      // Preparar datos para el gr치fico
      const chartData = historicalData
        .filter(data => new Date(data.timestamp) >= startDate)
        .map(data => ({
          x: new Date(data.timestamp),
          y: data[parameters[0] === 'presi칩n' ? 'pres' : 
                 parameters[0] === 'lluvia' ? 'lluvia' : 
                 parameters[0]]
        }));
      
      // A침ade un gr치fico con marcadores de m치ximos y m칤nimos
      const chartId = `extremes-chart-${Date.now()}`;
      const chartResponse = `
        <div class="extremes-chart-container">
          <div class="chart-title">Valores extremos de ${parameters[0]} en ${period}</div>
          <canvas class="extremes-chart" id="${chartId}" 
                  data-parameter="${parameters[0]}" 
                  data-chart-data='${JSON.stringify(chartData)}'
                  data-max-date="${maxDate}"
                  data-min-date="${minDate}"></canvas>
        </div>
      `;
      
      return response + chartResponse;
    },
    
    correlation: (entities, context) => {
      try {
        // Necesitamos al menos dos par치metros para analizar correlaci칩n
        if (entities.parameters.length < 2) {
          return "Para analizar correlaci칩n necesito dos par치metros meteorol칩gicos. Por ejemplo: '쮺칩mo se relaciona la temperatura con la humedad?'";
        }
        
        const parameter1 = entities.parameters[0];
        const parameter2 = entities.parameters[1];
        
        // Actualizar contexto
        conversationContext.lastParameter = parameter1;
        conversationContext.lastQuestionType = 'correlation';
        
        // Obtener datos para el periodo (usar 칰ltimos 30 d칤as por defecto)
        const now = new Date();
        const startDate = new Date(now);
        startDate.setDate(now.getDate() - 30);
        
        const periodData = historicalData.filter(data => new Date(data.timestamp) >= startDate);
        
        // Calcular correlaci칩n
        const values1 = periodData.map(data => 
          data[parameter1 === 'presi칩n' ? 'pres' : 
              parameter1 === 'lluvia' ? 'lluvia' : 
              parameter1]
        );
        
        const values2 = periodData.map(data => 
          data[parameter2 === 'presi칩n' ? 'pres' : 
              parameter2 === 'lluvia' ? 'lluvia' : 
              parameter2]
        );
        
        // Calcular media
        const mean1 = values1.reduce((a, b) => a + b, 0) / values1.length;
        const mean2 = values2.reduce((a, b) => a + b, 0) / values2.length;
        
        // Calcular covarianza y desviaci칩n est치ndar
        let covariance = 0;
        let stdDev1 = 0;
        let stdDev2 = 0;
        
        for (let i = 0; i < values1.length; i++) {
          const diff1 = values1[i] - mean1;
          const diff2 = values2[i] - mean2;
          
          covariance += diff1 * diff2;
          stdDev1 += diff1 * diff1;
          stdDev2 += diff2 * diff2;
        }
        
        covariance /= values1.length;
        stdDev1 = Math.sqrt(stdDev1 / values1.length);
        stdDev2 = Math.sqrt(stdDev2 / values1.length);
        
        // Calcular coeficiente de correlaci칩n de Pearson
        const correlationCoefficient = covariance / (stdDev1 * stdDev2);
        
        // Generar respuesta basada en el coeficiente
        let response = `<div class="detailed-analysis">`;
        response += `<h3>An치lisis de Correlaci칩n</h3>`;
        
        // Mapear nombres de par치metros a t칠rminos m치s descriptivos
        const paramNameMap = {
          'temperatura': 'la temperatura',
          'humedad': 'la humedad',
          'presi칩n': 'la presi칩n atmosf칠rica',
          'lluvia': 'la lluvia',
          'viento': 'la velocidad del viento',
          'gas': 'el nivel de gas'
        };
        
        const param1Name = paramNameMap[parameter1] || parameter1;
        const param2Name = paramNameMap[parameter2] || parameter2;
        
        response += `<p>He analizado la relaci칩n entre ${param1Name} y ${param2Name} durante los 칰ltimos 30 d칤as.</p>`;
        
        // Interpretar el coeficiente de correlaci칩n
        if (Math.abs(correlationCoefficient) > 0.7) {
          response += `<p>Existe una <strong>fuerte correlaci칩n</strong> entre estos dos par치metros, con un coeficiente de ${correlationCoefficient.toFixed(2)}.</p>`;
        } else if (Math.abs(correlationCoefficient) > 0.4) {
          response += `<p>Existe una <strong>correlaci칩n moderada</strong> entre estos dos par치metros, con un coeficiente de ${correlationCoefficient.toFixed(2)}.</p>`;
        } else if (Math.abs(correlationCoefficient) > 0.2) {
          response += `<p>Existe una <strong>ligera correlaci칩n</strong> entre estos dos par치metros, con un coeficiente de ${correlationCoefficient.toFixed(2)}.</p>`;
        } else {
          response += `<p>No hay una correlaci칩n significativa entre estos dos par치metros, con un coeficiente de ${correlationCoefficient.toFixed(2)}.</p>`;
        }
        
        // Interpretaci칩n contextual
        if (correlationCoefficient > 0.5) {
          response += `<p>Esto significa que cuando ${param1Name} aumenta, ${param2Name} tiende a aumentar tambi칠n.</p>`;
        } else if (correlationCoefficient < -0.5) {
          response += `<p>Esto significa que cuando ${param1Name} aumenta, ${param2Name} tiende a disminuir.</p>`;
        } else {
          response += `<p>Los cambios en ${param1Name} no parecen tener una relaci칩n clara con los cambios en ${param2Name}.</p>`;
        }
        
        // Informaci칩n adicional basada en pares espec칤ficos
        if ((parameter1 === 'temperatura' && parameter2 === 'humedad') || 
            (parameter1 === 'humedad' && parameter2 === 'temperatura')) {
          if (correlationCoefficient < 0) {
            response += `<p>Es com칰n observar una correlaci칩n negativa entre temperatura y humedad, ya que el aire caliente puede contener m치s vapor de agua, pero la humedad relativa disminuye a medida que la temperatura aumenta.</p>`;
          }
        }
        
        if ((parameter1 === 'presi칩n' && parameter2 === 'lluvia') || 
            (parameter1 === 'lluvia' && parameter2 === 'presi칩n')) {
          if (correlationCoefficient < 0) {
            response += `<p>Es t칤pico observar que la presi칩n atmosf칠rica baja antes de una lluvia, lo que explica la correlaci칩n negativa.</p>`;
          }
        }
        
        if ((parameter1 === 'temperatura' && parameter2 === 'presi칩n') || 
            (parameter1 === 'presi칩n' && parameter2 === 'temperatura')) {
          if (Math.abs(correlationCoefficient) < 0.3) {
            response += `<p>La temperatura y la presi칩n atmosf칠rica suelen tener una relaci칩n compleja que depende de muchos factores, por lo que no siempre se observa una correlaci칩n clara.</p>`;
          }
        }
        
        // A침adir informaci칩n de confianza
        const confidence = Math.min(1, Math.abs(correlationCoefficient) * 0.8 + 0.2);
        response += `<div class="confidence-indicator">Confianza del an치lisis: ${(confidence * 100).toFixed(0)}%</div>`;
        
        // Preparar datos para el gr치fico
        const chartData = periodData.map((data, index) => ({
          x: new Date(data.timestamp),
          y1: data[parameter1 === 'presi칩n' ? 'pres' : 
                 parameter1 === 'lluvia' ? 'lluvia' : 
                 parameter1],
          y2: data[parameter2 === 'presi칩n' ? 'pres' : 
                 parameter2 === 'lluvia' ? 'lluvia' : 
                 parameter2]
        }));
        
        // A침ade un gr치fico de correlaci칩n
        const chartId = `correlation-chart-${Date.now()}`;
        response += `
          <div class="prediction-chart-container">
            <div class="chart-title">Relaci칩n entre ${parameter1} y ${parameter2}</div>
            <canvas class="prediction-chart" id="${chartId}" 
                    data-parameter1="${parameter1}"
                    data-parameter2="${parameter2}"
                    data-chart-data='${JSON.stringify(chartData)}'></canvas>
          </div>
        `;
        
        response += `</div>`;
        
        return response;
      } catch (error) {
        console.error('Error en an치lisis de correlaci칩n:', error);
        return "丘멆잺 Ocurri칩 un error al analizar la correlaci칩n. Por favor, intenta nuevamente.";
      }
    },
    
    greeting: () => {
      const hours = new Date().getHours();
      let greeting;
      
      if (hours < 12) {
        greeting = "춰Buenos d칤as! ";
      } else if (hours < 18) {
        greeting = "춰Buenas tardes! ";
      } else {
        greeting = "춰Buenas noches! ";
      }
      
      return `${greeting}Soy Horus AI, tu asistente meteorol칩gico especializado. 쮼n qu칠 puedo ayudarte hoy?`;
    },
    
    goodbye: () => {
      return "춰Hasta luego! No dudes en volver si necesitas m치s informaci칩n meteorol칩gica.";
    },
    
    help: () => {
      return `Puedo ayudarte con consultas meteorol칩gicas como:\n\n` +
             `- Consultar datos actuales: "쮺u치l es la temperatura ahora?"\n` +
             `- Analizar tendencias hist칩ricas: "Muestra la tendencia de humedad esta semana"\n` +
             `- Comparar periodos: "Compara la presi칩n de esta semana con la semana pasada"\n` +
             `- Predecir condiciones: "쯈u칠 tiempo har치 ma침ana?"\n` +
             `- Encontrar valores extremos: "쮺u치l fue la temperatura m치xima esta semana?"\n` +
             `- Analizar correlaciones: "쮺칩mo se relaciona la temperatura con la humedad?"\n\n` +
             `쯉obre qu칠 par치metro meteorol칩gico te gustar칤a obtener informaci칩n?`;
    },
    
    unrelated: (entities, context) => {
      return "No estoy seguro de entender tu pregunta. Soy un asistente meteorol칩gico especializado. 쯇odr칤as reformular tu pregunta relacionada con el clima o las condiciones atmosf칠ricas? Por ejemplo, puedes preguntar sobre temperatura, humedad, presi칩n atmosf칠rica o viento.";
    }
  };

  // Analiza los datos para generar una respuesta descriptiva
  const analyzeData = (parameter, chartData, periodInfo) => {
    if (chartData.length === 0) {
      return "No hay datos disponibles para el periodo seleccionado.";
    }
    
    // Calcular estad칤sticas
    const values = chartData.map(item => item.y);
    const sum = values.reduce((a, b) => a + b, 0);
    const average = sum / values.length;
    const max = Math.max(...values);
    const min = Math.min(...values);
    
    // Determinar tendencia
    const startValue = values[0];
    const endValue = values[values.length - 1];
    const trend = endValue > startValue ? "ascendente" : "descendente";
    const trendStrength = Math.abs(endValue - startValue) / startValue;
    
    // Generar respuesta
    let response = `<div class="detailed-analysis">`;
    response += `<h3>An치lisis de ${parameter.charAt(0).toUpperCase() + parameter.slice(1)}</h3>`;
    
    // Descripci칩n general
    response += `<p>En el periodo seleccionado (${periodInfo.type === 'day' ? periodInfo.value + ' d칤as' : periodInfo.type}):</p>`;
    response += `<div class="statistics-grid">`;
    response += `<div class="stat-item"><strong>Promedio</strong><br><span class="stat-value">${average.toFixed(1)}`;
    if (parameter !== 'lluvia' && parameter !== 'direcci칩n') {
      response += ` ${parameter === 'presi칩n' ? 'hPa' : 
                  parameter === 'humedad' ? '%' : 
                  '춿C'}`;
    }
    response += `</span></div>`;
    
    response += `<div class="stat-item"><strong>M치ximo</strong><br><span class="stat-value">${max.toFixed(1)}`;
    if (parameter !== 'lluvia' && parameter !== 'direcci칩n') {
      response += ` ${parameter === 'presi칩n' ? 'hPa' : 
                  parameter === 'humedad' ? '%' : 
                  '춿C'}`;
    }
    response += `</span></div>`;
    
    response += `<div class="stat-item"><strong>M칤nimo</strong><br><span class="stat-value">${min.toFixed(1)}`;
    if (parameter !== 'lluvia' && parameter !== 'direcci칩n') {
      response += ` ${parameter === 'presi칩n' ? 'hPa' : 
                  parameter === 'humedad' ? '%' : 
                  '춿C'}`;
    }
    response += `</span></div>`;
    response += `</div>`;
    
    // An치lisis de tendencia
    if (trendStrength > 0.05) { // Si hay una tendencia significativa
      response += `<div class="trend-analysis">`;
      response += `<h3>Tendencia</h3>`;
      response += `<p>La tendencia es claramente ${trend} (${(trendStrength * 100).toFixed(1)}% de cambio).</p>`;
      
      if (parameter === 'temperatura') {
        response += trend === 'ascendente' ? 
          '<p>Esto sugiere un calentamiento progresivo en el periodo analizado. Podr칤as considerar ajustar tu ropa o planificar actividades al aire libre en los momentos m치s frescos del d칤a.</p>' :
          '<p>Esto sugiere un enfriamiento progresivo en el periodo analizado. Podr칤as considerar abrigarte adecuadamente para las actividades al aire libre.</p>';
      } else if (parameter === 'humedad') {
        response += trend === 'ascendente' ? 
          '<p>El aumento de humedad podr칤a indicar mayor probabilidad de precipitaci칩n. Considera llevar paraguas si planeas estar al aire libre.</p>' :
          '<p>La disminuci칩n de humedad sugiere condiciones m치s secas. Podr칤as necesitar hidratarte m치s frecuentemente.</p>';
      } else if (parameter === 'presi칩n') {
        response += trend === 'ascendente' ? 
          '<p>El aumento de presi칩n suele indicar condiciones clim치ticas estables y buen tiempo. Es un buen momento para actividades al aire libre.</p>' :
          '<p>La disminuci칩n de presi칩n suele preceder a condiciones clim치ticas inestables. Podr칤as considerar prepararte para posibles cambios en el clima.</p>';
      }
      
      response += `</div>`;
    } else {
      response += `<div class="trend-analysis">`;
      response += `<h3>Tendencia</h3>`;
      response += `<p>La tendencia es relativamente estable sin cambios significativos.</p>`;
      response += `<p>Las condiciones meteorol칩gicas permanecen consistentes durante el periodo analizado.</p>`;
      response += `</div>`;
    }
    
    // A침adir informaci칩n contextual adicional
    response += `<div class="trend-analysis">`;
    response += `<h3>Recomendaciones</h3>`;
    
    switch(parameter) {
      case 'temperatura':
        if (average > 25) {
          response += `<p>Con temperaturas promedio por encima de 25춿C, te recomendamos usar ropa ligera y mantener una buena hidrataci칩n.</p>`;
        } else if (average < 10) {
          response += `<p>Con temperaturas promedio por debajo de 10춿C, te recomendamos abrigarte adecuadamente para protegerte del fr칤o.</p>`;
        } else {
          response += `<p>Las temperaturas est치n dentro de un rango moderado. Considera vestir capas de ropa para adaptarte a los cambios durante el d칤a.</p>`;
        }
        break;
      case 'humedad':
        if (average > 70) {
          response += `<p>La alta humedad puede hacer que la temperatura se sienta m치s alta de lo que realmente es. Considera usar ropa transpirable.</p>`;
        } else if (average < 30) {
          response += `<p>La baja humedad puede causar sequedad en la piel y las v칤as respiratorias. Considera usar humectante y mantenerte hidratado.</p>`;
        } else {
          response += `<p>La humedad est치 en un nivel moderado, lo que suele ser c칩modo para la mayor칤a de las personas.</p>`;
        }
        break;
      case 'presi칩n':
        if (average < 1000) {
          response += `<p>La presi칩n atmosf칠rica baja suele indicar condiciones clim치ticas inestables. Mantente atento a posibles cambios en el clima.</p>`;
        } else if (average > 1020) {
          response += `<p>La presi칩n atmosf칠rica alta suele indicar condiciones clim치ticas estables y buen tiempo. Es un buen momento para actividades al aire libre.</p>`;
        } else {
          response += `<p>La presi칩n atmosf칠rica est치 en un nivel normal, indicando condiciones clim치ticas estables.</p>`;
        }
        break;
    }
    
    response += `</div>`;
    response += `</div>`;
    
    return response;
  };

  // Renderizar gr치ficos
  const renderChart = (parameter, chartData, chartId) => {
    const chartCtx = document.getElementById(chartId)?.getContext('2d');
    if (!chartCtx) return;
    
    // Determina el nombre del par치metro y colores
    let paramName = '';
    let color = '#4a90e2';
    let unit = '';
    
    switch (parameter) {
      case 'temperatura':
        paramName = 'Temperatura';
        color = '#FF6384';
        unit = '춿C';
        break;
      case 'humedad':
        paramName = 'Humedad';
        color = '#36A2EB';
        unit = '%';
        break;
      case 'presi칩n':
        paramName = 'Presi칩n Atmosf칠rica';
        color = '#FFCE56';
        unit = 'hPa';
        break;
      case 'lluvia':
        paramName = 'Precipitaci칩n';
        color = '#46BFBD';
        unit = 'Presencia';
        break;
      case 'viento':
        paramName = 'Viento';
        color = '#C9CBCF';
        unit = 'm/s';
        break;
      case 'gas':
        paramName = 'Nivel de Gas';
        color = '#FDB45C';
        unit = 'k풜';
        break;
      case 'direcci칩n':
        paramName = 'Direcci칩n del Viento';
        color = '#9966FF';
        unit = '춿';
        break;
      default:
        paramName = 'Medici칩n';
        unit = '';
    }
    
    // Crea el nuevo gr치fico
    const chart = new Chart(chartCtx, {
      type: 'line',
      data: {
        datasets: [{
          label: paramName,
          data: chartData,
          borderColor: color,
          backgroundColor: `${color}40`,
          borderWidth: 3,
          tension: 0.3,
          pointRadius: 3
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            display: false
          },
          tooltip: {
            mode: 'index',
            intersect: false
          }
        },
        scales: {
          x: {
            type: 'time',
            time: {
              unit: 'day'
            },
            title: {
              display: true,
              text: 'Fecha'
            }
          },
          y: {
            beginAtZero: false,
            title: {
              display: true,
              text: unit
            }
          }
        }
      }
    });
    
    // Almacenar instancia del gr치fico para actualizarla al cambiar de tema
    charts.push(chart);
  };
  
  // Renderizar gr치ficos de comparaci칩n
  const renderComparisonChart = (parameter, chartData1, chartData2, period1, period2, chartId) => {
    const chartCtx = document.getElementById(chartId)?.getContext('2d');
    if (!chartCtx) return;
    
    // Determina el nombre del par치metro y colores
    let paramName = '';
    let color1 = '#FF6384';
    let color2 = '#36A2EB';
    let unit = '';
    
    switch (parameter) {
      case 'temperatura':
        paramName = 'Temperatura';
        unit = '춿C';
        break;
      case 'humedad':
        paramName = 'Humedad';
        unit = '%';
        break;
      case 'presi칩n':
        paramName = 'Presi칩n Atmosf칠rica';
        unit = 'hPa';
        break;
      case 'lluvia':
        paramName = 'Precipitaci칩n';
        unit = 'Presencia';
        break;
      case 'viento':
        paramName = 'Viento';
        unit = 'm/s';
        break;
      case 'gas':
        paramName = 'Nivel de Gas';
        unit = 'k풜';
        break;
      case 'direcci칩n':
        paramName = 'Direcci칩n del Viento';
        unit = '춿';
        break;
      default:
        paramName = 'Medici칩n';
        unit = '';
    }
    
    // Crea el nuevo gr치fico
    const chart = new Chart(chartCtx, {
      type: 'line',
      data: {
        datasets: [
          {
            label: period1,
            data: chartData1,
            borderColor: color1,
            backgroundColor: `${color1}40`,
            borderWidth: 3,
            tension: 0.3,
            pointRadius: 3
          },
          {
            label: period2,
            data: chartData2,
            borderColor: color2,
            backgroundColor: `${color2}40`,
            borderWidth: 3,
            tension: 0.3,
            pointRadius: 3
          }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            position: 'top'
          },
          tooltip: {
            mode: 'index',
            intersect: false
          }
        },
        scales: {
          x: {
            type: 'time',
            time: {
              unit: 'day'
            },
            title: {
              display: true,
              text: 'Fecha'
            }
          },
          y: {
            beginAtZero: false,
            title: {
              display: true,
              text: unit
            }
          }
        }
      }
    });
    
    // Almacenar instancia del gr치fico para actualizarla al cambiar de tema
    charts.push(chart);
  };

  // Renderizar gr치ficos de extremos
  const renderExtremesChart = (parameter, chartData, maxDate, minDate, chartId) => {
    const chartCtx = document.getElementById(chartId)?.getContext('2d');
    if (!chartCtx) return;
    
    // Determina el nombre del par치metro y colores
    let paramName = '';
    let color = '#4a90e2';
    let unit = '';
    
    switch (parameter) {
      case 'temperatura':
        paramName = 'Temperatura';
        color = '#FF6384';
        unit = '춿C';
        break;
      case 'humedad':
        paramName = 'Humedad';
        color = '#36A2EB';
        unit = '%';
        break;
      case 'presi칩n':
        paramName = 'Presi칩n Atmosf칠rica';
        color = '#FFCE56';
        unit = 'hPa';
        break;
      case 'lluvia':
        paramName = 'Precipitaci칩n';
        color = '#46BFBD';
        unit = 'Presencia';
        break;
      case 'viento':
        paramName = 'Viento';
        color = '#C9CBCF';
        unit = 'm/s';
        break;
      case 'gas':
        paramName = 'Nivel de Gas';
        color = '#FDB45C';
        unit = 'k풜';
        break;
      case 'direcci칩n':
        paramName = 'Direcci칩n del Viento';
        color = '#9966FF';
        unit = '춿';
        break;
      default:
        paramName = 'Medici칩n';
        unit = '';
    }
    
    // Preparar datos con marcadores para m치ximos y m칤nimos
    const dataWithMarkers = chartData.map(item => ({
      x: item.x,
      y: item.y,
      pointBackgroundColor: item.x.toISOString() === maxDate || item.x.toISOString() === minDate ? 
                            (item.x.toISOString() === maxDate ? '#FF0000' : '#0000FF') : 
                            color
    }));
    
    // Crea el nuevo gr치fico
    const chart = new Chart(chartCtx, {
      type: 'line',
      data: {
        datasets: [{
          label: paramName,
          data: dataWithMarkers,
          borderColor: color,
          backgroundColor: `${color}40`,
          borderWidth: 3,
          tension: 0.3,
          pointRadius: function(context) {
            const index = context.dataIndex;
            const value = context.dataset.data[index];
            return value.pointBackgroundColor !== color ? 6 : 3;
          },
          pointBackgroundColor: function(context) {
            const index = context.dataIndex;
            const value = context.dataset.data[index];
            return value.pointBackgroundColor;
          }
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            display: false
          },
          tooltip: {
            mode: 'index',
            intersect: false
          }
        },
        scales: {
          x: {
            type: 'time',
            time: {
              unit: 'day'
            },
            title: {
              display: true,
              text: 'Fecha'
            }
          },
          y: {
            beginAtZero: false,
            title: {
              display: true,
              text: unit
            }
          }
        }
      }
    });
    
    // Almacenar instancia del gr치fico para actualizarla al cambiar de tema
    charts.push(chart);
  };

  // Renderizar gr치ficos de correlaci칩n
  const renderCorrelationChart = (parameter1, parameter2, chartData, chartId) => {
    const chartCtx = document.getElementById(chartId)?.getContext('2d');
    if (!chartCtx) return;
    
    // Determina los nombres de los par치metros y colores
    let paramName1 = '';
    let paramName2 = '';
    let color1 = '#FF6384';
    let color2 = '#36A2EB';
    let unit1 = '';
    let unit2 = '';
    
    const getParameterInfo = (parameter) => {
      switch (parameter) {
        case 'temperatura':
          return { name: 'Temperatura', color: '#FF6384', unit: '춿C' };
        case 'humedad':
          return { name: 'Humedad', color: '#36A2EB', unit: '%' };
        case 'presi칩n':
          return { name: 'Presi칩n Atmosf칠rica', color: '#FFCE56', unit: 'hPa' };
        case 'lluvia':
          return { name: 'Precipitaci칩n', color: '#46BFBD', unit: 'Presencia' };
        case 'viento':
          return { name: 'Viento', color: '#C9CBCF', unit: 'm/s' };
        case 'gas':
          return { name: 'Nivel de Gas', color: '#FDB45C', unit: 'k풜' };
        case 'direcci칩n':
          return { name: 'Direcci칩n del Viento', color: '#9966FF', unit: '춿' };
        default:
          return { name: 'Medici칩n', color: '#4a90e2', unit: '' };
      }
    };
    
    const info1 = getParameterInfo(parameter1);
    const info2 = getParameterInfo(parameter2);
    
    paramName1 = info1.name;
    color1 = info1.color;
    unit1 = info1.unit;
    
    paramName2 = info2.name;
    color2 = info2.color;
    unit2 = info2.unit;
    
    // Crea el nuevo gr치fico
    const chart = new Chart(chartCtx, {
      type: 'line',
      data: {
        datasets: [
          {
            label: paramName1,
            data: chartData.map(item => ({ x: item.x, y: item.y1 })),
            borderColor: color1,
            backgroundColor: `${color1}40`,
            borderWidth: 3,
            tension: 0.3,
            pointRadius: 3
          },
          {
            label: paramName2,
            data: chartData.map(item => ({ x: item.x, y: item.y2 })),
            borderColor: color2,
            backgroundColor: `${color2}40`,
            borderWidth: 3,
            tension: 0.3,
            pointRadius: 3
          }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            position: 'top'
          },
          tooltip: {
            mode: 'index',
            intersect: false
          }
        },
        scales: {
          x: {
            type: 'time',
            time: {
              unit: 'day'
            },
            title: {
              display: true,
              text: 'Fecha'
            }
          },
          y: {
            beginAtZero: false,
            title: {
              display: true,
              text: `${unit1} / ${unit2}`
            }
          }
        }
      }
    });
    
    // Almacenar instancia del gr치fico para actualizarla al cambiar de tema
    charts.push(chart);
  };

  // Procesar mensaje del usuario
  const processUserMessage = async (message) => {
    // Guardar en historial de conversaci칩n
    conversationContext.conversationHistory.push({
      role: 'user',
      content: message,
      timestamp: new Date().toISOString()
    });
    
    // Corregir ortograf칤a
    const { correctedMessage, hasCorrection } = spellingCorrection.correctMessage(message);
    
    // Mostrar mensaje de correcci칩n SOLO si hubo correcciones significativas
    if (hasCorrection) {
      addMessage(`游댌 Entiendo que quiz치s quisiste decir: "${correctedMessage}"`, false);
    }
    
    // Normalizar mensaje
    const normalizedMessage = correctedMessage.toLowerCase().replace(/[.,!?]/g, '');
    
    // An치lisis de 치mbito
    const domainAnalysis = semanticAnalysis.analyzeDomain(normalizedMessage);
    
    // Verificar referencias
    const references = semanticAnalysis.analyzeReferences(normalizedMessage, conversationContext);
    
    // Resolver an치foras
    const resolvedMessage = semanticAnalysis.resolveAnaphora(normalizedMessage, conversationContext);
    
    // Verificar si es hipot칠tica
    const isHypothetical = semanticAnalysis.analyzeHypotheticals(normalizedMessage);
    
    // Identificar entidades
    const entities = semanticAnalysis.identifyEntities(resolvedMessage);
    
    // Analizar intenci칩n
    const intent = semanticAnalysis.analyzeIntent(resolvedMessage, entities, domainAnalysis);
    
    // Verificar preguntas compuestas
    const isCompoundQuestion = semanticAnalysis.analyzeCompoundQuestions(normalizedMessage);
    
    // Entidades para la respuesta
    const detectedEntities = {
      parameters: entities.parameters,
      temporal: entities.periods,
      comparisons: entities.comparisons,
      operations: entities.operations
    };
    
    // Actualizar contexto temporal si se identifica uno
    if (entities.periods.length > 0) {
      conversationContext.temporalContext = entities.periods[0];
    }
    
    // Actualizar contexto de par치metros si se identifican
    if (entities.parameters.length > 0) {
      conversationContext.lastParameter = entities.parameters[0];
    }
    
    // Si hay referencias, actualizar contexto
    if (references.parameters.length > 0) {
      conversationContext.lastParameter = references.parameters[0];
    }
    
    // Si hay contexto de par치metro pero no se identific칩 en la pregunta, usar el contexto
    if (conversationContext.lastParameter && entities.parameters.length === 0) {
      entities.parameters = [conversationContext.lastParameter];
    }
    
    // Si hay contexto temporal pero no se identific칩 en la pregunta, usar el contexto
    if (conversationContext.lastPeriod && entities.periods.length === 0) {
      entities.periods = [conversationContext.lastPeriod];
    }
    
    try {
      // Procesar seg칰n la intenci칩n detectada
      if (intent && intent.confidence >= conversationContext.confidenceThreshold) {
        // Manejar intenci칩n reconocida
        if (intentHandlers[intent.type]) {
          return intentHandlers[intent.type](entities, conversationContext);
        }
      }
      
      // Si no se reconoci칩 la intenci칩n pero es una pregunta meteorol칩gica
      if (domainAnalysis.isWeatherQuestion) {
        // Intentar identificar par치metros incluso sin intenci칩n clara
        if (entities.parameters.length > 0) {
          // Si hay par치metros pero no intenci칩n clara, asumir consulta actual
          return intentHandlers.current_data({
            parameters: entities.parameters,
            periods: ['hoy']
          }, conversationContext);
        }
        
        // Si hay periodos pero no par치metros, pedir aclaraci칩n
        if (entities.periods.length > 0) {
          return "Para poder ayudarte, necesito saber qu칠 par치metro meteorol칩gico te interesa. Por ejemplo: 'temperatura', 'humedad' o 'presi칩n'.";
        }
      }
      
      // Si es un saludo aunque no se haya detectado claramente
      if (semanticAnalysis.isGreeting(normalizedMessage)) {
        return intentHandlers.greeting();
      }
      
      // Si es una despedida aunque no se haya detectado claramente
      if (semanticAnalysis.isGoodbye(normalizedMessage)) {
        return intentHandlers.goodbye();
      }
      
      // Si es una solicitud de ayuda aunque no se haya detectado claramente
      if (semanticAnalysis.isHelpRequest(normalizedMessage)) {
        return intentHandlers.help();
      }
      
      // Si no se identifica un 치mbito espec칤fico
      if (!domainAnalysis.isWeatherQuestion) {
        if (normalizedMessage.includes('pol칤tica') || normalizedMessage.includes('politica')) {
          return "Soy un asistente meteorol칩gico especializado. Para informaci칩n pol칤tica, te recomiendo consultar fuentes especializadas en pol칤tica y actualidad.";
        }
        if (normalizedMessage.includes('religi칩n') || normalizedMessage.includes('religion')) {
          return "Soy un asistente meteorol칩gico especializado. Para informaci칩n sobre religi칩n, te recomiendo consultar fuentes especializadas en este tema.";
        }
      }
      
      // Si es una pregunta hipot칠tica
      if (isHypothetical) {
        return "Como asistente meteorol칩gico, solo puedo proporcionar informaci칩n basada en datos reales y an치lisis hist칩ricos. No puedo especular sobre escenarios hipot칠ticos que no est칠n respaldados por datos clim치ticos.";
      }
      
      // Si es una pregunta compuesta
      if (isCompoundQuestion) {
        return "Para poder ayudarte mejor, por favor divide tu pregunta en partes m치s espec칤ficas. Por ejemplo, en lugar de preguntar sobre varios par치metros a la vez, enf칩cate en uno primero.";
      }
      
      // Si hay entidades detectadas pero no intenci칩n clara
      if (detectedEntities.parameters.length > 0 || 
          detectedEntities.temporal.length > 0 || 
          detectedEntities.comparisons.length > 0) {
        let response = "He detectado algunos elementos relevantes en tu pregunta, pero no estoy seguro de entender exactamente qu칠 necesitas.\n\n";
        
        if (detectedEntities.parameters.length > 0) {
          response += `* Par치metros meteorol칩gicos: ${detectedEntities.parameters.join(', ')}\n`;
        }
        if (detectedEntities.temporal.length > 0) {
          response += `* Periodos de tiempo: ${detectedEntities.temporal.join(', ')}\n`;
        }
        if (detectedEntities.comparisons.length > 0) {
          response += `* Tipos de comparaci칩n: ${detectedEntities.comparisons.map(c => 
            c === 'vs' ? 'comparaci칩n directa' : 
            c === 'trend' ? 'tendencia' : 
            c === 'correlation' ? 'correlaci칩n' : c).join(', ')}\n`;
        }
        if (detectedEntities.operations.length > 0) {
          response += `* Operaciones solicitadas: ${detectedEntities.operations.join(', ')}\n`;
        }
        
        response += `\n쯇odr칤as reformular tu pregunta para que sea m치s espec칤fica?`;
        
        return response;
      }
      
      // Si no hay contexto previo y no es claramente fuera de 치mbito, asumimos que es general
      return "No estoy seguro de entender tu pregunta. Soy un asistente meteorol칩gico especializado. 쯇odr칤as reformular tu pregunta relacionada con el clima o las condiciones atmosf칠ricas? Por ejemplo, puedes preguntar sobre temperatura, humedad, presi칩n atmosf칠rica o viento.";
      
    } catch (error) {
      console.error('Error procesando mensaje:', error);
      return "丘멆잺 Ocurri칩 un error al procesar tu solicitud. Por favor, intenta nuevamente.";
    }
  };

  // Enviar mensaje
  const sendMessage = async () => {
    const message = userInput.value.trim();
    if (message === '' || !chatbotReady) return;
    
    // A침ade mensaje del usuario
    addMessage(message, true);
    userInput.value = '';
    
    // Muestra "escribiendo..."
    const loadingId = showLoading();
    
    try {
      // Procesa el mensaje
      const response = await processUserMessage(message);
      
      // Remueve el mensaje de "escribiendo..."
      document.getElementById(loadingId).remove();
      
      // Muestra la respuesta
      addMessage(response, false, 'local');
      
      // Renderizar gr치ficos si existen
      setTimeout(() => {
        document.querySelectorAll('.prediction-chart').forEach(canvas => {
          const parameter = canvas.dataset.parameter;
          const chartData = JSON.parse(canvas.dataset.chartData);
          renderChart(parameter, chartData, canvas.id);
        });
        
        document.querySelectorAll('.comparison-chart').forEach(canvas => {
          const parameter = canvas.dataset.parameter;
          const chartData1 = JSON.parse(canvas.dataset.chartData1);
          const chartData2 = JSON.parse(canvas.dataset.chartData2);
          const period1 = canvas.dataset.period1;
          const period2 = canvas.dataset.period2;
          renderComparisonChart(parameter, chartData1, chartData2, period1, period2, canvas.id);
        });
        
        document.querySelectorAll('.extremes-chart').forEach(canvas => {
          const parameter = canvas.dataset.parameter;
          const chartData = JSON.parse(canvas.dataset.chartData);
          const maxDate = canvas.dataset.maxDate;
          const minDate = canvas.dataset.minDate;
          renderExtremesChart(parameter, chartData, maxDate, minDate, canvas.id);
        });
        
        document.querySelectorAll('.correlation-chart').forEach(canvas => {
          const parameter1 = canvas.dataset.parameter1;
          const parameter2 = canvas.dataset.parameter2;
          const chartData = JSON.parse(canvas.dataset.chartData);
          renderCorrelationChart(parameter1, parameter2, chartData, canvas.id);
        });
      }, 100);
      
    } catch (error) {
      console.error('Error procesando mensaje:', error);
      document.getElementById(loadingId).remove();
      addMessage("丘멆잺 Ocurri칩 un error al procesar tu solicitud. Por favor, intenta nuevamente.", false);
    }
  };

  // Inicializar chatbot
  const initChatbot = async () => {
    try {
      // Carga datos hist칩ricos
      await loadHistoricalData();
      
      chatbotReady = true;
      
      // Configurar sugerencias
      document.querySelectorAll('.suggestion').forEach(suggestion => {
        suggestion.addEventListener('click', () => {
          userInput.value = suggestion.textContent;
          sendMessage();
        });
      });
      
      // Hacer disponible para main.js
      window.updateChatbotCharts = () => {
        // Destruir y recrear los gr치ficos para actualizar colores
        charts.forEach(chart => {
          if (chart && chart.destroy) {
            chart.destroy();
          }
        });
        charts = [];
        
        // Volver a renderizar todos los gr치ficos
        setTimeout(() => {
          document.querySelectorAll('.prediction-chart').forEach(canvas => {
            const parameter = canvas.dataset.parameter;
            const chartData = JSON.parse(canvas.dataset.chartData);
            renderChart(parameter, chartData, canvas.id);
          });
          
          document.querySelectorAll('.comparison-chart').forEach(canvas => {
            const parameter = canvas.dataset.parameter;
            const chartData1 = JSON.parse(canvas.dataset.chartData1);
            const chartData2 = JSON.parse(canvas.dataset.chartData2);
            const period1 = canvas.dataset.period1;
            const period2 = canvas.dataset.period2;
            renderComparisonChart(parameter, chartData1, chartData2, period1, period2, canvas.id);
          });
          
          document.querySelectorAll('.extremes-chart').forEach(canvas => {
            const parameter = canvas.dataset.parameter;
            const chartData = JSON.parse(canvas.dataset.chartData);
            const maxDate = canvas.dataset.maxDate;
            const minDate = canvas.dataset.minDate;
            renderExtremesChart(parameter, chartData, maxDate, minDate, canvas.id);
          });
          
          document.querySelectorAll('.correlation-chart').forEach(canvas => {
            const parameter1 = canvas.dataset.parameter1;
            const parameter2 = canvas.dataset.parameter2;
            const chartData = JSON.parse(canvas.dataset.chartData);
            renderCorrelationChart(parameter1, parameter2, chartData, canvas.id);
          });
        }, 100);
      };
      
    } catch (error) {
      console.error('Error inicializando chatbot:', error);
      chatbotReady = true;
      addMessage("丘멆잺 Hubo un problema al cargar los datos. Algunas funciones avanzadas podr칤an no estar disponibles.", false);
    }
  };

  // Event listeners
  sendButton.addEventListener('click', sendMessage);
  userInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') sendMessage();
  });
  
  // Inicializar el chatbot
  initChatbot();
</script>
</body>
</html>
