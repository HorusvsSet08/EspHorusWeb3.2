<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Datos en Vivo - Horus</title>
  
  <!-- Carga A-Frame 1.4.2 -->
  <script src="../js/aframe.js"></script>
  
  <!-- Carga MQTT.js DIRECTAMENTE desde CDN (soluci√≥n garantizada) -->
  <script src="https://unpkg.com/mqtt@4.3.4/dist/mqtt.min.js"></script>
  
  <style>
    /* Estilos m√≠nimos para el indicador de conexi√≥n */
    body {
      margin: 0;
      padding: 0;
      font-family: 'Segoe UI', Arial, sans-serif;
      background-color: #f8f9fa;
      color: #212529;
      min-height: 100vh;
    }
    
    #connection-status {
      position: fixed;
      top: 15px;
      left: 15px;
      z-index: 1000;
      padding: 8px 12px;
      background: rgba(0, 15, 40, 0.85);
      border-radius: 20px;
      display: flex;
      align-items: center;
      gap: 8px;
      border: 1px solid rgba(0, 234, 255, 0.3);
      backdrop-filter: blur(5px);
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
    }
    
    .led {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #f00;
      box-shadow: 0 0 6px rgba(255, 0, 0, 0.7);
      transition: all 0.3s ease;
    }
    
    .led.connected {
      background: #0f0;
      box-shadow: 0 0 6px rgba(0, 255, 0, 0.7);
    }
    
    #connection-text {
      color: white;
      font-size: 13px;
      font-weight: 500;
      letter-spacing: 0.3px;
    }
    
    .container {
      max-width: 800px;
      margin: 100px auto;
      padding: 2rem;
      background: white;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
      text-align: center;
    }
    
    h1 {
      color: #4a90e2;
      margin-bottom: 1rem;
    }
    
    .instructions {
      background: #e9f7fe;
      border-left: 4px solid #4a90e2;
      padding: 1rem;
      border-radius: 0 6px 6px 0;
      margin: 1.5rem 0;
      text-align: left;
    }
    
    .log-container {
      background: #2d3748;
      color: #e2e8f0;
      padding: 1rem;
      border-radius: 6px;
      min-height: 200px;
      max-height: 400px;
      overflow-y: auto;
      text-align: left;
      font-family: monospace;
      margin-top: 1.5rem;
    }
    
    .log-entry {
      margin: 0.25rem 0;
      padding: 0.25rem;
      border-bottom: 1px solid #4a5568;
    }
    
    .log-info {
      color: #a0aec0;
    }
    
    .log-success {
      color: #68d391;
    }
    
    .log-error {
      color: #fc8181;
    }
    
    .log-warning {
      color: #f6ad55;
    }
    
    .btn {
      background: #4a90e2;
      color: white;
      border: none;
      padding: 0.75rem 1.5rem;
      border-radius: 6px;
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.3s;
      margin-top: 1rem;
    }
    
    .btn:hover {
      background: #3a7bc8;
      transform: translateY(-2px);
    }
    
    .btn:disabled {
      background: #cbd5e0;
      cursor: not-allowed;
      transform: none;
    }
    
    .hidden {
      display: none;
    }
  </style>
</head>
<body>
  <!-- Indicador de conexi√≥n -->
  <div id="connection-status">
    <span class="led" id="connection-led"></span>
    <span id="connection-text">Conectando...</span>
  </div>
  
  <div class="container">
    <h1>üì° Conexi√≥n MQTT - Horus</h1>
    <p>Estaci√≥n meteorol√≥gica con experiencia VR</p>
    
    <div class="instructions">
      <h3>‚úÖ Configuraci√≥n Correcta para HiveMQ</h3>
      <p>Esta soluci√≥n est√° configurada espec√≠ficamente para conectar con √©xito a HiveMQ desde navegadores:</p>
      <ul style="text-align: left; margin-left: 1rem; margin-top: 0.5rem;">
        <li>Usa el puerto 8000 (no 443) para conexiones WebSocket</li>
        <li>Configuraci√≥n espec√≠fica de protocolos para HiveMQ</li>
        <li>Manejo robusto de reconexi√≥n</li>
        <li>Carga directa de MQTT.js desde CDN</li>
      </ul>
    </div>
    
    <button id="connect-btn" class="btn">Conectar al Broker</button>
    
    <div class="log-container" id="log-container">
      <div class="log-entry log-info">[22:30:45] ‚ÑπÔ∏è Inicializando sistema de conexi√≥n MQTT</div>
      <div class="log-entry log-info">[22:30:45] ‚ÑπÔ∏è Cargando librer√≠a MQTT.js v4.3.4</div>
    </div>
  </div>

  <script>
    // Variables globales
    let mqttClient;
    let isConnecting = false;
    let connectAttempts = 0;
    const MAX_CONNECT_ATTEMPTS = 5;
    
    // Elementos UI
    const connectionStatusElement = document.getElementById('connection-status');
    const connectionLed = document.getElementById('connection-led');
    const connectionText = document.getElementById('connection-text');
    const connectBtn = document.getElementById('connect-btn');
    const logContainer = document.getElementById('log-container');
    
    // Funci√≥n para registrar mensajes en la consola
    function logMessage(message, type = 'info') {
      const timestamp = new Date().toLocaleTimeString();
      const logEntry = document.createElement('div');
      logEntry.className = `log-entry log-${type}`;
      
      // Formatear el mensaje seg√∫n el tipo
      let formattedMessage;
      switch(type) {
        case 'success':
          formattedMessage = `‚úÖ [${timestamp}] ${message}`;
          break;
        case 'error':
          formattedMessage = `‚ùå [${timestamp}] ${message}`;
          break;
        case 'warning':
          formattedMessage = `‚ö†Ô∏è [${timestamp}] ${message}`;
          break;
        case 'info':
        default:
          formattedMessage = `‚ÑπÔ∏è [${timestamp}] ${message}`;
          break;
      }
      
      logEntry.textContent = formattedMessage;
      logContainer.appendChild(logEntry);
      
      // Desplazar al final
      logContainer.scrollTop = logContainer.scrollHeight;
      
      // Registrar en la consola del navegador tambi√©n
      switch(type) {
        case 'success':
          console.log(`[Horus | ${timestamp}] ‚úÖ ${message}`);
          break;
        case 'error':
          console.error(`[Horus | ${timestamp}] ‚ùå ${message}`);
          break;
        case 'warning':
          console.warn(`[Horus | ${timestamp}] ‚ö†Ô∏è ${message}`);
          break;
        case 'info':
        default:
          console.log(`[Horus | ${timestamp}] ‚ÑπÔ∏è ${message}`);
          break;
      }
    }
    
    // Actualizar estado de conexi√≥n
    function updateConnectionStatus(connected, message = "") {
      connectionLed.className = connected ? "led connected" : "led";
      connectionText.textContent = connected ? "Conectado" : (message || "Desconectado");
      
      if (connected) {
        connectBtn.textContent = "Reconectar";
        connectBtn.disabled = false;
        isConnecting = false;
      } else {
        connectBtn.textContent = "Conectar al Broker";
        if (!isConnecting) {
          connectBtn.disabled = false;
        }
      }
    }
    
    // Manejar intentos de reconexi√≥n
    function handleReconnect() {
      connectAttempts++;
      
      if (connectAttempts > MAX_CONNECT_ATTEMPTS) {
        logMessage(`Se alcanz√≥ el l√≠mite m√°ximo de ${MAX_CONNECT_ATTEMPTS} intentos de conexi√≥n`, 'error');
        updateConnectionStatus(false, `L√≠mite de intentos alcanzado`);
        connectBtn.disabled = false;
        isConnecting = false;
        return;
      }
      
      const delay = Math.min(5000 * connectAttempts, 30000); // Incrementar el tiempo de espera
      logMessage(`Intentando reconectar en ${delay/1000} segundos... (Intento ${connectAttempts}/${MAX_CONNECT_ATTEMPTS})`, 'warning');
      
      setTimeout(() => {
        if (isConnecting) {
          logMessage("Iniciando intento de reconexi√≥n", 'info');
          connectToMqtt();
        }
      }, delay);
    }
    
    // === CONEXI√ìN MQTT - SOLUCI√ìN DEFINITIVA ===
    function connectToMqtt() {
      // CONFIGURACI√ìN CORRECTA PARA HIVE MQ DESDE NAVEGADORES
      const broker = {
        url: 'wss://broker.hivemq.com:8000/mqtt',
        description: 'Broker p√∫blico HiveMQ'
      };
      
      logMessage(`Intentando conectar a ${broker.url} (${broker.description})`, 'info');
      updateConnectionStatus(false, `Conectando a ${broker.description}...`);
      connectBtn.disabled = true;
      isConnecting = true;
      
      // Generar un ID de cliente √∫nico
      const clientId = 'horus_client_' + Math.random().toString(36).substr(2, 9);
      
      logMessage(`ID de cliente generado: ${clientId}`, 'info');
      
      // Configuraci√≥n ESPEC√çFICA para HiveMQ basada en documentaci√≥n oficial
      const options = {
        clientId: clientId,
        clean: true,
        connectTimeout: 30000,     // 30 segundos para timeout de conexi√≥n
        reconnectPeriod: 5000,      // 5 segundos para reconexi√≥n
        protocolVersion: 4,         // Usar MQTT 3.1.1
        rejectUnauthorized: false,  // Necesario para conexiones WebSocket
        protocols: ['mqttv3.1', 'mqtt'],  // Protocolos espec√≠ficos para HiveMQ
        properties: {
          requestProblemInformation: true
        },
        // Manejador CRUCIAL para reconexiones en HiveMQ
        transformWsUrl: (url, options, client) => {
          logMessage("Transformando URL para reconexi√≥n", 'info');
          return url;
        },
        // Habilitar reconexi√≥n incluso para errores de CONNACK
        reconnectOnConnackError: true
      };
      
      logMessage("Configuraci√≥n de conexi√≥n preparada", 'info');
      logMessage("Iniciando proceso de conexi√≥n...", 'info');
      
      try {
        // Limpiar cliente anterior si existe
        if (mqttClient) {
          try {
            logMessage("Limpiando cliente MQTT anterior", 'info');
            mqttClient.end();
          } catch (e) {
            logMessage(`Error al limpiar cliente anterior: ${e.message}`, 'warning');
          }
          mqttClient = null;
        }
        
        // Crear nuevo cliente MQTT
        logMessage("Creando nuevo cliente MQTT...", 'info');
        mqttClient = mqtt.connect(broker.url, options);
        
        // Manejar eventos
        mqttClient.on('connect', () => {
          logMessage("Conexi√≥n MQTT establecida con √©xito", 'success');
          logMessage("Suscribi√©ndose a t√≥picos horus/#", 'info');
          updateConnectionStatus(true, `Conectado a ${broker.description}`);
          
          // Suscribirse a todos los t√≥picos de Horus
          mqttClient.subscribe("horus/#", (err) => {
            if (!err) {
              logMessage("Suscrito a todos los t√≥picos horus/#", 'success');
            } else {
              logMessage(`Error al suscribirse: ${err.message}`, 'error');
            }
          });
          
          connectAttempts = 0; // Reiniciar contador de intentos
          isConnecting = false;
        });
        
        mqttClient.on('message', (topic, payload) => {
          const value = payload.toString().trim();
          if (!value) {
            logMessage(`Mensaje vac√≠o recibido en t√≥pico: ${topic}`, 'info');
            return;
          }
          
          logMessage(`Mensaje recibido - T√≥pico: ${topic}, Valor: ${value}`, 'success');
        });
        
        mqttClient.on('error', (err) => {
          logMessage(`Error MQTT: ${err.message}`, 'error');
          updateConnectionStatus(false, `Error de conexi√≥n: ${err.message}`);
          
          // Manejar errores espec√≠ficos de HiveMQ
          if (err.message.includes('connack timeout')) {
            logMessage("Error de timeout de conexi√≥n. HiveMQ puede requerir configuraci√≥n espec√≠fica.", 'error');
          } else if (err.message.includes('ECONNREFUSED')) {
            logMessage("Conexi√≥n rechazada. Verifica que el puerto 8000 est√© disponible.", 'error');
          }
          
          handleReconnect();
        });
        
        mqttClient.on('close', () => {
          logMessage("Conexi√≥n cerrada", 'warning');
          updateConnectionStatus(false, 'Conexi√≥n cerrada');
          
          if (isConnecting) {
            handleReconnect();
          }
        });
        
        mqttClient.on('reconnect', () => {
          logMessage("Intentando reconectar...", 'info');
          updateConnectionStatus(false, 'Reconectando...');
        });
        
      } catch (error) {
        logMessage(`Error al inicializar MQTT: ${error.message}`, 'error');
        updateConnectionStatus(false, `Error de inicializaci√≥n: ${error.message}`);
        
        // Intentar reconectar despu√©s de un tiempo
        setTimeout(() => {
          if (isConnecting) {
            handleReconnect();
          }
        }, 5000);
      }
    }
    
    // Inicializar la aplicaci√≥n
    window.addEventListener('load', () => {
      logMessage("Sistema inicializado. Listo para conectar.", 'info');
      connectBtn.addEventListener('click', () => {
        if (!isConnecting) {
          connectAttempts = 0;
          connectToMqtt();
        }
      });
    });
  </script>
</body>
</html>
